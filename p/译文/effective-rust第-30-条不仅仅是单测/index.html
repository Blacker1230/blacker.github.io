<!doctype html><html lang=zh-Hans dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="本文为 effective-rust 第 30 条译文。"><title>【译文/effective-rust】第 30 条：不仅仅是单测</title>
<link rel=canonical href=https://liyan-ah.github.io/p/%E8%AF%91%E6%96%87/effective-rust%E7%AC%AC-30-%E6%9D%A1%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E5%8D%95%E6%B5%8B/><link rel=stylesheet href=/scss/style.min.8e60baf4cd3fc55968717a6e39762f4d28ed7ef6007566b6c7970ad0fe907198.css><meta property='og:title' content="【译文/effective-rust】第 30 条：不仅仅是单测"><meta property='og:description' content="本文为 effective-rust 第 30 条译文。"><meta property='og:url' content='https://liyan-ah.github.io/p/%E8%AF%91%E6%96%87/effective-rust%E7%AC%AC-30-%E6%9D%A1%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E5%8D%95%E6%B5%8B/'><meta property='og:site_name' content='李岩'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='译文'><meta property='article:tag' content='effective-rust'><meta property='article:published_time' content='2024-09-08T16:35:05+08:00'><meta property='article:modified_time' content='2024-09-08T16:35:05+08:00'><meta name=twitter:title content="【译文/effective-rust】第 30 条：不仅仅是单测"><meta name=twitter:description content="本文为 effective-rust 第 30 条译文。"><link rel="shortcut icon" href=/icon.jpg></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu16177073813840188542.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>李岩</a></h1><h2 class=site-description>努力做个工程师。</h2></div></header><ol class=menu-social><li><a href=https://github.com/liyan-ah/liyan-ah.github.io/issues/new target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#单元测试>单元测试</a></li><li><a href=#集成测试>集成测试</a></li><li><a href=#文档测试>文档测试</a></li><li><a href=#代码示例>代码示例</a></li><li><a href=#基准测试>基准测试</a></li><li><a href=#模糊测试>模糊测试</a></li><li><a href=#测试的建议>测试的建议</a></li><li><a href=#需要注意的点>需要注意的点</a><ol><li><a href=#注释>注释</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/ style=background-color:#2a9d8f;color:#fff>程序人生</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/%E8%AF%91%E6%96%87/effective-rust%E7%AC%AC-30-%E6%9D%A1%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E5%8D%95%E6%B5%8B/>【译文/effective-rust】第 30 条：不仅仅是单测</a></h2><h3 class=article-subtitle>本文为 effective-rust 第 30 条译文。</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Sep 08, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 11 分钟</time></div></footer></div></header><section class=article-content><blockquote><p>“所有的公司都拥有测试环境。但只有那些幸运的公司拥有独立于测试环境的生产环境。” —— @FearlessSon</p></blockquote><p>和大多数其他的现代编程语言一样，Rust 也包含一些便于<a class=link href=https://doc.rust-lang.org/book/ch11-00-testing.html target=_blank rel=noopener>编写测试</a>的特性。借助这些特性，你可以将单测和代码共存。而通过测试，可以提升代码运行准确性的信心。</p><p>这并非是兜售测试重要性的文章。从测试最基本功能来说，如果代码缺少了测试，它很可能并非如我们所希望的那样运行。本条目是在你已经建立了<strong>为代码编写测试</strong>这一信念的基础上展开的。</p><p>单元测试（unit tests）以及集成测试（integration tests）是测试领域内的两大重要成员。在接下来的两节内将会介绍。但是，Rust 工具链，也包括它的扩展，允许多种多样的测试形式。本条目将会介绍它们的基本使用流程及应用场景。</p><h2 id=单元测试><a href=#%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95>#</a>
单元测试</h2><p>Rust 代码中最常见的测试类型是单元测试：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// ... (code defining `nat_subtract*` functions for natural
</span></span></span><span class=line><span class=cl><span class=c1>//      number subtraction)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[cfg(test)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>mod</span> <span class=nn>tests</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=k>super</span>::<span class=o>*</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>test_nat_subtract</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>nat_subtract</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>).</span><span class=n>unwrap</span><span class=p>(),</span><span class=w> </span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>nat_subtract</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>),</span><span class=w> </span><span class=nb>None</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[should_panic]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[test]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>test_something_that_panics</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>nat_subtract_unchecked</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这段单测示例体现了 Rust 所有单测都会有的形式：</p><ul><li>使用模块对单测函数进行封装。</li><li>每个单测都会使用<code>#[test]</code>属性来进行标志。</li><li>用来测试的模块使用<code>#[cfg(test)]</code>进行声明，所以单测的代码仅会在测试时生效。</li></ul><p>示例也展示了一些仅在特定测试中才会出现的形式：</p><ul><li>这里的测试代码放置在单独的模块里，模块名一般为<code>tests</code>或者<code>test</code>。这个模块可以和逻辑代码放置在一起，或者放置在单独的<em>tests.rs</em>文件里。放置在单独的文件里可以让人更加便捷的区分代码是用来测试的，还是用于一般的功能逻辑。</li><li>测试的模块可以使用一个通配符<code>use super::*</code>来将父模块的所有依赖都声明到测试模块里。这种操作可以让编写测试代码更加方便（同时依据<a class=link href=https://rustx-labs.github.io/effective-rust-cn/chapter_4/item23-wildcard.html target=_blank rel=noopener>第 23 条</a>来说，通配符的引入是一种要规避的操作）。</li><li>在模块的一般可达性规则下，单测可以使用所有父模块里包含的内容，无论是否声明为公共的。基于单测对内部功能可访问的特点，可以对代码进行“开箱”测试。</li><li>测试代码使用<code>expect()</code>或者<code>unwrap()</code>来标志其希望的结果。显然，<a class=link href=https://rustx-labs.github.io/effective-rust-cn/chapter_3/item18-panic.html target=_blank rel=noopener>第 18 条</a>中声明的规则并不适用这些单测的代码。单测中需要使用<code>panic!</code>来标注失败的结果。同样的，测试的代码中也会使用<code>assert_eq!</code>来校验期待的值，并且会在失败时抛出<code>panic</code>。</li><li>测试代码中使用了一个函数，该函数在一些非法的输入下会造成<code>panic</code>。为了校验该函数的这一功能是否生效，单测的函数中使用了<code>#[should_panic]</code>特性。这一特性在需要测试一个内部函数且希望保持这个函数的各校验规则不发生改变，或者测试一个公共的函数且由于一些原因需要忽略<a class=link href=https://rustx-labs.github.io/effective-rust-cn/chapter_3/item18-panic.html target=_blank rel=noopener>第 18 条</a>中的建议。（这样的函数需要在它的注释文档中有“Panics”小节，就像<a class=link href=https://rustx-labs.github.io/effective-rust-cn/chapter_5/item27-document-public-interfaces.html target=_blank rel=noopener>第 27 条</a>中描述的。）</li></ul><p><a class=link href=https://rustx-labs.github.io/effective-rust-cn/chapter_5/item27-document-public-interfaces.html target=_blank rel=noopener>第 27 条</a>中建议不要对已经通过类型表述出的内容。同样的，也不需要对已经由类型进行约束的内容进行测试。如果你的<code>enum</code>类型派生出了不在声明列表中罗列的变量，你可能遇到了比单测失败更加严重的问题。</p><p>然而，如果你的代码依赖了一些依赖库中的独特功能，对这些功能准备基础的单测会很有用。这里的单测目的并非是重复依赖中已经具备的功能测试，而是尽量早地暴露依赖的包依赖的这些功能发生了变更的风险 —— 尤其是公共的接口约定发生了变化，通常应当通过版本号来表明（<a class=link href=https://www.lurklurk.org/effective-rust/semver.html target=_blank rel=noopener>第 21 条</a>）。</p><h2 id=集成测试><a href=#%e9%9b%86%e6%88%90%e6%b5%8b%e8%af%95>#</a>
集成测试</h2><p>Rust 项目中另一种常用到的测试模式是：<em>集成测试</em>（integration tests），测试通常被放置在<code>tests/</code>目录下。这个目录下的每个文件都会作为一个单独的测试程序运行，每个测试程序都会执行其包含的所有以<code>#[test]</code>标志的测试函数。</p><p>集成测试没有访问包内部内容的权限，因此集成测试仅能覆盖包的公共 API。</p><h2 id=文档测试><a href=#%e6%96%87%e6%a1%a3%e6%b5%8b%e8%af%95>#</a>
文档测试</h2><p><a class=link href=https://rustx-labs.github.io/effective-rust-cn/chapter_5/item27-document-public-interfaces.html target=_blank rel=noopener>第 27 条</a>描述了在注释中包含一小段代码的示例，通常是为了说明特定的公共 API 的使用方式。每段这样的代码都包含在一个隐式的<code>fn main() { ... }</code>函数中，并且可以在<code>cargo test</code>时被执行。这是一种高效的代码添加测试用例的方法，一般被称为<em>文档测试</em>（doc tests）。每个类似的测试都可以通过<code>cargo test --doc &lt;item-name></code>的方式来选择性的执行。</p><p>定期的通过 CI 系统（<a class=link href=https://www.lurklurk.org/effective-rust/ci.html target=_blank rel=noopener>第 32 条</a>）来执行这些测试可以确保代码不会离包中期望提供的 API 太远。</p><h2 id=代码示例><a href=#%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b>#</a>
代码示例</h2><p><a class=link href=https://rustx-labs.github.io/effective-rust-cn/chapter_5/item27-document-public-interfaces.html target=_blank rel=noopener>第 27 条</a>也描述了为公共接口提供示例代码的实践。在<code>examples/</code>目录下的每个 Rust 文件（或者<code>examples</code>目录下每个子目录中的<code>main.rs</code>文件）都可以通过<code>cargo run --example &lt;name></code>或者<code>cargo test --example &lt;name></code>的方式来作为独立的可执行文件运行。</p><p>这些程序仅能访问包中的公共接口，并且可以说明这些公共接口的使用方式。示例代码并非被设计为测试代码（没有<code>#[test]</code>，没有<code>[cfg(test)]</code>的标注），而且由于处于一些不起眼的角落，它们并不适合放置代码 —— 尤其是，它们并不在<code>cargo test</code>时默认执行。</p><p>尽管如此，CI 系统（<a class=link href=https://www.lurklurk.org/effective-rust/ci.html target=_blank rel=noopener>第 32 条</a>）构建并且运行这些示例代码（通过<code>cargo test --examples</code>）仍然是一个很好的实践。通过执行这些代码，可以为那些会影响大多数用户的接口提供一个很好的回归校验机制。特别地，如果你的示例揭示了接口使用的一般方式，那么示例运行的失败往往意味着存在如下的错误：</p><ul><li>如果这是个高超的错误，它可能会影响很多用户 —— 示例中的代码将会被很多用户复制、粘贴或者参照。</li><li>如果公共接口发生了变更，那么这些示例也需要参照最新的接口定义来实现。接口的改变往往意味着不兼容。所以当包被发布时，版本号需要随着调整以说明这是个不兼容的升级（<a class=link href=https://www.lurklurk.org/effective-rust/semver.html target=_blank rel=noopener>第 21 条</a>）。</li></ul><p>用户复制、粘贴测试代码的行为意味着示例代码和测试代码的形式有很大的不同。如<a class=link href=https://rustx-labs.github.io/effective-rust-cn/chapter_3/item18-panic.html target=_blank rel=noopener>第 18 条</a>中描述的一样，你可以避免对 Results 进行 unwrap() 使用，从而为用户提供一个很好的参照。同样的，在每个示例代码的<code>main()</code>函数中返回类似<code>Result&lt;(), Box&lt;dyn Error>></code>的结果，并且在内部使用<code>?</code>符号来组织代码（<a class=link href=https://rustx-labs.github.io/effective-rust-cn/chapter_1/item3-transform.html target=_blank rel=noopener>第 3 条</a>）也是一种很好的行为。</p><h2 id=基准测试><a href=#%e5%9f%ba%e5%87%86%e6%b5%8b%e8%af%95>#</a>
基准测试</h2><p>[第 20 条]试图说明极致的代码性能优化并非总是必要的。尽管如此，有时性能肯定时很关键的，并且在这种情况下，衡量以及追踪代码的性能变化是很好的实践。具备定期运行的<em>基准测试</em>（benchmarks）（比如，作为 CI 系统的一部分，<a class=link href=https://www.lurklurk.org/effective-rust/ci.html target=_blank rel=noopener>第 32 条</a>）允许你发觉代码或者工具链的变更可以如何影响代码的性能。</p><p><code>[cargo bench]</code>命令可以运行重复执行特定操作的测试代码，并且计算出这个操作的平均耗时。在撰写本文时，Rust 对基准测试的支持还不太稳定，所以基准测试相关的指令需要通过<code>cargo +nightly bench</code>的方式来执行。（Rust 不稳定的特性，包括本文中使用的<a class=link href=https://doc.rust-lang.org/unstable-book/library-features/test.html target=_blank rel=noopener>test</a>特性，都描述在 Rust <a class=link href=https://doc.rust-lang.org/unstable-book/the-unstable-book.html target=_blank rel=noopener>Unstable Book</a>中。）</p><p>然而，这里存在着编译器给出错误结果的风险，尤其是当你将操作约束在很简单的代码时。考虑如下一个简单的算数函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>factorial</span><span class=p>(</span><span class=n>n</span>: <span class=kt>u128</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>u128</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=mi>0</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>n</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>factorial</span><span class=p>(</span><span class=n>n</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这段代码的一个简单的基准测试实现是：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#![feature(test)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>extern</span><span class=w> </span><span class=k>crate</span><span class=w> </span><span class=n>test</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[bench]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>bench_factorial</span><span class=p>(</span><span class=n>b</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>test</span>::<span class=n>Bencher</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>b</span><span class=p>.</span><span class=n>iter</span><span class=p>(</span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>factorial</span><span class=p>(</span><span class=mi>15</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>result</span><span class=p>,</span><span class=w> </span><span class=mi>1_307_674_368_000</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>输出了一段奇妙的结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>test</span><span class=w> </span><span class=n>bench_factorial</span><span class=w>             </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=n>bench</span>:           <span class=mi>0</span><span class=w> </span><span class=n>ns</span><span class=o>/</span><span class=n>iter</span><span class=w> </span><span class=p>(</span><span class=o>+/-</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>由于在测试过程中使用固定的输入以及很少的代码指令，编译器可能会对迭代进行优化并且直接输出计算结果。这就将会导致不切实际的测试结论。</p><p>使用 <a class=link href=https://doc.rust-lang.org/std/hint/fn.black_box.html target=_blank rel=noopener>std::hint::black_box</a> 可以解决这一问题。这是一个标志函数，<a class=link href=https://rust-lang.github.io/rfcs/2360-bench-black-box.html target=_blank rel=noopener>编辑器识别后将不</a>对其进行优化。</p><p>上述基准测试可以变更为如下形式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[bench]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>bench_factorial</span><span class=p>(</span><span class=n>b</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>test</span>::<span class=n>Bencher</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>b</span><span class=p>.</span><span class=n>iter</span><span class=p>(</span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>factorial</span><span class=p>(</span><span class=n>std</span>::<span class=n>hint</span>::<span class=n>black_box</span><span class=p>(</span><span class=mi>15</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>result</span><span class=p>,</span><span class=w> </span><span class=mi>1_307_674_368_000</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>给出了如下更加接近实际的结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>test</span><span class=w> </span><span class=n>blackboxed</span>::<span class=n>bench_factorial</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=n>bench</span>:          <span class=mi>16</span><span class=w> </span><span class=n>ns</span><span class=o>/</span><span class=n>iter</span><span class=w> </span><span class=p>(</span><span class=o>+/-</span><span class=w> </span><span class=mi>3</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><a class=link href=https://rust.godbolt.org/ target=_blank rel=noopener>Godbolt 编辑资源管理器</a>也可以通过展示实际的机器码的方式来辅助测试，这样就能让实际执行的优化后的字节码变得清晰以确认是否过度优化而不能得到实际的结果。</p><p>最后，如果你为 Rust 代码准备了基准测试，<a class=link href=https://crates.io/crates/criterion target=_blank rel=noopener>criterion</a>包可能提供了<a class=link href=https://doc.rust-lang.org/test/bench/struct.Bencher.html target=_blank rel=noopener>test::bench::Bencher</a>的替代品，而且使用起来更加便捷（可以在稳定的 Rust 工具链上运行），功能也更多（支持结果的数据统计及图表）。</p><h2 id=模糊测试><a href=#%e6%a8%a1%e7%b3%8a%e6%b5%8b%e8%af%95>#</a>
模糊测试</h2><p>模糊测试（fuzzy testing）是将代码暴露在随机输入中以期能够发现错误，尤其导致异常的场景，的测试方法。从技术校验的角度来说它已经很重要了，而当你的输入会被其他人填充或者攻击时，它将会显得更加重要 —— <strong>所以如果你的代码输入可能暴露给潜在的攻击者时，你应当使用模糊测试</strong>。</p><p>从历史上来看，C/C++ 代码通过模糊测试发现的往往时内存安全问题，通常会通过结合模糊测试与内存访问模式的运行时结合来检测（比如<a class=link href=https://clang.llvm.org/docs/AddressSanitizer.html target=_blank rel=noopener>AddressSanitizer</a>或者<a class=link href=https://clang.llvm.org/docs/ThreadSanitizer.html target=_blank rel=noopener>ThreadSanitizer</a>）。</p><p>Rust 对其中的一些（但并非全部）内存安全问题免疫，尤其是未引入<code>unsafe</code>的代码时（<a class=link href=https://rustx-labs.github.io/effective-rust-cn/chapter_3/item16-unsafe.html target=_blank rel=noopener>第 16 条</a>）。然而，Rust 并不能杜绝全部的错误，触发<code>panic!</code>（<a class=link href=https://rustx-labs.github.io/effective-rust-cn/chapter_3/item18-panic.html target=_blank rel=noopener>第 18 条</a>）的代码仍可能引发导致拒绝服务攻击（denial-of-service，DOS）。</p><p>模糊测试的最佳实践是以<em>覆盖率引导</em>：测试的基础设施监控代码的哪些部分被执行，随机更改输入直至能够触发新的代码路径。“<a class=link href=https://lcamtuf.coredump.cx/afl/ target=_blank rel=noopener>American fuzzy lop</a>”（AFL）是其中的佼佼者。但是近些年来，类似的功能已经被引入了 LLVM 的工具链，比如<a class=link href=https://llvm.org/docs/LibFuzzer.html target=_blank rel=noopener>libFuzzer</a>。</p><p>Rust 编译器是在 LLVM 的基础上构建的，因此<a class=link href=https://github.com/rust-fuzz/cargo-fuzz target=_blank rel=noopener>cargo-fuzz</a>自然地为 Rust 引入了<code>libFuzzer</code>（仅在部分平台上可用）。</p><p>模糊测试的首要要求是确定代码的入口点，该入口点需要采用（或者可以适应）任意字节的数据作为输入：</p><div class=ferris><img src=../images/ferris/not_desired_behavior.svg width=75 height=75></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=sd>/// Determine if the input starts with &#34;FUZZ&#34;.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>is_fuzz</span><span class=p>(</span><span class=n>data</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=kt>u8</span><span class=p>])</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>data</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=cm>/* oops */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>data</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sa>b</span><span class=sc>&#39;F&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>data</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sa>b</span><span class=sc>&#39;U&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>data</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sa>b</span><span class=sc>&#39;Z&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>data</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sa>b</span><span class=sc>&#39;Z&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>当目标入口点确定后，Rust <a class=link href=https://rust-fuzz.github.io/book/ target=_blank rel=noopener>Fuzz Book</a>给出了如何启动测试的说明。它的核心是一个小型的驱动程序，会将目标入口点连接到模糊测试的基础设施上：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// fuzz/fuzz_targets/target1.rs file
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#![no_main]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>libfuzzer_sys</span>::<span class=n>fuzz_target</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>fuzz_target!</span><span class=p>(</span><span class=o>|</span><span class=n>data</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=kt>u8</span><span class=p>]</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>somecrate</span>::<span class=n>is_fuzz</span><span class=p>(</span><span class=n>data</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>});</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>运行<code>cargo +nightly fuzz run target1</code>将会持续使用随机数据来执行模糊测试的目标函数，直至异常出现。上述示例中，错误将被立即发现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=no>INFO</span>: <span class=nc>Running</span><span class=w> </span><span class=n>with</span><span class=w> </span><span class=n>entropic</span><span class=w> </span><span class=n>power</span><span class=w> </span><span class=n>schedule</span><span class=w> </span><span class=p>(</span><span class=mh>0xFF</span><span class=p>,</span><span class=w> </span><span class=mi>100</span><span class=p>).</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=no>INFO</span>: <span class=nc>Seed</span>: <span class=mi>1607525774</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=no>INFO</span>: <span class=nc>Loaded</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=n>modules</span>: <span class=mi>1624</span><span class=w> </span><span class=p>[</span><span class=mh>0x108219fa0</span><span class=p>,</span><span class=w> </span><span class=mh>0x10821a5f8</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=no>INFO</span>: <span class=nc>Loaded</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=no>PC</span><span class=w> </span><span class=n>tables</span><span class=w> </span><span class=p>(</span><span class=mi>1624</span><span class=w> </span><span class=n>PCs</span><span class=p>)</span>: <span class=mi>1624</span><span class=w> </span><span class=p>[</span><span class=mh>0x10821a5f8</span><span class=p>,</span><span class=mh>0x108220b78</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=no>INFO</span>:        <span class=mi>9</span><span class=w> </span><span class=n>files</span><span class=w> </span><span class=n>found</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>fuzz</span><span class=o>/</span><span class=n>corpus</span><span class=o>/</span><span class=n>target1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=no>INFO</span>: <span class=nc>seed</span><span class=w> </span><span class=n>corpus</span>: <span class=nc>files</span>: <span class=mi>9</span><span class=w> </span><span class=n>min</span>: <span class=mi>1</span><span class=n>b</span><span class=w> </span><span class=n>max</span>: <span class=mi>8</span><span class=n>b</span><span class=w> </span><span class=n>total</span>: <span class=mi>46</span><span class=n>b</span><span class=w> </span><span class=n>rss</span>: <span class=mi>38</span><span class=n>Mb</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>#<span class=mi>10</span><span class=w>	</span><span class=no>INITED</span><span class=w> </span><span class=n>cov</span>: <span class=mi>26</span><span class=w> </span><span class=n>ft</span>: <span class=mi>26</span><span class=w> </span><span class=n>corp</span>: <span class=mi>6</span><span class=o>/</span><span class=mi>22</span><span class=n>b</span><span class=w> </span><span class=n>exec</span><span class=o>/</span><span class=n>s</span>: <span class=mi>0</span><span class=w> </span><span class=n>rss</span>: <span class=mi>39</span><span class=n>Mb</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>thread</span><span class=w> </span><span class=n>panicked</span><span class=w> </span><span class=n>at</span><span class=w> </span><span class=na>&#39;index</span><span class=w> </span><span class=n>out</span><span class=w> </span><span class=n>of</span><span class=w> </span><span class=n>bounds</span>: <span class=nc>the</span><span class=w> </span><span class=n>len</span><span class=w> </span><span class=n>is</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=n>but</span><span class=w> </span><span class=n>the</span><span class=w> </span><span class=n>index</span><span class=w> </span><span class=n>is</span><span class=w> </span><span class=mi>3</span><span class=na>&#39;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=n>testing</span><span class=o>/</span><span class=n>src</span><span class=o>/</span><span class=n>lib</span><span class=p>.</span><span class=n>rs</span>:<span class=mi>77</span>:<span class=mi>12</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>stack</span><span class=w> </span><span class=n>backtrace</span>:
</span></span><span class=line><span class=cl>   <span class=mi>0</span>: <span class=nc>rust_begin_unwind</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>             </span><span class=n>at</span><span class=w> </span><span class=o>/</span><span class=n>rustc</span><span class=o>/</span><span class=n>f77bfb7336f2</span><span class=o>/</span><span class=n>library</span><span class=o>/</span><span class=n>std</span><span class=o>/</span><span class=n>src</span><span class=o>/</span><span class=n>panicking</span><span class=p>.</span><span class=n>rs</span>:<span class=mi>579</span>:<span class=mi>5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=mi>1</span>: <span class=nc>core</span>::<span class=n>panicking</span>::<span class=n>panic_fmt</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>             </span><span class=n>at</span><span class=w> </span><span class=o>/</span><span class=n>rustc</span><span class=o>/</span><span class=n>f77bfb7336f2</span><span class=o>/</span><span class=n>library</span><span class=o>/</span><span class=n>core</span><span class=o>/</span><span class=n>src</span><span class=o>/</span><span class=n>panicking</span><span class=p>.</span><span class=n>rs</span>:<span class=mi>64</span>:<span class=mi>14</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=mi>2</span>: <span class=nc>core</span>::<span class=n>panicking</span>::<span class=n>panic_bounds_check</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>             </span><span class=n>at</span><span class=w> </span><span class=o>/</span><span class=n>rustc</span><span class=o>/</span><span class=n>f77bfb7336f2</span><span class=o>/</span><span class=n>library</span><span class=o>/</span><span class=n>core</span><span class=o>/</span><span class=n>src</span><span class=o>/</span><span class=n>panicking</span><span class=p>.</span><span class=n>rs</span>:<span class=mi>159</span>:<span class=mi>5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=mi>3</span>: <span class=nc>somecrate</span>::<span class=n>is_fuzz</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=mi>4</span>: <span class=nc>_rust_fuzzer_test_input</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=mi>5</span>: <span class=nc>___rust_try</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=mi>6</span>: <span class=nc>_LLVMFuzzerTestOneInput</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=mi>7</span>: <span class=nc>__ZN6fuzzer6Fuzzer15ExecuteCallbackEPKhm</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=mi>8</span>: <span class=nc>__ZN6fuzzer6Fuzzer6RunOneEPKhmbPNS_9InputInfoEbPb</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=mi>9</span>: <span class=nc>__ZN6fuzzer6Fuzzer16MutateAndTestOneEv</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=mi>10</span>: <span class=nc>__ZN6fuzzer6Fuzzer4LoopERNSt3__16vectorINS_9SizedFileENS_</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=mi>16</span><span class=n>fuzzer_allocatorIS3_EEEE</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=mi>11</span>: <span class=nc>__ZN6fuzzer12FuzzerDriverEPiPPPcPFiPKhmE</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=mi>12</span>: <span class=nc>_main</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>导致上述错误的测试数据也给出了。</p><p>一般来说，模糊测试并不能如此快地发现错误，因此将模糊测试作为 CI 流程中的一部分也是没有意义的。模糊测试的不确定性及随之而来的计算成本意味着你需要考虑如何开展以及何时开展模糊测试 —— 可能仅需要在新的发布版本或者主要变更发生时才运行，或者仅运行确定性的时间<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。</p><p>你也可以通过存储和重用先前模糊测试程序已找到用来触发新的代码路径的语料库的方式来加速模糊测试的执行。这将有助于后续的模糊测试过程将时间放在尝试新的输入上，而非重新测试以前访问过的代码路径。</p><h2 id=测试的建议><a href=#%e6%b5%8b%e8%af%95%e7%9a%84%e5%bb%ba%e8%ae%ae>#</a>
测试的建议</h2><p>一般性的建议也适用于 Rust 项目中：</p><ul><li>由于测试是需要持续进行的，<strong>每次变更后都需要在 CI 中执行单测</strong>（除了模糊测试）。</li><li>当你在修复一个错误时，<strong>在修复前，准备一个能反映错误的测试用例</strong>。这样当你完成错误的修复时，就可以通过测试用例的执行来说名修复效果。并且在未来不会重新引入。</li><li>如果你的包中包含了某些功能（[第 26 条]），<strong>对所有可能的功能组合都要进行测试</strong>。</li><li>更一般性的，如果你的包中包含了任何特殊的配置，（比如，<code>#[cfg(target_os="windows")]</code>），<strong>每种包含了独特配置的平台上的测试都需要运行</strong>。</li></ul><p>这些建议包含了很多不同类型的测试，在项目中应当选择那些最有价值的测试。</p><p>如果你有很多测试的代码并且会将你的包推送到<a class=link href=https://crates.io/ target=_blank rel=noopener>crates.io</a>中，那么就需要考虑下哪些测试项发布后是有意义的。一般地，<code>cargo</code>项目中会包含单元测试、集成测试、基准测试以及代码示例（但是并没有包含模糊测试，因为<code>cargo-fuzz</code>工具会将模糊测试的内容放置在包的子目录中）等等远超一般用户使用所需要的测试项。如果某些测试项并非是必须的，你可以<a class=link href=https://doc.rust-lang.org/cargo/reference/manifest.html#the-exclude-and-include-fields target=_blank rel=noopener>移除</a>一些测试项或者将这些测试项（尤其是行为性的测试）移入单独的测试包中。</p><h2 id=需要注意的点><a href=#%e9%9c%80%e8%a6%81%e6%b3%a8%e6%84%8f%e7%9a%84%e7%82%b9>#</a>
需要注意的点</h2><ul><li>编写单元测试来达到全面测试的目的，包括仅包含内部代码的测试。通过<code>cargo test</code>来运行它们。</li><li>编写集成测试代码来测试公共的接口。通过<code>cargo test</code>来运行它们。</li><li>编写文档测试来校验公共接口的调用方式。通过<code>cargo test</code>来调用它们。</li><li>编写示例代码来完整的说明如何使用包中的公共 API。通过<code>cargo test --exmaples</code>或者<code>cargo run --example &lt;name></code>的方式来运行它们。</li><li>如果代码对性能有很明确的要求，编写基准测试来确认代码的性能表现。通过<code>cargo bench</code>来执行它们。</li><li>如果代码会暴露在未被信任的输入中，编写模糊测试来确认对输入的参数的约束。通过<code>cargo fuzz</code>来（持续地）运行它们。</li></ul><h3 id=注释><a href=#%e6%b3%a8%e9%87%8a>#</a>
注释</h3><p>原文<a class=link href=https://www.lurklurk.org/effective-rust/testing.html target=_blank rel=noopener>点这里</a>查看</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>如果你的代码是一个被广泛运用的开源包，<a class=link href=https://google.github.io/oss-fuzz/getting-started/accepting-new-projects/ target=_blank rel=noopener>Google OSS-Fuzz program</a>可以为你的项目进行模糊测试。&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></section><footer class=article-footer><section class=article-tags><a href=/tags/%E8%AF%91%E6%96%87/>译文</a>
<a href=/tags/effective-rust/>Effective-Rust</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/%E8%AF%91%E6%96%87/effective-rust%E7%AC%AC-29-%E6%9D%A1%E9%81%B5%E5%BE%AA-clippy-%E7%9A%84%E5%BB%BA%E8%AE%AE/><div class=article-details><h2 class=article-title>【译文/effective-rust】第 29 条：遵循 Clippy 的建议</h2></div></a></article><article><a href=/p/%E8%AF%91%E6%96%87/effective-rust%E7%AC%AC-28-%E6%9D%A1%E5%9C%A8%E5%90%88%E9%80%82%E7%9A%84%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%AE%8F/><div class=article-details><h2 class=article-title>【译文/effective-rust】第 28 条：在合适的时候使用宏</h2></div></a></article><article><a href=/p/%E8%AF%91%E6%96%87/effective-rust%E7%AC%AC-27-%E6%9D%A1%E4%B8%BA%E5%85%AC%E5%85%B1%E6%8E%A5%E5%8F%A3%E6%92%B0%E5%86%99%E6%96%87%E6%A1%A3/><div class=article-details><h2 class=article-title>【译文/effective-rust】第 27 条：为公共接口撰写文档</h2></div></a></article><article><a href=/p/emacs-%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%E5%BF%AB%E6%8D%B7%E9%94%AE/><div class=article-details><h2 class=article-title>Emacs 字符操作快捷键</h2></div></a></article><article><a href=/p/bpftrace-%E9%81%8D%E5%8E%86-golang-%E9%93%BE%E8%A1%A8go17-/><div class=article-details><h2 class=article-title>bpftrace 遍历 golang 链表（go17+）</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2019 -
2024 李岩</section><section class=powerby>Hello, World!<br>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.25.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>