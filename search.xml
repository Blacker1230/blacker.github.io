<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mac使用备注</title>
    <url>/2020/12/10/cljb83dli0006kcs6azdrhztx/</url>
    <content><![CDATA[<blockquote>
<p>最近开始使用Mac了。在使用过程中，发现了一些<code>Mac OS</code>和<code>Centos</code>体验上不同的地方。在这里做一下备注。</p>
</blockquote>
<h3 id="部分Linux指令缺失"><a href="#部分Linux指令缺失" class="headerlink" title="部分Linux指令缺失"></a>部分Linux指令缺失</h3><p><code>Mac OS</code>并没有实现所有的<code>Linux</code>下的指令，如<code>realpath</code>这里就需要单独安装一些扩展包了：</p>
<blockquote>
<p>brew install coreutils</p>
</blockquote>
<span id="more"></span>

<h3 id="终端Basic颜色不友好"><a href="#终端Basic颜色不友好" class="headerlink" title="终端Basic颜色不友好"></a>终端Basic颜色不友好</h3><p>可以单独下载一些配色方案。从尽量使用原生配色的角度来说，只需要在<code>.bashrc</code>下面作如下配置即可：</p>
<blockquote>
<p># for color<br>export CLICOLOR=1<br># grep<br>alias grep=’grep –color=always’</p>
</blockquote>
<p>此外，配合<code>.vimrc</code>中配色变更食用更佳：</p>
<blockquote>
<p>“ 设置搜索高亮<br>set hlsearch<br>“ 设置语法高亮<br>syntax on </p>
</blockquote>
<h3 id="启动shell配置不同"><a href="#启动shell配置不同" class="headerlink" title="启动shell配置不同"></a>启动shell配置不同</h3><p><code>Mac OS</code>默认使用<code>zsh</code>作为登陆<code>shell</code>。所以设置<code>.bashrc</code>作为启动配置时，需要在<code>~/.zshrc</code>中进行配置：</p>
<blockquote>
<p>[ -f ~/.bashrc ] &amp;&amp; source ~/.bashrc</p>
</blockquote>
<p>后面碰到再补充吧。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 绘图工具推荐</title>
    <url>/2022/02/16/cljb83dlk000akcs6bubfd203/</url>
    <content><![CDATA[<p>之前办公一直在<code>Windows</code>系统中，诸如流程图、部署图等图表使用的是<code>visio</code>。迁移到<code>Mac</code>上后，<code>visio</code>便不能使用了。转战到<a href="https://www.sketch.com/"><code>sketch</code></a> 上，用着颇为顺手，无奈试用期到了之后，就无法使用了。评估了下使用需求及产品价格，只能启用。<br>目前在使用<a href="https://draw.io/"><code>draw.io</code></a> 进行日常绘图，开源、跨平台、免费、使用流畅，可以在线使用或者客户端使用。基本满足日常需求。用着还是比较好的。</p>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>工具</tag>
        <tag>绘图</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP-7.1升级至7.4兼容性</title>
    <url>/2021/08/02/cljb83dll000bkcs67dedfdje/</url>
    <content><![CDATA[<blockquote>
<p>php作为<del>动不动搞个大事情</del>世界上最好的语言,<del>经常</del>偶尔会出现由于版本升级导致的不兼容问题。笔者在工作中遇到了<code>php7.1</code>升级到<code>php7.4</code>导致的<code>each</code>弃用、<code>mcrypt</code>库启动导致的不兼容。在这里备注下兼容方式。</p>
</blockquote>
<span id="more"></span>
<h1 id="each弃用"><a href="#each弃用" class="headerlink" title="each弃用"></a>each弃用</h1><p>从<code>php7.2</code>开始，官方开始弃用<code>each</code>函数。作为一个伪码农我是很震惊的，无法想象哪天<code>python</code>把<code>range</code>弃用了，代码维护人员是否有毅力将所有的历史内容都重新适配下。<code>php官方</code>就是这么<del>任性</del>自信，直接删除，不做兼容。网上找到的兼容方案是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function func_new_each(&amp;$array)&#123;</span><br><span class="line">    $res = array();</span><br><span class="line">    $key = key($array);</span><br><span class="line">    if($key !== null)&#123;</span><br><span class="line">        next($array);</span><br><span class="line">        $res[1] = $res[&#x27;value&#x27;] = $array[$key];</span><br><span class="line">        $res[0] = $res[&#x27;key&#x27;] = $key;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        $res = false;</span><br><span class="line">    &#125;</span><br><span class="line">    return $res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">// 替换前</span><br><span class="line">list($scalar_type, $scalar_value) = each($methName-&gt;me);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">// 替换后</span><br><span class="line">list($scalar_type, $scalar_value) = func_new_each($methName-&gt;me);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="mcrpt库弃用"><a href="#mcrpt库弃用" class="headerlink" title="mcrpt库弃用"></a>mcrpt库弃用</h1><p>这个更狠了，整个库直接弃用。改为推荐<a href="https://www.php.net/manual/zh/ref.openssl.php"><code>openssl</code></a>。好在工程不是长期维护的，后续可能还有重构的规划，所以以解决问题为优先目标吧，直接将废弃的<code>mcrypt</code>作为插件，重新编入<code>php7.4</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line"> </span><br><span class="line"># any problem please contact me</span><br><span class="line"># used to install mcrypt.so extentions for php</span><br><span class="line"> </span><br><span class="line">php_path=$&#123;1:-&quot;/usr/local/php&quot;&#125;;</span><br><span class="line">echo &quot;install php under $&#123;php_path&#125;&quot;;</span><br><span class="line"> </span><br><span class="line">function Info()&#123;</span><br><span class="line">    echo `whoami`@`hostname`:`pwd`;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function check_env()&#123;</span><br><span class="line">    mised=1;</span><br><span class="line">    for i in &#123;0&#125;; do</span><br><span class="line">        set -x;</span><br><span class="line">        command -v $&#123;php_path&#125;/bin/php &gt;/dev/null 2&gt;&amp;1 || break</span><br><span class="line">        command -v $&#123;php_path&#125;/bin/phpize &gt;/dev/null 2&gt;&amp;1 || break</span><br><span class="line">        command -v $&#123;php_path&#125;/bin/php-config &gt;/dev/null 2&gt;&amp;1 || break</span><br><span class="line">        set +x;</span><br><span class="line">        mised=0;</span><br><span class="line">    done</span><br><span class="line">    return $&#123;mised&#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">check_env;</span><br><span class="line">if [ $? -ne 0 ]; then</span><br><span class="line">    echo &quot;missing php exe file&quot;;</span><br><span class="line">    exit 233;</span><br><span class="line">fi</span><br><span class="line"> </span><br><span class="line"># wget mcrypt</span><br><span class="line">wk_dir=&quot;$&#123;HOME&#125;/php_extend&quot;;</span><br><span class="line">mkdir -p $&#123;wk_dir&#125;;</span><br><span class="line">if [ $? -ne 0 ]; then</span><br><span class="line">    echo &quot;cannot create $&#123;wk_dir&#125;, check permission&quot;;</span><br><span class="line">    exit 20;</span><br><span class="line">fi</span><br><span class="line">rm -rf $&#123;wk_dir&#125;/*;</span><br><span class="line">cd $&#123;wk_dir&#125; &amp;&amp; wget http://pecl.php.net/get/mcrypt-1.0.4.tgz;</span><br><span class="line">if [ $? -ne 0 ]; then</span><br><span class="line">    echo &quot;download mcrypt-1.0.4 failed&quot;;</span><br><span class="line">    exit 23;</span><br><span class="line">fi</span><br><span class="line"> </span><br><span class="line"># prepare</span><br><span class="line">cd $&#123;wk_dir&#125; &amp;&amp; tar -xvf mcrypt-1.0.4.tgz;</span><br><span class="line">cd $&#123;wk_dir&#125;/mcrypt-1.0.4 &amp;&amp; $&#123;php_path&#125;/bin/phpize;</span><br><span class="line">if [ $? -ne 0 ]; then</span><br><span class="line">    echo &quot;mcrypt path init failed&quot;;</span><br><span class="line">    exit 233;</span><br><span class="line">fi</span><br><span class="line"> </span><br><span class="line"># configure</span><br><span class="line">cd $&#123;wk_dir&#125;/mcrypt-1.0.4 &amp;&amp; ./configure --prefix=$&#123;wk_dir&#125;/mcrypt --with-php-config=$&#123;php_path&#125;/bin/php-config;</span><br><span class="line"> </span><br><span class="line">if [ $? -ne 0 ]; then</span><br><span class="line">    echo &quot;=========&gt; attention that, configure failed, would try to make&quot;;</span><br><span class="line">fi</span><br><span class="line"> </span><br><span class="line"># XXX: there is a sudo</span><br><span class="line">cd $&#123;wk_dir&#125;/mcrypt-1.0.4 &amp;&amp; make &amp;&amp; sudo make install</span><br><span class="line"> </span><br><span class="line"># check if has output</span><br><span class="line">extend_dir=$($&#123;php_path&#125;/bin/php-config --extension-dir);</span><br><span class="line">if [ ! -f &quot;$&#123;extend_dir&#125;/mcrypt.so&quot; ]; then</span><br><span class="line">    echo &quot;======&gt;  mcrypt.so generate failed&quot;;</span><br><span class="line">    exit 233;</span><br><span class="line">fi</span><br><span class="line"> </span><br><span class="line">ini_dir=$($&#123;php_path&#125;/bin/php-config --ini-path);</span><br><span class="line">if [ ! -f &quot;$&#123;ini_dir&#125;/php.ini&quot; ]; then</span><br><span class="line">    echo &quot;======&gt; missing php ini file, $&#123;ini_dir&#125;/php.ini&quot;;</span><br><span class="line">    exit 233;</span><br><span class="line">fi</span><br><span class="line"> </span><br><span class="line">cat &lt;&lt; EOF</span><br><span class="line">mcrypt.so is generated in $&#123;extend_dir&#125;/mcrypt.so,</span><br><span class="line">please do with sudo permission:</span><br><span class="line">echo &quot;extension=mcrypt.so&quot; &gt;&gt; $&#123;ini_dir&#125;/php.ini</span><br><span class="line"> </span><br><span class="line">EOF</span><br><span class="line"> </span><br><span class="line"># XXX: there is a sudo</span><br><span class="line"># need sudo, and should run ok</span><br><span class="line">#sudo echo &quot;extension=mcrypt.so&quot; &gt;&gt; $&#123;ini_dir&#125;/php.ini</span><br><span class="line">#if [ $? -ne 0 ]; then</span><br><span class="line">#    echo &quot;cannot write `extension=mcrypt.so` into $&#123;ini_dir&#125;/php.ini, please check permission&quot;;</span><br><span class="line">#    exit 2333;</span><br><span class="line">#fi</span><br><span class="line">#</span><br><span class="line">#echo &quot;mcrypt.so install ok&quot;;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>语言的兼容性确实像噩梦一样。希望不要老是整这些幺蛾子。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/zchare/article/details/81903362">php7.2 废弃each方法
</a><br><a href="https://blog.csdn.net/cbuy888/article/details/93618842">php7.2 安装 mcrypt扩展
</a></p>
]]></content>
  </entry>
  <entry>
    <title>bpftrace 无侵入遍历golang链表</title>
    <url>/2022/07/22/cljb83dlm000ckcs6bp7thrf9/</url>
    <content><![CDATA[<blockquote>
<p><code>bpftrace</code> 基于 <code>bcc</code> 进行开发的工具，语法简洁、功能强大。用其分析<code>Linux</code> 环境下的程序会很方便。本文构造了一个入参为链表头节点的函数使用场景，通过使用<code>bpftrace</code>无侵入遍历链表成员的方式，介绍<code>bpftrace</code> <code>attach uprobe</code> 的使用。更多使用说明见:<a href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md">bpftrace官网使用文档</a></p>
</blockquote>
<span id="more"></span>

<h1 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h1><p>下面直接给出执行结果。可以看到，通过<code>bpftrace</code>脚本输出的结果与代码中实际遍历的结果相同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ./handle.bt  // 先启动监听</span><br><span class="line">Attaching 1 probe...  // 启动后停止在这里</span><br><span class="line">=== enter main.handle.  // 目标程序执行后输出</span><br><span class="line">name: Alice</span><br><span class="line">age : 10</span><br><span class="line">name: Bob</span><br><span class="line">age : 11</span><br><span class="line">name: Claire</span><br><span class="line">age : 12</span><br><span class="line">=== total node: 3</span><br><span class="line"></span><br><span class="line">./demo  // 再执行目标程序</span><br><span class="line">cur name: Alice, cur aget: 10</span><br><span class="line">cur name: Bob, cur aget: 11</span><br><span class="line">cur name: Claire, cur aget: 12</span><br></pre></td></tr></table></figure>

<h1 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h1><p>系统环境如下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux 4.18.0-193.6.3.el8_2.v1.2.x86_64</span><br><span class="line">bpftrace v0.14.0-72-g6761-dirty</span><br><span class="line">go version go1.16.15 linux/amd64</span><br></pre></td></tr></table></figure>

<p>示例环境目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── demo</span><br><span class="line">├── go.mod</span><br><span class="line">├── handle.bt</span><br><span class="line">└── main.go</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">    Age  int64</span><br><span class="line">    // Comment [600]Byte 这样会使得这个问题变得很麻烦，hhh</span><br><span class="line">    Next *Student</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加如下配置以防止函数被编译优化掉</span><br><span class="line">//go:noinline</span><br><span class="line">func handle(ctx context.Context, student *Student) &#123;</span><br><span class="line">    for cur := student; cur != nil; cur = cur.Next &#123;</span><br><span class="line">        fmt.Printf(&quot;cur name: %s, cur aget: %d\n&quot;, cur.Name, cur.Age)</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    first := &amp;Student&#123;</span><br><span class="line">        Name: &quot;Alice&quot;,</span><br><span class="line">        Age:  10,</span><br><span class="line">        Next: &amp;Student&#123;</span><br><span class="line">            Name: &quot;Bob&quot;,</span><br><span class="line">            Age:  11,</span><br><span class="line">            Next: &amp;Student&#123;</span><br><span class="line">                Name: &quot;Claire&quot;,</span><br><span class="line">                Age:  13,</span><br><span class="line">                Next: nil,</span><br><span class="line">            &#125;&#125;&#125;</span><br><span class="line">    handle(context.Background(), first)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// handle.bt</span><br><span class="line">#!/bin/bpftrace</span><br><span class="line"></span><br><span class="line">// 当目标结构体较小时(使得整体栈开销 &lt; 512Byte)，可以直接构造使用</span><br><span class="line">struct student&#123;</span><br><span class="line">    u64 name_ptr;</span><br><span class="line">    u64 name_length;</span><br><span class="line">    long  age;</span><br><span class="line">    struct student *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uprobe:./demo:&quot;main.handle&quot;</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;=== enter main.handle.\n&quot;);</span><br><span class="line"></span><br><span class="line">    $cur = (struct student *)sarg2;</span><br><span class="line">    if ($cur == 0)&#123;</span><br><span class="line">        printf(&quot;input param is nil.\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    $node_count = 1;</span><br><span class="line">    unroll(10)&#123;  // 这里定义的最大节点数量为10</span><br><span class="line">        printf(&quot;name: %s\n&quot;, str($cur-&gt;name_ptr, $cur-&gt;name_length));</span><br><span class="line">        printf(&quot;age : %d\n&quot;, $cur-&gt;age);</span><br><span class="line">        $cur = $cur-&gt;next;</span><br><span class="line">        if ($cur == 0)&#123;</span><br><span class="line">            printf(&quot;=== total node: %d\n&quot;, $node_count);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        $node_count += 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;==== meet max\n&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在编译完成<code>main.go</code>后，通过<code>sudo bpftrace -l &quot;uprobe:./demo:*&quot; &gt; uprobe.info</code>的方式，可以获取<code>demo</code>中所有可以<code>attach</code>的<code>uprobe</code>信息。这里说明下取<code>student*</code>指针值时，为什么取<code>sarg3</code>。<code>bpftrace</code>中对内存传参的参数支持是<code>sarg0, sarg1, sarg2...</code>，且每个参数实际只对应<code>8Byte</code>大小的空间。对于<code>func handle(ctx context.Context, student *Student)</code>函数来说，由于<code>context.Context</code>实际占用<code>2*8Byte</code>的空间（见<a href="https://blacker1230.github.io/2022/06/06/golang-%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E5%AD%97%E8%8A%82%E6%95%B0/">golang常见类型字节数</a>)，因此需要使用<code>sarg2</code>来取<code>student</code>的值，而非直觉上的<code>sarg1</code>。<br>整个过程比较简单、明了。只要拥有<code>root</code>权限，基本上可以对系统内的任何进程进行详细的分析。</p>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>ebpf</tag>
        <tag>golang</tag>
        <tag>bpftrace</tag>
        <tag>uprobe</tag>
      </tags>
  </entry>
  <entry>
    <title>Quic协议</title>
    <url>/2021/11/09/cljb83dln000gkcs6gsqwblfo/</url>
    <content><![CDATA[<blockquote>
<p>Quic 协议作为应用层的协议，在无线、弱网场景下的移动通信领域有广阔的应用场景。本文简单记录一些 Quic 的知识点，同时附上介绍的详细文章；</p>
</blockquote>
<span id="more"></span>

<h1 id="Quic-协议"><a href="#Quic-协议" class="headerlink" title="Quic 协议"></a>Quic 协议</h1><p><code>Quic</code>协议是应用层（5层网络模型下，由于基于传输层协议，笔者倾向于认为其是<code>应用层协议</code>，但是博文中多次标注其是<code>传输层协议</code>），对标 <code>HTTP</code> 协议，基于 <code>UDP</code> 协议构建。</p>
<h1 id="Quic-协议优点"><a href="#Quic-协议优点" class="headerlink" title="Quic 协议优点"></a>Quic 协议优点</h1><ul>
<li>建立连接延时低。相对于 HTTP 协议的至少 3RTT 的建联，Quic 协议可以实现 0RTT 建联；</li>
<li>改进了拥塞控制。将拥塞控制算法的选择交由应用程序控制；同时抛弃了基于 TCP 的 <code>seq</code> 标记，改由严格递增的 <code>package number</code> + <code>offset</code>，优化了拥塞时的重传；<ul>
<li>举例，需要传递 <code>N,N+1,N+2</code> 三个包，传递过程中，<code>N</code> 丢失了；<code>TCP</code>的重传会将<code>N,N+1,N+2</code>三个包都重传；<code>Quic</code> 会重传一个 <code>N+3</code>（即<code>package_num</code>+1），但是 <code>offset</code> 记为 <code>0</code>（即<code>stream_offset</code>不变）。这样在另一端将三个包按照 <code>offset</code> 重新进行组织；</li>
</ul>
</li>
<li>基于 <code>Connection</code> 及 <code>Stream</code> 进行多路复用；</li>
<li>消除队头阻塞，更好的支持多路复用，处理多个会话时，不会因为其中一个会话的丢失，导致其他会话结果也重传(TCP消息重传逻辑)；</li>
<li>默认支持加密认证；<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><code>Quic</code> 协议相当于在 <code>UDP</code> 的基础上，在更高层次协议上实现了 <code>TCP</code> 的大部分功能：可靠传输，拥塞控制等，同时对 <code>TCP</code> 的这些功能进行了优化；<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><a href="http://www.52im.net/thread-1309-1-1.html">技术扫盲：新一代基于UDP的低延时网络传输层协议——QUIC详解</a></li>
</ul>
]]></content>
      <categories>
        <category>通信协议</category>
        <category>理论内容</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>PlantUML-文本化绘制UML多类图表</title>
    <url>/2023/04/21/cljb83dln000hkcs607cl3b68/</url>
    <content><![CDATA[<blockquote>
<p>笔者一直都是文本编辑器教派的忠实拥趸：期望将所有的任务都通过文本编辑，而非鼠标/触摸板等，进行实现。从早年的<code>Vim</code>，到现而今的<code>Emacs</code>，对文本化完成需求是越来越习惯，也越来越依赖了。最近刚好有了些时间，把最近的一些实践整理下。</p>
</blockquote>
<p>在之前的文章，<a href="https://liyan-ah.github.io/2023/02/10/emacs-org-mode%E7%BB%98%E5%88%B6%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">emacs org-mode 绘制思维导图</a>，中，笔者有提到在探索不跳出<code>Emacs</code>这一文本编辑器的情况下，完成思维导图绘制的需求。在翻了一些文章后，找到了一款神器：<a href="https://plantuml.com/zh/">PlantUML</a>。其完美的匹配了笔者的需求：</p>
<ol>
<li>不仅是思维导图，工程、文档常用的<code>UML</code>图像也能全部支持文本化表示；</li>
<li>功能强大，颜色、文本等格式均能支持；</li>
<li><code>Emacs</code>友好，而且可以集成到<code>Org-mode</code>里使用。</li>
</ol>
<p>而且，<code>PlantUML</code>支持在线使用，意味着能够很方便的获取、使用。这里做下介绍。  </p>
<span id="more"></span>

<h2 id="一、依赖内容"><a href="#一、依赖内容" class="headerlink" title="一、依赖内容"></a>一、依赖内容</h2><p>这里先列一下笔者使用时的配置：</p>
<ol>
<li><code>plantuml.jar</code>，安装在本地后，可以通过配置，在本地进行文本-&gt;多格式输出的编译。<a href="https://plantuml.com/zh/download">plantuml.jar 下载</a>；</li>
<li><code>plantuml</code> 配置。由于笔者还是使用的<code>Emacs</code>，这里列一下参照官网配置的<code>Emacs</code>设置。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;; plantuml</span><br><span class="line">;; 安装 plantuml-mode</span><br><span class="line">(ensure-package-installed &#x27;plantuml-mode) </span><br><span class="line">;; 设置 plantuml.jar 的本地路径</span><br><span class="line">(setq org-plantuml-jar-path (expand-file-name &quot;~/.emacs.d/tools/plantuml.jar&quot;)) </span><br><span class="line">;; 将 .plantuml 后缀文件默认以 plantuml-mode 打开。非必需，后面都在 org-mode 里使用了</span><br><span class="line">(add-to-list &#x27;auto-mode-alist &#x27;(&quot;\\.plantuml\\&#x27;&quot; . plantuml-mode)) </span><br><span class="line">;; 比较重要，在 org-mode 里声明 plantuml </span><br><span class="line">(org-babel-do-load-languages &#x27;org-babel-load-languages &#x27;((plantuml . t)))  </span><br></pre></td></tr></table></figure>
配置很简单。下面就可以愉快的使用了。</li>
</ol>
<h2 id="二、plantuml-介绍"><a href="#二、plantuml-介绍" class="headerlink" title="二、plantuml 介绍"></a>二、plantuml 介绍</h2><p><a href="https://plantuml.com/zh/">plantuml官网</a>，目前支持的部分图标类型：</p>
<ul>
<li>UML 图<ol>
<li>时序图</li>
<li>用例图</li>
<li>状态图</li>
<li>活动图</li>
<li>类图</li>
<li>用例图</li>
<li>等等</li>
</ol>
</li>
<li>非UML图<ol>
<li>思维导图</li>
<li>甘特图</li>
<li>工作分解结构图</li>
<li>等等</li>
</ol>
</li>
</ul>
<p>在官网中，对每种图都给出了教程及示例，可以通过<a href="http://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000">在线生成</a> 进行感受。<br><code>PlantUML</code>的输入是文本，输出可以是<code>ASCII, PNG, SVG</code>等等格式。满足日常工作的需求。</p>
<h2 id="三、思维导图"><a href="#三、思维导图" class="headerlink" title="三、思维导图"></a>三、思维导图</h2><h3 id="3-1-一个简单的思维导图"><a href="#3-1-一个简单的思维导图" class="headerlink" title="3.1 一个简单的思维导图"></a>3.1 一个简单的思维导图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#+begin_src plantuml :file mindmap.png</span><br><span class="line">@startmindmap</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">  mindmapDiagram &#123;</span><br><span class="line">    .green &#123;</span><br><span class="line">      BackgroundColor lightgreen</span><br><span class="line">     &#125;</span><br><span class="line">    .yellow &#123;</span><br><span class="line">      BackgroundColor yellow</span><br><span class="line">    &#125;</span><br><span class="line">    .rose&#123;</span><br><span class="line">      BackgroundColor #FFBBCC</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">  * emacs planuml 介绍 &lt;&lt;rose&gt;&gt;</span><br><span class="line">  left side</span><br><span class="line">  ** 依赖内容 &lt;&lt;yellow&gt;&gt;</span><br><span class="line">  ***_ plantuml.jar 安装</span><br><span class="line">  ***_ plantuml 配置</span><br><span class="line">  ** plantuml 介绍 &lt;&lt;yellow&gt;&gt;</span><br><span class="line">  ***_ 支持多种UML文本化编辑\n\</span><br><span class="line">  多种格式文件输出的组件</span><br><span class="line">  ***_ 在线体验</span><br><span class="line"></span><br><span class="line">  right side</span><br><span class="line">  ** 思维导图 &lt;&lt;green&gt;&gt;</span><br><span class="line">  ***_ 一个简单的思维导图</span><br><span class="line">  ***_ 编译输出</span><br><span class="line">  ** 时序图 &lt;&lt;green&gt;&gt;</span><br><span class="line">  ***_ 一个简单的时序图</span><br><span class="line">  ***_ 编译输出</span><br><span class="line">@endmindmap</span><br><span class="line">#+end_src</span><br></pre></td></tr></table></figure>
<p>由于笔者已经在<code>Org-mode</code>里配置了<code>plantuml</code>，因此只要在<code>begin_src</code>后声明<code>plantuml</code>即可。通过<code>:file mindmap.png</code>指定了输出的文件为<code>png</code>格式内容。<code>C-c C-e</code>或者<code>org-export-dispatch</code>即可通过<code>org-mode</code>的输出界面触发编译、输出。</p>
<h3 id="3-2-编译输出"><a href="#3-2-编译输出" class="headerlink" title="3.2 编译输出"></a>3.2 编译输出</h3><p>输出结果：<br>mindmap.png<br><img src="/images/mindmap.png" alt="upload successful"></p>
<h2 id="四、时序图"><a href="#四、时序图" class="headerlink" title="四、时序图"></a>四、时序图</h2><h3 id="4-1-一个简单的时序图"><a href="#4-1-一个简单的时序图" class="headerlink" title="4.1 一个简单的时序图"></a>4.1 一个简单的时序图</h3><p>这里来一点展示内容更丰富的<code>UML</code>时序图实际使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#+begin_src plantuml :file ngx_request.png</span><br><span class="line">    @startuml</span><br><span class="line">        title: nginx+php请求处理示例</span><br><span class="line">      [-&gt;nginx: &lt;font color=blue&gt;/caller_path</span><br><span class="line">      note right of nginx</span><br><span class="line">      nginx 视角:</span><br><span class="line">      caller=nginx,</span><br><span class="line">      caller_func=/caller_path,</span><br><span class="line">      callee=php,</span><br><span class="line">      callee_func=/index.php/caller_path</span><br><span class="line">      end note</span><br><span class="line">      activate nginx #yellow</span><br><span class="line">      nginx-&gt;php: &lt;font color=red&gt;/index.php/caller_path</span><br><span class="line">      activate php #yellow</span><br><span class="line">      note right of php #gray</span><br><span class="line">      laravel</span><br><span class="line">      end note</span><br><span class="line">      php-&gt;callee: &lt;font color=blue&gt;/callee_path</span><br><span class="line">      note right of php</span><br><span class="line">      php 视角:</span><br><span class="line">      caller=php,</span><br><span class="line">      caller_func=/index.php/caller_path,</span><br><span class="line">      callee=callee,</span><br><span class="line">      callee_func=callee_path</span><br><span class="line">      end note</span><br><span class="line">      activate callee</span><br><span class="line">      callee-&gt;php: response</span><br><span class="line">      deactivate callee</span><br><span class="line">      php-&gt;nginx: response</span><br><span class="line">      deactivate php</span><br><span class="line">      nginx-&gt;[: response</span><br><span class="line">      deactivate nginx</span><br><span class="line">      note over nginx, php #aqua: 实际四元组:\n\</span><br><span class="line">    caller=nginx\ncaller_func=/caller_path,\ncallee=callee,\ncallee_func=callee_path,</span><br><span class="line">  @enduml</span><br><span class="line">#+end_src</span><br></pre></td></tr></table></figure>
<h3 id="4-2-编译输出"><a href="#4-2-编译输出" class="headerlink" title="4.2 编译输出"></a>4.2 编译输出</h3><p>输出结果如下：<br>ngx_request.png<br><img src="/images/ngx_request.png" alt="upload successful"><br>可以看到，基本上能够满足一般工程文档使用的需求。</p>
<p>以上是本次介绍的内容。周末愉快～</p>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>emacs</tag>
        <tag>plantuml</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK-docker 实践</title>
    <url>/2022/01/04/cljb83dlp000lkcs6cncxgu5y/</url>
    <content><![CDATA[<h1 id="ELK-docker-部署实践"><a href="#ELK-docker-部署实践" class="headerlink" title="ELK docker 部署实践"></a>ELK docker 部署实践</h1><blockquote>
<p>本文主要对 ELK 套件中的 filebeat, logstash, elasticsearch 的安装进行实践，以及简单运行。</p>
</blockquote>
<span id="more"></span>

<h1 id="Elasticsearch-安装"><a href="#Elasticsearch-安装" class="headerlink" title="Elasticsearch 安装"></a>Elasticsearch 安装</h1><p>这里参照官网给出的<code>docker-compose.yml</code>文件设置<code>elasticsearch</code>集群。<code>elastisearch</code>支持<code>single-node</code>及<code>multi node cluster</code>两种部署模式。在本文中，实际上两种方式都能达到效果。使用<code>single-node</code>启动的环境，查看集群状态时会出现<code>status:yellow</code>。将<code>docker-compose.yml</code>文件放置在一个单独的目录下，然后创建<code>data01, data02, data03</code>目录。依据实际需要，还可创建<code>plugins</code>目录映射。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;2&#x27;</span><br><span class="line">services:</span><br><span class="line">  es01:</span><br><span class="line">    container_name: es01</span><br><span class="line">    image: docker.elastic.co/elasticsearch/elasticsearch:7.15.0</span><br><span class="line">    ports:</span><br><span class="line">      - 9200:9200</span><br><span class="line">      - 9300:9300</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data01:/usr/share/elasticsearch/data</span><br><span class="line">    environment:</span><br><span class="line">      - node.name=es01</span><br><span class="line">      - cluster.name=es-docker-cluster</span><br><span class="line">      - discovery.seed_hosts=es02</span><br><span class="line">      - cluster.initial_master_nodes=es01,es02</span><br><span class="line">      - bootstrap.memory_lock=true</span><br><span class="line">      - &quot;ES_JAVA_OPTS=-Xms128m -Xmx128m&quot;</span><br><span class="line">    ulimits:</span><br><span class="line">      memlock:</span><br><span class="line">        soft: -1</span><br><span class="line">        hard: -1</span><br><span class="line">    networks:</span><br><span class="line">      - elastic</span><br><span class="line"></span><br><span class="line">  es02:</span><br><span class="line">    container_name: es02</span><br><span class="line">    image: docker.elastic.co/elasticsearch/elasticsearch:7.15.0</span><br><span class="line">    environment:</span><br><span class="line">      - node.name=es02</span><br><span class="line">      - cluster.name=es-docker-cluster</span><br><span class="line">      - discovery.seed_hosts=es01</span><br><span class="line">      - cluster.initial_master_nodes=es01,es02</span><br><span class="line">      - bootstrap.memory_lock=true</span><br><span class="line">      - &quot;ES_JAVA_OPTS=-Xms128m -Xmx128m&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data02:/usr/share/elasticsearch/data</span><br><span class="line">    ulimits:</span><br><span class="line">      memlock:</span><br><span class="line">        soft: -1</span><br><span class="line">        hard: -1</span><br><span class="line">    networks:</span><br><span class="line">      - elastic</span><br><span class="line"></span><br><span class="line">  es03:</span><br><span class="line">    container_name: es03</span><br><span class="line">    image: docker.elastic.co/elasticsearch/elasticsearch:7.15.0</span><br><span class="line">    environment:</span><br><span class="line">      - node.name=es03</span><br><span class="line">      - cluster.name=es-docker-cluster</span><br><span class="line">      - discovery.seed_hosts=es01,es02</span><br><span class="line">      - cluster.initial_master_nodes=es01,es02,es03</span><br><span class="line">      - bootstrap.memory_lock=true</span><br><span class="line">      - &quot;ES_JAVA_OPTS=-Xms128m -Xmx128m&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - data03:/usr/share/elasticsearch/data</span><br><span class="line">    ulimits:</span><br><span class="line">      memlock:</span><br><span class="line">        soft: -1</span><br><span class="line">        hard: -1</span><br><span class="line">    networks:</span><br><span class="line">      - elastic</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  data01:</span><br><span class="line">    driver: local</span><br><span class="line">  data02:</span><br><span class="line">    driver: local</span><br><span class="line">  data03:</span><br><span class="line">    driver: local</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  elastic:</span><br><span class="line">    driver: bridge</span><br><span class="line">    external: true</span><br></pre></td></tr></table></figure>

<p>注意这里将集群的网络设置为<code>external</code>，这样后续的<code>logstash</code>才能找到服务节点。此外，由于笔者的机器可用存储较小，因此设置<code>es</code>的存储占用设置为<code>128m</code>。实际使用时，可以按照需求进行调整。<br>运行<code>docker-compose up -d</code>即可后台启动。启动后，<code>curl -X GET &quot;localhost:9200/_cat/nodes?v=true&amp;pretty&quot;</code> 判断集群状态。    </p>
<h1 id="Logstash-安装"><a href="#Logstash-安装" class="headerlink" title="Logstash 安装"></a>Logstash 安装</h1><blockquote>
<p>collect, parse transform logs  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;2&#x27;</span><br><span class="line">services:</span><br><span class="line">  logstash:</span><br><span class="line">    image: docker.elastic.co/logstash/logstash:7.15.0</span><br><span class="line">    container_name: logstash</span><br><span class="line">    user: root</span><br><span class="line">    ports:</span><br><span class="line">      - 5004:5004</span><br><span class="line">    volumes:</span><br><span class="line">      - ./config:/usr/share/logstash/config/</span><br><span class="line">      - /etc/localtime:/etc/localtime</span><br><span class="line">    command: bash -c &quot;cd /usr/share/logstash &amp;&amp; logstash -f config/online.conf&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - elastic</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  elastic:</span><br><span class="line">    driver: bridge</span><br><span class="line">    external: true</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ./config/online.conf</span><br><span class="line">input &#123;</span><br><span class="line">  # 这里支持多种 input</span><br><span class="line">  beats &#123;</span><br><span class="line">    port =&gt; 5004</span><br><span class="line">    codec =&gt; &quot;json&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">  # 这里基于 ruby 脚本进行过滤</span><br><span class="line">  ruby &#123;</span><br><span class="line">    path =&gt; &quot;./config/filter.rb&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  # 这里将过滤后的结果输出到标准输出及 es 中</span><br><span class="line">  stdout &#123;</span><br><span class="line">    codec =&gt; json</span><br><span class="line">  &#125;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [&quot;es01:9200&quot;]</span><br><span class="line">    index =&gt; &quot;logstash&quot;</span><br><span class="line">    #user =&gt; &quot;&quot;</span><br><span class="line">    #password =&gt; &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># config/filter.rb</span><br><span class="line"># 按照 online.conf 中的配置，logstash 启动后，会读取 filter.rb，并使用 filter 函数作为过滤函数。</span><br><span class="line">require &quot;json&quot;</span><br><span class="line"></span><br><span class="line">BEGIN&#123;</span><br><span class="line">  puts &quot;start event filter&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">END&#123;</span><br><span class="line">  puts &quot;end event filter&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def filter(event)</span><br><span class="line">  puts event</span><br><span class="line">  if event.get(&quot;[errno]&quot;) != 0</span><br><span class="line">    return []</span><br><span class="line">  end</span><br><span class="line">  valid_age = 0</span><br><span class="line">  event.get(&quot;[data]&quot;).each&#123; | info |</span><br><span class="line">    if info[&quot;age&quot;] &lt; 10</span><br><span class="line">      valid_age += info[&quot;age&quot;]</span><br><span class="line">    end</span><br><span class="line">  &#125;</span><br><span class="line">  event.set(&quot;[data]&quot;, valid_age)</span><br><span class="line">  return [event]</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>logstash 启动后，会监听容器内的 <code>5004</code> 接口（配置于<code>online.conf</code>中），如果有信息传入，则会经过<code>filter.rb</code>中的 <code>filter()</code> 函数对数据进行处理。而后输出到标准输出及 <code>es01</code>容器<code>5004</code>端口的<code>elasticsearch</code>服务。由于<code>elasticsearch</code>及<code>logstash</code>容器使用了相同的网络，因此可以互相感知。  </p>
<h1 id="filebeat-安装"><a href="#filebeat-安装" class="headerlink" title="filebeat 安装"></a>filebeat 安装</h1><blockquote>
<p>filebeat 作为轻量级的日志收集器，仅占用很少的资源，即可完成日志的采集，并且转发至配置的<code>logstash</code>进行后续的处理、归档等操作。  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;2&#x27;</span><br><span class="line">services:</span><br><span class="line">  filebeat:</span><br><span class="line">    image: docker.elastic.co/beats/filebeat:7.16.0</span><br><span class="line">    container_name: filebeat</span><br><span class="line">    user: root</span><br><span class="line">    environment:</span><br><span class="line">      - strict.perms=false</span><br><span class="line">    volumes:</span><br><span class="line">      - ./filebeat.yml:/usr/share/filebeat/filebeat.yml</span><br><span class="line">      - ./data:/usr/share/filebat/data</span><br><span class="line">    networks:</span><br><span class="line">      - elastic</span><br><span class="line">    command: bash -c &quot;cd /usr/share/filebeat &amp;&amp; filebeat -e -c ./filebeat.yml&quot;</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  elastic:</span><br><span class="line">    driver: bridge</span><br><span class="line">    external: true</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># filebeat.yml</span><br><span class="line">filebeat.inputs:</span><br><span class="line">  - type: log</span><br><span class="line">    enabled: true</span><br><span class="line">    paths:</span><br><span class="line">      - /usr/share/filebeat/input.log</span><br><span class="line"></span><br><span class="line">filebeat.config:</span><br><span class="line">  modules:</span><br><span class="line">    path: $&#123;path.config&#125;/modules.d/*.yml</span><br><span class="line">    reload.enabled: false</span><br><span class="line"></span><br><span class="line">filbeat.autodiscover:</span><br><span class="line">  providers:</span><br><span class="line">    - type: docker</span><br><span class="line">      hints.enabled: true</span><br><span class="line"></span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: &quot;logstash:5004&quot;</span><br></pre></td></tr></table></figure>


<p>容器启动后，会监听<code>/usr/share/filebeat/input.log</code>文件。当该文件发生变更时，<code>filebeat</code>会读取增量的内容并进行转发。</p>
<h1 id="let-it-run"><a href="#let-it-run" class="headerlink" title="let it run"></a>let it run</h1><p>经过上述步骤，一个简单的日志监听、采集、处理、存档的流程就构建了。为了测试，可以在<code>filebeat</code>容器的<code>/usr/share/filebeat/input.log</code>中写入：</p>
<pre><code>&#123;&quot;errno&quot;: 0,&quot;data&quot;: [&#123;&quot;age&quot;: 9,&quot;name&quot;: &quot;tt&quot;&#125;,&#123;&quot;age&quot;: 8,&quot;name&quot;: &quot;gg&quot;&#125;]&#125;
</code></pre>
<p>按照<code>logstash:online.conf</code>的逻辑，会向<code>elasticsearch</code>的<code>logstash</code>写入信息。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a href="https://www.cnblogs.com/zhangfushuai/p/14975307.html">Linux-ELK日志收集</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html#docker">Install Elasticsearch with Docker</a></li>
<li><a href="https://www.cnblogs.com/cjsblog/p/9459781.html">Logstash介绍</a></li>
</ol>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>c++插件管理--pluma&lt;实践&gt;</title>
    <url>/2020/10/29/cljb83dlp000mkcs6hkraapq5/</url>
    <content><![CDATA[<p>最近研究了一下<a href="http://pluma-framework.sourceforge.net/">pluma</a>的使用。发现官网上的简单示例对于刚入门的人来说还是麻烦了些（而且还有语法错误）。<br>下面重新整理了一个例子，作为备注。  </p>
<span id="more"></span>

<p>其中，<code>device</code>为一个虚基类，作为接口类存在。<code>keyboard</code>及<code>screen</code>作为实现了device的子类存在，实现具体的操作。在pluma上注册后，在<code>main</code>中调用接口，实现<code>keyboard</code>及<code>screen</code>的调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// device.hpp</span><br><span class="line">#ifndef _DEVICE_HPP_</span><br><span class="line">#define _DEVICE_HPP_</span><br><span class="line">#include &quot;Pluma/Pluma.hpp&quot;</span><br><span class="line"></span><br><span class="line">class Device&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual std::string getDescription() const=0;</span><br><span class="line">&#125;;</span><br><span class="line">// create DevicedProvider class</span><br><span class="line">PLUMA_PROVIDER_HEADER(Device);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// device.cpp</span><br><span class="line">#include &quot;device.hpp&quot;</span><br><span class="line">PLUMA_PROVIDER_SOURCE(Device, 6, 3);</span><br></pre></td></tr></table></figure>
<p>如上所示，是<code>device</code>的定义。其中<code>PLUMA_PROVIDER_HEADER</code>和<code>PLUMA_PROVIDER_SOURCE</code><code>pluma</code>提供的宏。功能暂且不论。我们继续往下看。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// screen.hpp</span><br><span class="line">#include &quot;Pluma/Pluma.hpp&quot;</span><br><span class="line">#include &quot;device.hpp&quot;</span><br><span class="line"></span><br><span class="line">class Screen: public Device&#123;</span><br><span class="line">public:</span><br><span class="line">    std:: string getDescription() const&#123;</span><br><span class="line">        return &quot;screen&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PLUMA_INHERIT_PROVIDER(Screen, Device);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// keyboard.hpp</span><br><span class="line">#include &quot;Pluma/Pluma.hpp&quot;</span><br><span class="line">#include &quot;device.hpp&quot;</span><br><span class="line"></span><br><span class="line">class Keyboard: public Device&#123;</span><br><span class="line">public:</span><br><span class="line">    std:: string getDescription() const&#123;</span><br><span class="line">        return &quot;keyboard&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PLUMA_INHERIT_PROVIDER(Keyboard, Device);</span><br></pre></td></tr></table></figure>
<p>上面实现了<code>screen</code>及<code>keyboard</code>的逻辑。实现了之后，需要进行注册：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// connect.cpp</span><br><span class="line"> #include &lt;Pluma/Connector.hpp&gt;</span><br><span class="line"> #include &quot;keyboard.hpp&quot;</span><br><span class="line"> #include &quot;screen.hpp&quot;</span><br><span class="line"></span><br><span class="line"> PLUMA_CONNECTOR</span><br><span class="line"> bool connect(pluma::Host&amp; host)&#123;</span><br><span class="line">     // add a keyboard provider to host</span><br><span class="line">     host.add( new KeyboardProvider() );</span><br><span class="line">     host.add( new ScreenProvider() );</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里在<code>connect</code>中进行了两个子类的注册。之所以使用<code>connect</code>是因为后面的pluma使用的时候，官网给出的示例代码中，会从<code>connect</code>入口开始调用。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.cpp</span><br><span class="line">#include &quot;Pluma/Pluma.hpp&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;device.hpp&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pluma:: Pluma plugins;</span><br><span class="line">    plugins.acceptProviderType&lt;DeviceProvider&gt;();</span><br><span class="line">    plugins.load(&quot;./plugin/connect.so&quot;);</span><br><span class="line">    //plugins.load(&quot;./plugin/keyboard.so&quot;);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;DeviceProvider*&gt; providers;</span><br><span class="line">    plugins.getProviders(providers);</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;&quot;size for providers are:&quot; &lt;&lt; providers.size()&lt;&lt; std:: endl;</span><br><span class="line">    if (!providers.empty())&#123;</span><br><span class="line">        for (std::vector&lt;DeviceProvider*&gt;::iterator device=providers.begin();</span><br><span class="line">            device != providers.end(); ++ device)&#123;</span><br><span class="line">            Device* myDevice = (*device)-&gt;create();</span><br><span class="line">            std::cout &lt;&lt; myDevice-&gt;getDescription() &lt;&lt; std::endl;</span><br><span class="line">            delete myDevice;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是主要的调用逻辑了。官网中<code>myDevice</code>附近的拼写有主意，这是个坑了。<br>这里回顾下目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── connect.cpp</span><br><span class="line">├── device.hpp</span><br><span class="line">├── device.cpp</span><br><span class="line">├── keyboard.hpp</span><br><span class="line">├── main.cpp</span><br><span class="line">├── plugin                          # 用来存储插件结果的目录</span><br><span class="line">├── Pluma                           # 为了方便，这里将Pluma的include及src文件均拷贝到这里</span><br><span class="line">│   ├── Config.hpp</span><br><span class="line">│   ├── Connector.hpp</span><br><span class="line">│   ├── Dir.cpp</span><br><span class="line">│   ├── Dir.hpp</span><br><span class="line">│   ├── DLibrary.cpp</span><br><span class="line">│   ├── DLibrary.hpp</span><br><span class="line">│   ├── Host.cpp</span><br><span class="line">│   ├── Host.hpp</span><br><span class="line">│   ├── PluginManager.cpp</span><br><span class="line">│   ├── PluginManager.hpp</span><br><span class="line">│   ├── Pluma.hpp</span><br><span class="line">│   ├── Pluma.inl</span><br><span class="line">│   ├── Provider.cpp</span><br><span class="line">│   ├── Provider.hpp</span><br><span class="line">│   └── uce-dirent.h</span><br><span class="line">└── screen.hpp</span><br></pre></td></tr></table></figure>
<p>看下编译过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 生成device.so</span><br><span class="line">g++ connect.cpp device.cpp Pluma/*.cpp -shared -fPIC -o plugin/connect.so -I./</span><br><span class="line"></span><br><span class="line"># 生成main</span><br><span class="line">g++ main.cpp device.hpp device.cpp Pluma/*.cpp -o main -I./ -ldl</span><br></pre></td></tr></table></figure>
<p>执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./main</span><br><span class="line">size for providers are:2</span><br><span class="line">keyboard</span><br><span class="line">screen</span><br></pre></td></tr></table></figure>
<p>以上就是实践的内容了。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>pluma</tag>
      </tags>
  </entry>
  <entry>
    <title>centos 安装docker并构建golang镜像</title>
    <url>/2022/03/04/cljb83dlq000qkcs6hnnb1kv4/</url>
    <content><![CDATA[<blockquote>
<p>工作需要（抛弃了kubectl搞一套环境的方法），需要在centos8上构建一套docker镜像并运行golang程序。这里记录下docker安装及golang程序打包镜像的过程。  </p>
</blockquote>
<span id="more"></span>

<h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo  </span><br><span class="line">    </span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io  </span><br><span class="line">\# 这里报了一个错</span><br><span class="line">\# (try to add &#x27;--allowerasing&#x27; to command line to replace conflicting packages or &#x27;--skip-broken&#x27; to skip uninstallable packages or &#x27;--nobest&#x27; to use not only best candidate packages)  </span><br><span class="line">\# 重新执行  </span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io --allowerasing</span><br><span class="line"></span><br><span class="line">\# 启动 docker  </span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line">\# 测试   </span><br><span class="line">sudo docker run hello-world </span><br><span class="line">\# Hello from Docker!  </span><br><span class="line">\# This message shows that your installation appears to be working correctly.  </span><br></pre></td></tr></table></figure>


<h1 id="构建golang服务镜像"><a href="#构建golang服务镜像" class="headerlink" title="构建golang服务镜像"></a>构建golang服务镜像</h1><p>先看下工作目录的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── gin-srv</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">└── main.go</span><br></pre></td></tr></table></figure>
<p>简单写一个<code>golang</code>的程序:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;time&quot;</span><br><span class="line">import &quot;github.com/gin-gonic/gin&quot;</span><br><span class="line"></span><br><span class="line">type Resp struct&#123;</span><br><span class="line">	Errno int `json:&quot;errno&quot;`</span><br><span class="line">	Data map[string]int64 `json:&quot;data&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(&quot;/ping&quot;, func(c *gin.Context)&#123;</span><br><span class="line">		resp := &amp;Resp&#123;Errno:0, Data: map[string]int64&#123;</span><br><span class="line">			&quot;now&quot;: time.Now().Unix(),</span><br><span class="line">		&#125;&#125;</span><br><span class="line">		c.JSON(200, &amp;resp)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run(&quot;0.0.0.0:8080&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构建一个Dockerfile，以<code>centos</code>作为base以便能够正常登陆容器进行调试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM centos:8</span><br><span class="line">ADD . ./</span><br><span class="line">EXPOSE 8080</span><br><span class="line">ENTRYPOINT [&quot;./gin-srv&quot;]</span><br></pre></td></tr></table></figure>
<p>启动容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 构建镜像</span><br><span class="line">sudo docker build -t gin_docker .</span><br><span class="line"># 启动镜像</span><br><span class="line">sudo docker run --name gin_docker -p 8080:8080 -d gin_docker</span><br></pre></td></tr></table></figure>
<p>访问容器中的服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl localhost:8080/ping</span><br><span class="line">&#123;&quot;errno&quot;:0,&quot;data&quot;:&#123;&quot;now&quot;:1646381863&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>容器起来了。可以继续后面的性能评估及agent启动工作了。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://docs.docker.com/engine/install/centos/">Install Docker Engine on CentOS</a><br><a href="https://article.itxueyuan.com/7DreWj">Golang应用打包docker镜像并运行</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>eBPF</tag>
      </tags>
  </entry>
  <entry>
    <title>centos 构建 local-k8s</title>
    <url>/2022/02/24/cljb83dlr000skcs60qx3acis/</url>
    <content><![CDATA[<blockquote>
<p>工作原因，需要安装一个 local-k8s。中间碰了很多坑，做个记录。<br>环境：Linux test 4.18.0-193.el8.x86_64</p>
</blockquote>
<span id="more"></span>
<h1 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h1><p><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/">kubectl安装说明</a>，可以直接使用包管理器安装，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line">sudo yum install -y kubectl</span><br></pre></td></tr></table></figure>
<h1 id="minicube"><a href="#minicube" class="headerlink" title="minicube"></a>minicube</h1><p><a href="https://minikube.sigs.k8s.io/docs/start/">minicube安装说明</a> 也比较方便，官网里有不同系统的安装方式。笔者使用<code>curl</code>的安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64</span><br><span class="line">sudo install minikube-linux-amd64 /usr/local/bin/minikube</span><br></pre></td></tr></table></figure>
<h1 id="start-cluster"><a href="#start-cluster" class="headerlink" title="start cluster"></a>start cluster</h1><h2 id="安装-kvm"><a href="#安装-kvm" class="headerlink" title="安装 kvm"></a>安装 kvm</h2><p><a href="https://phoenixnap.com/kb/install-kvm-centos">How to Install KVM on CentOS 8</a> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># check</span><br><span class="line">cat /proc/cpuinfo | egrep &quot;vmx|svm&quot;</span><br><span class="line"># install</span><br><span class="line">sudo yum install @virt</span><br><span class="line"># start</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>minikube start --driver=&lt;kvm2|hyperkit&gt; --cni=flannel --cpus=4 --memory=8000 -p=&lt;cluster-name&gt;</code>，其中，笔者使用的<code>centos</code>系统使用<code>--driver=kvm2</code>选项。执行时存在诸多问题：</p>
<h2 id="kvm2-错误"><a href="#kvm2-错误" class="headerlink" title="kvm2 错误"></a>kvm2 错误</h2><p>参照错误提示来。需要安装<code>libvirt</code>，笔者直接<code>sudo yum install libvirt</code>进行的。</p>
<h2 id="not-in-libvirt-group"><a href="#not-in-libvirt-group" class="headerlink" title="not in libvirt group"></a>not in libvirt group</h2><p>不确定为什么需要单独搞一个<code>libvirt group</code>，按照<a href="https://github.com/kubernetes/minikube/issues/5617">issue-5617</a> 的说明，需要将用户添加到<code>libvirt</code>用户组中。笔者直接进行<code>sudo usermod -a -G libvirt $&#123;USERNAME&#125;</code>。</p>
<h2 id="virsh-报错"><a href="#virsh-报错" class="headerlink" title="virsh 报错"></a>virsh 报错</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: failed to connect to the hypervisor</span><br><span class="line">error: authentication failed: access denied by policy</span><br></pre></td></tr></table></figure>
<p> 需要在将当前用户添加到<code>libvirt</code>之后，需要配置<code>polkit</code>规则，确保<code>libvirt</code>组中的用户能够访问<code>libvirt</code>。<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> # 方案参考 https://blog.csdn.net/cunjiu9486/article/details/109074019</span><br><span class="line"> # /etc/polkit-1/rules.d/80-libvirt.rules</span><br><span class="line"> polkit.addRule(function(action, subject)&#123;</span><br><span class="line">	if (action.id == &quot;org.libvirt.unix.manage&quot; &amp;&amp; subject.local &amp;&amp; subject.active &amp;&amp; subject.isInGroup(&quot;libvirt&quot;))&#123;</span><br><span class="line">		return polkit.Result.YES;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br> 添加规则后，还需要重启 <code>polkitd</code>。简单粗暴：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup /usr/lib/polkit-1/polkitd -r &gt; /dev/null &amp;</span><br></pre></td></tr></table></figure></p>
<h2 id="Cannot-find-suitable-emulator-for-x86-64"><a href="#Cannot-find-suitable-emulator-for-x86-64" class="headerlink" title="Cannot find suitable emulator for x86_64"></a>Cannot find suitable emulator for x86_64</h2><p> 通过 <code>sudo systemctl status libvirtd</code> 查看，发现报错是：<code>cannot initialize crypt</code>，继续安装<code>yum install libgcrypt</code>。</p>
<h2 id="dnsmasq-unknown-user-or-group-dnsmasq"><a href="#dnsmasq-unknown-user-or-group-dnsmasq" class="headerlink" title="dnsmasq: unknown user or group: dnsmasq"></a>dnsmasq: unknown user or group: dnsmasq</h2> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groupadd dnsmasq</span><br><span class="line">useradd dnsmasq -g dnsmasq</span><br></pre></td></tr></table></figure>
<h2 id="Failed-to-start-host"><a href="#Failed-to-start-host" class="headerlink" title="Failed to start host"></a>Failed to start host</h2><p> 提示建议删除刚才的<code>cluster</code>，不清楚为啥，提示了就搞起来：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">minikube delete $cluster_name</span><br><span class="line"># 再次执行</span><br><span class="line">minikube start --driver=&lt;kvm2|hyperkit&gt; --cni=flannel --cpus=4 --memory=8000 -p=&lt;cluster-name&gt;</span><br></pre></td></tr></table></figure><br> 这次可以了！<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* Enabled addons: storage-provisioner, default-storageclass</span><br><span class="line">* Done! kubectl is now configured to use &quot;$&#123;cluster_name&#125;&quot; cluster and &quot;default&quot; namespace by default</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>code</category>
      </categories>
      <tags>
        <tag>ebpf</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>challenges of bpf tracing go</title>
    <url>/2022/04/19/cljb83dls000vkcs6dmdud1ov/</url>
    <content><![CDATA[<blockquote>
<p>goroutine 开销为 2KB（最少），对比线程 2MB 的开销，有明显的优势。当goroutine 栈资源不足时，runtime 会将整个 goroutine stack 拷贝、重新分配空间。</p>
</blockquote>
<blockquote>
<p>Instead of using a thread for every goroutine, Go multiplexes goroutines across multiple threads (“M:N scheduling”). So instead of each thread having a default 2MB stack, each goroutine has a tiny 2KB stack that’s managed by the runtime instead of the operating system. When the program needs to grow the stack for a goroutine and there’s not enough room, the runtime copies the entire goroutine’s stack to another place in memory where it has enough room to expand.  </p>
</blockquote>
<p><a href="https://blog.0x74696d.com/posts/challenges-of-bpf-tracing-go/">Challenges of BPF Tracing Go</a></p>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>ebpf</tag>
        <tag>code</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>eBPF及其对可观测的意义【译文】</title>
    <url>/2022/03/02/cljb83dlt000zkcs68x7u0q2j/</url>
    <content><![CDATA[<blockquote>
<p>最近在做 eBPF 的技术调研。看到很多对 eBPF 的介绍。为了加强对内容的理解，笔者选择了其中的一篇尝试翻译。本着便于笔者自己理解的角度，很多内容加入了自己的一些理解，因此并不能算是严格意义上的“翻译”。文章涉及了 eBPF 的介绍、优势、不足，算是一篇 eBPF 的很好的介绍。现在把它贴上来，算是纪念自己的第一篇“译文”。<br>原文地址：<a href="https://newrelic.com/blog/best-practices/what-is-ebpf">What Is eBPF and Why Does It Matter for Observability?</a></p>
</blockquote>
<span id="more"></span>

<h1 id="eBPF-及其对可观测领域的影响"><a href="#eBPF-及其对可观测领域的影响" class="headerlink" title="eBPF 及其对可观测领域的影响"></a>eBPF 及其对可观测领域的影响</h1><p>当实现安全性、网络化以及可观测的特性时，在linux 内核中工作是非常理想化的。然而，它并非缺少挑战。无论是变更内核源码或者新增<br>内核模块，开发者通常会面对复杂的架构及难以调试的抽象层。<a href="https://www.kernel.org/doc/html/latest/bpf/index.html">扩展的 BPF(eBPF)</a> 能够解决这两个问题。<br>伯克利包过滤器扩展技术(Extended Berkeley Packet Filter, eBPF) 是一种内核技术(自 Linux 4.x 引入)允许程序在无需变更内核源码或添加<br>额外的内核模块。你可以认为它是一种内核内置的轻量级的、沙箱式的虚拟机，编程人员可以通过 BPF 字节码来最大化的利用内核的资源。<br>使用 eBPF 消除了变更内核源码并且简化了软件利用现有层级的能力。因此，它是一种强大的技术，有可能从根本上改变网络、可观测性及安全<br>服务的工作方式。<br>这是一篇 eBPF 是什么、怎么工作以及什么时候考虑利用这种技术的文章。</p>
<h1 id="eBPF-是怎么工作的"><a href="#eBPF-是怎么工作的" class="headerlink" title="eBPF 是怎么工作的"></a>eBPF 是怎么工作的</h1><p>eBPF 是事件驱动的，并且绑定到特定的代码路径。代码路径包含特殊的触发点(triggers)，或者称为钩子(hooks)。触发时，会执行所有绑定<br>到上面的 eBPF 程序。一些钩子的示例包括网络事件、系统调用、函数执行以及内核跟踪点。<br>当被触发时，代码会首先被编译成 BPF 字节码。然后，字节码会在执行前被校验，以确保不包含任何循环。校验会确保程序不会有意或无意的<br>破坏内核。<br>当代码在一个钩子上执行后，会产生辅助调用(helper calls)。这些辅助调用是一些eBPF访问内存的函数。辅助调用需要内核提前定义，目前<br><a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html">调用的函数列表</a>仍在持续增长中。<br>eBPF 最开始的时候是作为一种增加过滤网络包时可观测性及安全性的工具。然而，时至今日，它已经成为一种用来让用户态的程序更加安全、<br>便捷、表现更好的工具。</p>
<h1 id="eBPF-的优势"><a href="#eBPF-的优势" class="headerlink" title="eBPF 的优势"></a>eBPF 的优势</h1><p>eBPF 通常被用来进行<a href="https://blog.px.dev/ebpf-function-tracing/">追踪</a>用户态的进程，这里列出一些它的优势：</p>
<ul>
<li>高速、高效。eBPF 可以将网络包从内核态移动至用户态。而且，eBPF支持一个运行时（just-in-time, JIT）的编译器。在字节码被编译出来<br>后即可被执行，毋需基于平台重新解释；</li>
<li>低侵入性。当被用作调试器时，eBPF 无需停止服务便可以观测它的状态；</li>
<li>安全性。程序会被高效地加载到沙盒中，意味着内核源码被保护起来不会发生变更。执行时的校验能够确保资源不会由于程序陷入死循环而<br>阻塞；</li>
<li>便捷。相对于构建并维护内核的模块，编写内核的函数钩子要简单的多；</li>
<li>一致追踪。eBPF能够带来一个单一、有效、可用性强的追踪程序的框架。这增加了可视化及安全性；</li>
<li>可编程性。使用 eBPF 在不引入额外架构层的情况下，丰富了系统的特性。而且，由于代码是直接运行在内核里的，在不同的eBPF事件间存储<br>数据，而非像其他追踪程序一样转存出来，是可行的；</li>
<li>表达丰富。eBPF极具表达能力，这通常只能在其他高级语言中能够看到；<h1 id="eBPF-最佳实践"><a href="#eBPF-最佳实践" class="headerlink" title="eBPF 最佳实践"></a>eBPF 最佳实践</h1>考虑到 eBPF 仍然是一项新的技术，很多使用仍待进一步开发。关于 eBPF 的最佳实践仍在随着这种技术的改进而不断增加。虽然没有已定义的<br>最佳实践存在，仍然有一些措施可以采纳以确保程序高效、便捷。<br>如果你在生态系统中使用了 eBPF，我们建议你：</li>
<li>使用 <a href="https://clang.llvm.org/">LLVM Clang</a> 来将 C 代码编辑为 eBPF 字节码。当 eBPF 刚出现时，编码及汇编均需要手动操作。然后，<br>开发者使用内核的汇编器生成字节码。幸运的是，现在已经不再需要这样操作了。Clang 为 C 语言编写的 eBPF 提供了前端及工具；</li>
<li>使用 BCC 工具集来编写 BPF 程序。<a href="https://github.com/iovisor/bcc">BPF 编译器集合（BPF Compiler Collection, BCC）</a> 是一个帮助<br>构建高效内核追踪及管理程序的工具集。针对性能分析及网络拥塞控制相关的任务尤其合适。<h1 id="eBPF-的不足"><a href="#eBPF-的不足" class="headerlink" title="eBPF 的不足"></a>eBPF 的不足</h1>尽管很强大，eBPF 并不是适合所有项目/生态系统的万金油。eBPF 有一些显而易见的不足，这些不足会让它在一些场景下不适用。一些开发者<br>可能会发现在如下场景下 eBPF 不适用：</li>
<li>eBPF 限制在 Linux 系统及较新的内核版本。eBPF 是在 Linux 内核上发展并且完全聚焦在其上。这导致它相对于其他工具而言移植性不强。<br>此外，你需要一个相当新的内核。如果运行在任何早于 v4.13 的内核上，你将不能使用它。</li>
<li>沙盒编程是存在限制的。eBPF 通过限制应用程序可以接触的资源来提升安全性。然而，由于限制了操作系统的访问，功能上也被限制了。<h1 id="eBPF-适用哪些领域"><a href="#eBPF-适用哪些领域" class="headerlink" title="eBPF 适用哪些领域"></a>eBPF 适用哪些领域</h1>eBPF <a href="https://newrelic.com/solutions/cloud-adoption">云原生应用</a> 领域正迅速的获得关注。目前，eBPF 在以下两个场景中获得普遍<br>使用：</li>
<li>需要使用内核追踪实现可观测性。在这种场景下，eBPF 表现得更加快速、高效。这里不涉及到<a href="https://www.quora.com/What-is-context-switching-in-Linux">上下文切换</a>，并且 eBPF 程序是事件驱动的所以毋需一个特定的触发器–所以你不会存在精度上的问题。</li>
<li>传统的安全监控不起作用。eBPF 在分布式及容器化的环境中有巨大的应用潜力，包括<a href="https://kubernetes.io/blog/2017/12/using-ebpf-in-kubernetes/">Kubernets</a>。<br>在这些环境中，eBPF 可以缩小可见性的差距，因为他可以提供<a href="https://blog.pixielabs.ai/ebpf-http-tracing/">HTTP 可见性追踪</a>。<br>在如下安全度量领域，你也可以发现 eBPF 被使用：</li>
<li>防火墙；</li>
<li>设备驱动；</li>
<li>网络性能监控；<h1 id="New-Relic-and-eBPF"><a href="#New-Relic-and-eBPF" class="headerlink" title="New Relic and eBPF"></a>New Relic and eBPF</h1><a href="https://newrelic.com/platform/kubernetes-pixie">Pixie</a> (acquired by New Relic), is an open source, kubernetes-native-in-cluster observability platform that provides instant visibility into Kubernetes workloads with no manual instrumentation. eBPF provides most of the magic behind the Pixie platform. As described earlier, eBPF allows you to run restricted code when an event is triggered. This event could be a function call either in kernel space(kprobes) or userspace(uprobes). Pixie uses both uprobes and kprobes to enable observability across services and applications.</li>
</ul>
<p>Pixie automatically harvests telemetry data by leveraging eBPF, and its edge-machine intelligence connects this data with Kubernetes metadata to provide visibility while maintaining data locality. This visibility complements New Relic’s powerful Kubernetes observability solution. And starting in late May, you’ll be able to send Pixie-generated telemetry data to New Relic One, gaining scalable retention, powerful visualizations, advanced correlation, and intelligent alerting capabilities.</p>
<h1 id="eBPF-正在可见的创造效率"><a href="#eBPF-正在可见的创造效率" class="headerlink" title="eBPF 正在可见的创造效率"></a>eBPF 正在可见的创造效率</h1><p>eBPF 是一个提升 Linux 内核可观测、网络及安全性的新技术。它毋需变更内核源码或者添加新的模块，所以你可以在不引入复杂性的前提下，<br>提升系统的基础建设。<br>我们简要的谈到 eBPF 是什么、如何工作以及为什么它在分布式环境中如此有用。通过监控内核层，很多云上的可观测问题被解决了。你可以<br>享受数据中更深层次的可见性、更丰富的上下文以及更准确的信息。</p>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>eBPF</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>clisp编译</title>
    <url>/2019/05/28/cljb83dlt0013kcs6hboe4fto/</url>
    <content><![CDATA[<p>目前，lisp的开发环境基本上被<a href="https://common-lisp.net/project/lispbox/">lispbox</a>所垄断。所以本文来说一<a href="https://clisp.sourceforge.io/">CLISP</a>，C语言实现的LISP解释器的安装。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget &quot;https://ftp.gnu.org/pub/gnu/clisp/latest/clisp-2.49.tar.gz&quot;</span><br><span class="line">tar -xvf clisp-2.49.tar.gz</span><br><span class="line">cd clisp-2.49</span><br><span class="line">./configure --prefix=LOCAL_PATH --ignore-absence-of-libsigsegv</span><br><span class="line">cd src &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>这样就可以将CLISP安装到<code>--prefix</code>指定的路径。<br>然后是使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd LOCAL_PATH/bin/</span><br><span class="line">./clisp</span><br></pre></td></tr></table></figure>
<p>就会出现欢迎界面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  i i i i i i i       ooooo    o        ooooooo   ooooo   ooooo</span><br><span class="line">  I I I I I I I      8     8   8           8     8     o  8    8</span><br><span class="line">  I  \ `+&#x27; /  I      8         8           8     8        8    8</span><br><span class="line">   \  `-+-&#x27;  /       8         8           8      ooooo   8oooo</span><br><span class="line">    `-__|__-&#x27;        8         8           8           8  8</span><br><span class="line">        |            8     o   8           8     o     8  8</span><br><span class="line">  ------+------       ooooo    8oooooo  ooo8ooo   ooooo   8</span><br><span class="line"></span><br><span class="line">Welcome to GNU CLISP 2.49 (2010-07-07) &lt;http://clisp.cons.org/&gt;</span><br><span class="line"></span><br><span class="line">Copyright (c) Bruno Haible, Michael Stoll 1992, 1993</span><br><span class="line">Copyright (c) Bruno Haible, Marcus Daniels 1994-1997</span><br><span class="line">Copyright (c) Bruno Haible, Pierpaolo Bernardi, Sam Steingold 1998</span><br><span class="line">Copyright (c) Bruno Haible, Sam Steingold 1999-2000</span><br><span class="line">Copyright (c) Sam Steingold, Bruno Haible 2001-2010</span><br><span class="line"></span><br><span class="line">Type :h and hit Enter for context help.</span><br><span class="line">[1]&gt;</span><br></pre></td></tr></table></figure>
<p>尝试进行函数求值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1]&gt; (defun sum(x y) (format t &quot;~d&quot; (+ x y)))</span><br><span class="line">SUM</span><br><span class="line">[2]&gt; (sum 1 2)</span><br><span class="line">3</span><br><span class="line">NIL</span><br><span class="line">[3]&gt; (exit)</span><br><span class="line">Bye.</span><br></pre></td></tr></table></figure>
<p>或者，将以下内容写入<code>test.lisp</code>文件然后执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(defun sum(x y)</span><br><span class="line">  (format t &quot;~d&quot; (+ x y)))</span><br><span class="line">(sum 1 2)</span><br></pre></td></tr></table></figure>
<p>执行<code>LOCAL_PATH/bin/clisp test.lisp</code>成功输出。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>lisp</tag>
      </tags>
  </entry>
  <entry>
    <title>ebpf采集mysql请求信息及ebpf对应用安全的思考</title>
    <url>/2022/10/21/cljb83dlx0017kcs60fjy9gna/</url>
    <content><![CDATA[<blockquote>
<p>本文笔者继续介绍<code>ebpf</code> 的应用：使用<code>bpftrace</code>采集<code>mysql</code>连接信息，包括数据库地址、<code>db_name</code>、<code>user_name</code>。在展示采集操作的同时，附上对<code>ebpf</code>对云时代应用安全的一些思考。</p>
</blockquote>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>使用<code>bpftrace</code>对一个运行中进程的<code>mysql</code>请求进行采集，目标采集内容包括数据库地址、<code>db_name</code>、<code>user_name</code>。</p>
<span id="more"></span>
<p>目标进程代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// blog/main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line"></span><br><span class="line">	&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">	_ &quot;github.com/go-sql-driver/mysql&quot;</span><br><span class="line">	&quot;xorm.io/xorm&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var sqlE *xorm.Engine</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">	fmt.Println(&quot;init from main&quot;)</span><br><span class="line">	var err error</span><br><span class="line">	sqlE, err = xorm.NewEngine(&quot;mysql&quot;,</span><br><span class="line">		&quot;test:mysqltest@tcp(localhost:3306)/test_db?charset=utf8&amp;parseTime=true&quot;) // 随便写个数据库信息，假装是正确的</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Printf(&quot;init mysql failed: %+v\n&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Resp struct &#123;</span><br><span class="line">	Code int    `json:&quot;code&quot;`</span><br><span class="line">	Msg  string `json:&quot;msg&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SqlInfo struct &#123;</span><br><span class="line">	Id      int64     `json:&quot;id&quot; xorm:&quot;pk bigint(20)&quot;`</span><br><span class="line">	Created time.Time `json:&quot;created&quot; xorm:&quot;created&quot;`</span><br><span class="line">	Info    string    `json:&quot;info&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sql *SqlInfo) TableName() string &#123;</span><br><span class="line">	return &quot;sql_info&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Mysql(c *gin.Context) &#123;</span><br><span class="line">	info := c.Query(&quot;info&quot;)</span><br><span class="line">	if info == &quot;&quot; &#123;</span><br><span class="line">		now := time.Now().Format(&quot;2008-01-02 15:04:05&quot;)</span><br><span class="line">		info = now</span><br><span class="line">	&#125;</span><br><span class="line">	sqlInfo := SqlInfo&#123;</span><br><span class="line">		Info: info,</span><br><span class="line">	&#125;</span><br><span class="line">	affected, err := sqlE.Insert(&amp;sqlInfo)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Printf(&quot;insert db with error: %+v\n&quot;, err)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		log.Printf(&quot;affect column nums: %d\n&quot;, affected)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.JSON(http.StatusOK, &amp;Resp&#123;Code: 0, Msg: &quot;mysql req over&quot;&#125;)</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	srv := &amp;http.Server&#123;</span><br><span class="line">		Addr: &quot;0.0.0.0:9981&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(&quot;server start at: 0.0.0.0:9981&quot;)</span><br><span class="line">	r.GET(&quot;/sql&quot;, Mysql)</span><br><span class="line">	srv.Handler = r</span><br><span class="line">	err := srv.ListenAndServe()</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatal(&quot;error with start listener&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="bpftrace-代码"><a href="#bpftrace-代码" class="headerlink" title="bpftrace 代码"></a>bpftrace 代码</h1><p>直接上代码了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#! /bin/bpftrace</span><br><span class="line"></span><br><span class="line">/* 保存在 blog/blog.bt 里</span><br><span class="line"> 这里使用的 uprobe 函数为 go-sql-driver 里的内容。源代码在：</span><br><span class="line"> https://github.com/go-sql-driver/mysql/blob/master/connector.go#L23</span><br><span class="line"> 定义为：</span><br><span class="line"> func (c *connector) Connect(ctx context.Context) (driver.Conn, error) &#123;...&#125;</span><br><span class="line">*/</span><br><span class="line">uprobe:./blog:&quot;github.com/go-sql-driver/mysql.(*connector).Connect&quot;</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Connect\n&quot;);</span><br><span class="line">    $cfg_addr = *(uint64*)sarg0; // 获取 c.cfg 的地址</span><br><span class="line">    $user_addr = *(uint64*)($cfg_addr); // 获取 c.cfg.User</span><br><span class="line">    $user_len = *(uint64*)($cfg_addr+8); // 获取 len(c.cfg.User)</span><br><span class="line">    //$pwd_addr = *(uint64*)($cfg_addr+16); // 请注意这里注释掉的内容</span><br><span class="line">    //$pwd_len = *(uint64*)($cfg_addr+24);</span><br><span class="line">    $addr_addr = *(uint64*)($cfg_addr+48);</span><br><span class="line">    $addr_len = *(uint64*)($cfg_addr+56);</span><br><span class="line">    $db_addr = *(uint64*)($cfg_addr+64);</span><br><span class="line">    $db_len = *(uint64*)($cfg_addr+72);</span><br><span class="line">    printf(&quot;user: %s\n&quot;, str($user_addr, $user_len));</span><br><span class="line">    //printf(&quot;pwd: %s\n&quot;, str($pwd_addr, $pwd_len));</span><br><span class="line">    printf(&quot;addr: %s\n&quot;, str($addr_addr, $addr_len));</span><br><span class="line">    printf(&quot;db: %s\n&quot;, str($db_addr, $db_len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而后启动应用程序<code>blog</code>，启动监听程序<code>sudo bpftrace ./blog.bt</code>，请求<code>blog</code>的<code>/sql</code>接口以触发<code>blog</code>对<code>sql</code>的请求。整个过程对<code>blog</code>程序来说没有任何的不平凡之处，但是我们已经获取了采集结果。<br>附上执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./blog</span><br><span class="line">init from main</span><br><span class="line">[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.</span><br><span class="line"></span><br><span class="line">[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.</span><br><span class="line"> - using env:	export GIN_MODE=release</span><br><span class="line"> - using code:	gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">2022/10/21 20:15:38 server start at: 0.0.0.0:9981</span><br><span class="line">[GIN-debug] GET    /sql                      --&gt; main.Mysql (3 handlers)</span><br><span class="line">2022/10/21 20:18:52 insert db with error: dial tcp 127.0.0.1:3306: connect: connection refused</span><br><span class="line">[GIN] 2022/10/21 - 20:18:52 | 200 |    3.679499ms |       127.0.0.1 | GET      &quot;/sql&quot;</span><br></pre></td></tr></table></figure>
<p>此时，在采集侧：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo ./blog.bt</span><br><span class="line">Attaching 1 probe...</span><br><span class="line">Connect</span><br><span class="line">user: test</span><br><span class="line">addr: localhost:3306</span><br><span class="line">db: test_db</span><br></pre></td></tr></table></figure>
<p>我们已经获取了需要的信息。</p>
<h1 id="对采集代码的一些说明"><a href="#对采集代码的一些说明" class="headerlink" title="对采集代码的一些说明"></a>对采集代码的一些说明</h1><p><code>bpftrace</code>语法部分，参见<a href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md">github-bpftrace-reference_guid</a>。里面有<code>ebpf</code>的一些简单介绍以及<code>bpftrace</code>的使用说明。代码里的主要逻辑，则需要参见<code>golang</code>的语法来理解。部分简述如下：</p>
<ul>
<li>类里的方法，实际调用的时候，第一个参数为对象的地址；</li>
<li>go-1.16 及之前的版本，参数存储在栈上；</li>
</ul>
<p>剩下的内容就比较好理解了：<code>ebpf</code>提供的核心功能包括按需读取用户空间内的数据。结合<a href="https://liyan-ah.github.io/2022/06/06/golang-%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E5%AD%97%E8%8A%82%E6%95%B0/#more">golang-常见类型字节数</a>可以比较快的推导出我们需要的信息在地址内的偏移量。同时，在<a href="https://liyan-ah.github.io/2022/07/22/bpfTrace-%E8%BF%BD%E8%B8%AA-uprobe/#more">bpftrace无侵入遍历golang链表</a>曾经提到过，如果目标对象比较大，无法在<code>ebpf</code>代码里完整定义该对象（内核限制单个<code>ebpf</code>的<code>hook</code>点程序的栈空间大小在<code>512B</code>），我们访问对象里的成员时，使用的方法就是偏移量访问。</p>
<h1 id="ebpf-与应用安全的一些思考"><a href="#ebpf-与应用安全的一些思考" class="headerlink" title="ebpf 与应用安全的一些思考"></a>ebpf 与应用安全的一些思考</h1><p>最后提一点自己的思考。<br>请回到<code>bpftrace</code>代码里，里面的<code>pasword</code>信息获取的操作被注释掉了。其实我们去掉注释，仍然能够按照预期获取结果。这就意味着，如果我们拥有机器上的权限，并且机器满足我们的采集需求，应用里的核心信息（这里是数据库的密码）将被简单的获取。无论数据库密码如何存储：配置文件、源代码、通过网络配置下发等。只要有涉及数据库访问的用户态函数，有涉及数据库密码传递的内容，这些信息存在被获取的风险，只要采集人拥有<code>root</code>权限。<br>这里引出另外一个问题：如果一个用户拥有机器上的管理员权限，<code>TA</code>是否应该拥有机器上所有进程信息的准入权。这里的进程信息，显然是包括机器上容器内的进程信息的，无论是公有云或者私有云。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>ebpf</tag>
        <tag>mysql</tag>
        <tag>采集</tag>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>elscreen标签背景颜色</title>
    <url>/2020/12/23/cljb83dly0019kcs6gk5jhhic/</url>
    <content><![CDATA[<blockquote>
<p>使用<code>emacs</code>过程中，配合<code>evil</code>使用，按照<code>tab</code>的划分，将编辑、浏览、<code>leetcode</code>等任务划分到不同的<code>tab</code>便于切换及管理。美中不足的是，模拟标签的<code>elscreen</code>默认将其他标签的颜色设置成<code>:background blue  :foreground black</code>的配色，每次切换任务时，都需要重复确认需要跳转到哪个标签，就比较麻烦了。查找了一下重置<code>face-attribute</code>的方法，备注下。</p>
</blockquote>
<p>在初始文件的最后添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;; 选中标签设置为绿底黑字，其他标签为黄底黑字</span><br><span class="line">(set-face-attribute &#x27;elscreen-tab-other-screen-face nil</span><br><span class="line">                    :background &quot;yellow&quot; :foreground &quot;black&quot;)</span><br><span class="line">(set-face-attribute &#x27;elscreen-tab-current-screen-face nil</span><br><span class="line">                    :background &quot;green&quot; :foreground &quot;black&quot;)</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>备注下<a href="https://github.com/knu/elscreen"><code>elscreen</code></a>原始代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(defface elscreen-tab-current-screen-face</span><br><span class="line">  &#x27;((((class color))</span><br><span class="line">     (:background &quot;white&quot; :foreground &quot;black&quot;))</span><br><span class="line">    (t (:underline t)))</span><br><span class="line">  &quot;Face for current screen tab.&quot;</span><br><span class="line">  :group &#x27;elscreen)</span><br><span class="line"></span><br><span class="line">(defface elscreen-tab-other-screen-face</span><br><span class="line">  &#x27;((((type x w32 mac ns) (class color))</span><br><span class="line">     :background &quot;Gray85&quot; :foreground &quot;Gray50&quot;)</span><br><span class="line">    (((class color))</span><br><span class="line">     (:background &quot;blue&quot; :foreground &quot;black&quot; :underline t)))</span><br><span class="line">  &quot;Face for tabs other than current screen one.&quot;</span><br><span class="line">  :group &#x27;elscreen)</span><br></pre></td></tr></table></figure>
<p><a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Defining-Faces.html">emacs defface</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>emacs</tag>
        <tag>vim</tag>
        <tag>elscreen</tag>
      </tags>
  </entry>
  <entry>
    <title>ebpf 采集ebpf 采集tag+tcp五元组</title>
    <url>/2023/02/24/cljb83dlz001ckcs6dmn3hrpr/</url>
    <content><![CDATA[<blockquote>
<p>在这里对文章题目作一些说明。笔者想了很长时间也无法给这篇文章想个恰当的表意题目。实际上使用<code>ebpf</code>来进行服务观测是有在进行的，比如获取目前<code>l1s</code>上的常见的四元组。但是本文不是介绍这部分可观测实践的。文章希望阐述的场景是：采集请求触发里的一些信息（诸如<code>trace</code>及其他<code>header</code>等）并和服务请求下游的传输层五元组(protocol, src-ip, src-port, dst-ip, dst-port)进行关联。这也是最近工作中实际遇到的问题。</p>
</blockquote>
<p>基于<code>ebpf</code>的丰富的特性能够获取服务很多的信息，不同特性的组合更是可以达到极强的数据整合能力。比如通过<code>uprobe</code>便捷的获取业务信息后，结合<code>kprobe</code>来获取系统调用里的内容，可以获取一般侵入式可观测代码无法获取的内容。笔者最近遇到的一个实际问题是：获取服务<code>A</code>的接口<code>/a</code>响应后，向下游<code>B</code>发起的请求时，所使用的传输层五元组，同时带上结合一些<code>/a</code>触发时的一些内容，比如<code>caller_fun</code>或者<code>traceId</code>。<br>这里值得说明的是，用户态请求的是一个域名。域名的解析是在<code>golang</code>的<code>http</code>里完成的。但是请注意，<code>golang</code>发起<code>tcp</code>请求时，<code>local port</code>设置的是<code>0</code>，然后由内核态的<code>tpc</code>处理来选择一个空闲的<code>port</code>作为<code>socket</code>里的<code>lport</code>。这部分的信息通过代码的埋点显然是无法获取的（详情可参考<a href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247485577&idx=1&sn=24220fcc3782f61b4a691585251f1c27&chksm=a6e309b2919480a4696c8a2944ad887951100b5068050d354eab40cf0c8f1124b6367176a0a6&scene=21#wechat_redirect">TCP连接中客户端的端口号是如何确定的？</a>）。<br>下面介绍下实现效果及思路。  </p>
<blockquote>
<p>关于<code>bpftrace</code>使用的介绍，可以参见：<a href="https://liyan-ah.github.io/2022/07/22/bpfTrace-%E8%BF%BD%E8%B8%AA-uprobe/#more">bpftrace 无侵入遍历golang链表</a>，关于<code>ebpf</code>来进行数据采集的实践，可以参见<a href="https://liyan-ah.github.io/2022/10/21/ebpf%E9%87%87%E9%9B%86mysql%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF%E5%8F%8Aebpf%E5%AF%B9%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E7%9A%84%E6%80%9D%E8%80%83/">ebpf采集mysql请求信息及ebpf对应用安全的思考</a>。</p>
</blockquote>
<span id="more"></span>

<h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p>服务端启动、触发的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动目标服务</span><br><span class="line">./caller_tuple</span><br><span class="line">[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.</span><br><span class="line"></span><br><span class="line">[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.</span><br><span class="line"> - using env:	export GIN_MODE=release</span><br><span class="line"> - using code:	gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">[GIN-debug] GET    /echo                     --&gt; main.Echo (3 handlers)</span><br><span class="line"># 这里触发一次接口调用</span><br><span class="line">[GIN] 2023/02/24 - 22:05:29 | 200 |   85.618975ms |       127.0.0.1 | GET      &quot;/echo&quot;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">`bpftrace` 采集端的效果：</span><br><span class="line">```   </span><br><span class="line"># 启动采集</span><br><span class="line">bpftrace ./caller.bt</span><br><span class="line">Attaching 3 probes...</span><br><span class="line">start to gather caller info.</span><br><span class="line">get caller path: /echo</span><br><span class="line"># 将 caller_path 和 传输层五元组结合起来（本机的IP实际上是输出的，但是为了信息安全，就使用 0.0.0.0 来代替了）</span><br><span class="line">caller info: /echo</span><br><span class="line">3326691  caller_tuple     0.0.0.0                            38610  110.242.68.66                           80</span><br></pre></td></tr></table></figure>

<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>这里分别上一下目标服务<code>caller_func</code>以及采集脚本<code>caller.bt</code>的代码，来说明下实现思路。</p>
<pre><code>// ./caller_tuple/main.go
package main

import (
    &quot;net/http&quot;

    &quot;github.com/gin-gonic/gin&quot;
)

type Resp struct &#123;
    Errno int64  `json:&quot;errno&quot;`
    Msg   string `json:&quot;msg&quot;`
&#125;

func Echo(c *gin.Context) &#123;
    req, _ := http.NewRequest(http.MethodGet, &quot;http://baidu.com&quot;, nil)
    client := http.Client&#123;&#125;
    resp, err := client.Do(req)
    if err != nil &#123;
        c.JSON(http.StatusOK, &amp;Resp&#123;Errno: 1, Msg: &quot;request error&quot;&#125;)
        return
    &#125;
    defer resp.Body.Close()
    c.JSON(http.StatusOK, &amp;Resp&#123;Errno: 0, Msg: &quot;ok&quot;&#125;)
    return
&#125;

func main() &#123;
    r := gin.Default()
    srv := &amp;http.Server&#123;
        Addr: &quot;0.0.0.0:3344&quot;,
    &#125;
    r.GET(&quot;/echo&quot;, Echo)
    srv.Handler = r
    srv.ListenAndServe()
&#125;


// caller_tuple/caller.bt
#!/usr/bin/env bpftrace

#define AF_INET 2

struct sock_common &#123;
        union &#123;
                struct &#123;
                        __be32 skc_daddr;
                        __be32 skc_rcv_saddr;
                &#125;;
        &#125;;
        union &#123;
                unsigned int skc_hash;
                __u16 skc_u16hashes[2];
        &#125;;
        union &#123;
                struct &#123;
                        __be16 skc_dport;
                        __u16 skc_num;
                &#125;;
        &#125;;
        short unsigned int skc_family;
&#125;;

struct sock &#123;
        struct sock_common __sk_common;
&#125;;

BEGIN&#123;
    printf(&quot;start to gather caller info.\n&quot;);
    @caller[pid] = &quot;none&quot;;
&#125;

// 这里通过 uprobe 来便捷的获取会话信息。同时将信息写入bpf_map
uprobe:./caller_tuple:&quot;net/http.serverHandler.ServeHTTP&quot;&#123;
    $req_ptr = sarg3;
    $method_ptr = *(uint64*)($req_ptr);
    $method_len = *(uint64*)($req_ptr+8);

    /* read request.url.Path */
    $url_ptr = *(uint64*)($req_ptr + 16);
    $path_ptr = *(uint64*)($url_ptr+56);
    $path_len = *(uint64*)($url_ptr+64);
    printf(&quot;get caller path: %s\n&quot;, str($path_ptr, $path_len));
    // 这里使用 pid 来作为 key 只是为了实现方便。实际可以采取其他更有区分性的内容。
    @caller_ptr[pid]=$path_ptr;
    @caller_len[pid]=$path_len;
&#125;

// 通过 kprobe 来获取用户态无法获取的内容。同时通过 bpf_map 来控制生效及内容的交互。
kprobe:tcp_connect
&#123;
    if (@caller_ptr[pid] == 0)&#123;
        return;
    &#125;
    $ptr = @caller_ptr[pid];
    $len = @caller_len[pid];
    printf(&quot;caller info: %s\n&quot;, str($ptr, $len));
    @caller_ptr[pid] = 0;
    @caller_len[pid] = 0;

  $sk = ((struct sock *) arg0);
  $inet_family = $sk-&gt;__sk_common.skc_family;

  if ($inet_family == AF_INET) &#123;
    $daddr = ntop($sk-&gt;__sk_common.skc_daddr);
    $saddr = ntop($sk-&gt;__sk_common.skc_rcv_saddr);
    $lport = $sk-&gt;__sk_common.skc_num;
    $dport = $sk-&gt;__sk_common.skc_dport;
    $dport = (((($dport) &gt;&gt; 8) &amp; 0xff) | ((($dport) &amp; 0xff) &lt;&lt; 8));
    printf(&quot;%-8d %-16s &quot;, pid, comm);
    printf(&quot;%-39s %-6d %-39s %-6d\n&quot;, $saddr, $lport, $daddr, $dport);
  &#125;
&#125;
</code></pre>
<p>这样就达到了笔者的目标。这只是<code>ebpf</code>应用的一个简单的场景，更多的<code>metric</code>采集内容仍在进行。<br>以上，周末愉快！</p>
]]></content>
  </entry>
  <entry>
    <title>emacs org-mode 绘制思维导图</title>
    <url>/2023/02/10/cljb83dm0001ekcs6ejdsdn3i/</url>
    <content><![CDATA[<blockquote>
<p>工作中难免会搞一些思维导图，一些小的需求又不希望切换窗口到另外一个界面去特地绘制。使用 emacs 来整理思维导图可以提升一些的效率，在当前窗口（文本编辑器）里即可完成简单思维导图的绘制。同时可以便于对工作内容进行归档（比如把相关的文本都放到一起）。live in emacs.</p>
</blockquote>
<h1 id="依赖内容"><a href="#依赖内容" class="headerlink" title="依赖内容"></a>依赖内容</h1><ul>
<li>org-contrib 扩展文件。用来将 org-mode 格式的文本转换成 freemind mm 文件。</li>
<li>freemind 软件。用来查看生成的 mm 文件。  </li>
</ul>
<p>笔者试了一下，<code>Xmind思维导图</code>看起来无法打开<code>mm</code>文件，<code>freemind</code>工作正常。也可能是我操作有问题。<br>此外，生成的思维导图展现样式肯定没有目前专业的思维导图工具丰富，如果有正式的使用需求，还是首先考虑下专业的思维导图工具。</p>
<span id="more"></span>

<h1 id="org-contrib-安装"><a href="#org-contrib-安装" class="headerlink" title="org-contrib 安装"></a>org-contrib 安装</h1><p>笔者使用的<code>emacs</code>发布版本默认没有<code>org-contrib</code>，需要自行安装。安装过程也比较简单，从<code>github</code>里把<code>org-contrib</code>拉下来，在<code>emacs init.el</code>里配置加载路径，然后主动加载需要的<code>ox-freemind.el</code>即可。<br><code>github org-contrib</code>地址为<code>git@github.com:emacsmirror/org-contrib.git</code>。目录地址可以视自己的需求确定。笔者的<code>emacs</code>配置都放到了<code>.emacs.d</code>里，<code>org-contrib</code>的本地目录也就放到了<code>~/.emacs.d/org-contrib</code>这里。扩展下载后，在<code>init.el</code>里做如下配置即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;; ox-fremind</span><br><span class="line">;; 这里改成本地的 org-contrib 地址</span><br><span class="line">(add-to-list &#x27;load-path &quot;~/.emacs.d/org-contrib/lisp&quot;)</span><br><span class="line">;; 目前只需要 ox-freemind，因此仅加载这个插件。</span><br><span class="line">(load-file &quot;~/.emacs.d/org-contrib/lisp/ox-freemind.el&quot;)</span><br></pre></td></tr></table></figure>

<p>安装结束后，需要重新加载一下<code>emacs</code>的配置文件，<code>ox-freemind</code>才能可用。</p>
<h1 id="使用-org-mode-整理文档并转换"><a href="#使用-org-mode-整理文档并转换" class="headerlink" title="使用 org-mode 整理文档并转换"></a>使用 org-mode 整理文档并转换</h1><p>这里直接贴一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#+TITLE:  emacs org-mode 绘制思维导图</span><br><span class="line">#+OPTIONS: H:1000</span><br><span class="line"></span><br><span class="line">* org-contrib 安装</span><br><span class="line">   org-contrib 可以直接从 github 下载，然后在 emacs 配置文件里加载。</span><br><span class="line">** org-contrib github 地址</span><br><span class="line">*** git@github.com:emacsmirror/org-contrib.git</span><br><span class="line">** emacs 本地配置</span><br><span class="line">*** (add-to-list &#x27;load-path &quot;~/.emacs.d/org-contrib/lisp&quot;)(load-file &quot;~/.emacs.d/org-contrib/lisp/ox-freemind.el&quot;)</span><br><span class="line">* org-mode 下文档编写</span><br><span class="line">** org-mode 是 emacs 下的神器</span><br><span class="line">*** 打开 freemind.org 文件，输入这个文本</span><br><span class="line">** 转换文本文件到 freemind mm 文件</span><br><span class="line">*** M-x org-freemind-export-to-freemind</span><br><span class="line">* 查看 mm 文件</span><br><span class="line">** 使用 freemind 查看生成的 freemind.mm</span><br></pre></td></tr></table></figure>

<p>用<code>emacs</code>打开一个<code>freemind.org</code>，笔者这里直接触发了<code>org-mode</code>。如果没有触发<code>org-mode</code>的话，需要手动执行下<code>M-x org-mode</code>。然后执行<code>org-freemind-export-to-freemind</code>。如果没有这个函数，需要看下之前<code>org-contrib</code>的安装是否有问题，或者加载路径是否正常，加载是否有报错。如果函数执行异常，则需要查下原因。笔者安装后即可直接执行，因此没有报错处置的经验可供参考。  </p>
<h1 id="使用freemind查看及导出"><a href="#使用freemind查看及导出" class="headerlink" title="使用freemind查看及导出"></a>使用freemind查看及导出</h1><p><code>mac</code>可以直接<code>brew install --cask freemind</code>。或者到其他下载源下载，如<a href="https://freemind.sourceforge.net/wiki/index.php/Download">freemind sourceforge 下载</a>。<br>最后使用<code>freemind</code>打开<code>freemind.org</code>同级目录生成的<code>freemind.mm</code>。展示效果如下：<br><img src="/images/freemind.png" alt="upload successful"><br>最后，可以使用<code>emacs</code>查看导出的<code>freemind.png</code>（🐶，笔者还在探索如何在不打开<code>freemind</code>的情况下把<code>mm</code>文件转换成<code>png</code>)。</p>
]]></content>
  </entry>
  <entry>
    <title>find匹配文件名</title>
    <url>/2020/11/12/cljb83dm1001hkcs6hynvgc2z/</url>
    <content><![CDATA[<p>目录内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">text  text.bak</span><br></pre></td></tr></table></figure>
<p>希望从中找到<code>text.bak</code>。使用<code>find</code>实现。</p>
<span id="more"></span>
<p>错误操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;find -name *.bak* .</span><br><span class="line">find: paths must precede expression: .</span><br><span class="line">Usage: find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path...] [expression]</span><br></pre></td></tr></table></figure>
<p><code>-name</code>会作为<code>EXPRESSIONS</code>存在。<code>find</code>要求的参数位置为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find [-H] [-L] [-P] [-D debugopts] [-Olevel] [path...] [expression]</span><br></pre></td></tr></table></figure>
<p>所以，正确格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -name *.bak</span><br><span class="line">./text.bak</span><br></pre></td></tr></table></figure>
<p>关于正则中<code>.</code>会作为通配符，如需匹配<code>text.bak</code>需要对<code>.</code>进行转义的情况，也需要关注下。本例中就不涉及了。</p>
]]></content>
  </entry>
  <entry>
    <title>emacs-若干语言 lsp 配置备注</title>
    <url>/2021/10/12/cljb83dm1001jkcs65inacuh2/</url>
    <content><![CDATA[<blockquote>
<p>微软推出的<a href="https://microsoft.github.io/language-server-protocol/#:~:text=Language%20Server%20Protocol.%20The%20Language%20Server%20Protocol%20%28LSP%29,is%20to%20support%20rich%20code%20navigation%20in%20">language server protol</a> 确实提升了文本编辑器的使用体验。就 <code>emacs</code> 的使用而言，配合各个语言的 lsp 实现，能够减少配置语言开发环境的难度。这里记录一下使用 <code>emacs</code> 中的 rust, golang, python, c/c++ lsp 配置</p>
</blockquote>
<span id="more"></span>

<h1 id="rust"><a href="#rust" class="headerlink" title="rust"></a>rust</h1><p>这里使用 <code>rust-analyzer</code> 作为 <code>rust</code> 的语言服务器，在安装 <code>rust-mode</code>后，通过绑定语言服务器信息，即可在打开由 <code>cargo</code> 创建的工程时，顺利进入 <code>lsp-mode</code>。需要关注的是，在非<code>cargo</code>创建的项目中，笔者的<code>lsp-mode</code>使用体验很差，甚至缺少代码补充、语法提示等功能。可能是<code>rust-analyzer</code>主要是针对<code>cargo</code>项目进行的设置，也可能是笔者设置的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;; config for rust-lsp for emacs</span><br><span class="line">;; rls install address: https://github.com/rust-lang-nursery/rls</span><br><span class="line">(unless (package-installed-p &#x27;rust-mode)</span><br><span class="line">  (w-install &#x27;rust-mode))</span><br><span class="line">(add-to-list &#x27;auto-mode-alist &#x27;(&quot;\\.rs\\&#x27;&quot; . rust-mode))</span><br><span class="line">(add-hook &#x27;rust-mode-hook &#x27;lsp)</span><br><span class="line">(unless (package-installed-p &#x27;rustic)</span><br><span class="line">  (w-install &#x27;rustic))</span><br><span class="line">(unless (package-installed-p &#x27;cargo)</span><br><span class="line">  (w-install &#x27;cargo))</span><br><span class="line">(use-package rustic) ; lsp-compatible rust mode</span><br><span class="line">(add-hook &#x27;rust-mode-hook &#x27;rustic-mode)</span><br><span class="line">(add-hook &#x27;rustic-mode-hook</span><br><span class="line">  (lambda ()</span><br><span class="line">    (setq rustic-lsp-server &#x27;rust-analyzer) ; not rls</span><br><span class="line">    (setq lsp-rust-analyzer-server-command &#x27;(&quot;/opt/homebrew/bin/rust-analyzer&quot;))</span><br><span class="line">                                        ;(setq rustic-format-on-save t) ; has annoying bug move point to other buffer bug</span><br><span class="line">  (setq rustic-indent-offset 4)</span><br><span class="line">    (setq rustic-match-angle-brackets nil)</span><br><span class="line">    ;; thought this would be better, was wrong.</span><br><span class="line">    ;(setq rustic-compile-display-method &#x27;popwin:display-buffer-1) ; display if possible in popup-win</span><br><span class="line">    ))</span><br><span class="line">(use-package cargo)</span><br><span class="line">(setq lsp-rust-server &#x27;rust-analyzer)</span><br></pre></td></tr></table></figure>
<h1 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h1><p><code>golang</code>作为谷歌的亲儿子，是拥有官方维护的语言服务器的。而且<code>gopls</code>的使用体验非常好，完全不逊色与目前用户较多的<code>goland</code>及<code>vscode</code>。配合<code>dlv-mode</code>使用，在调试上笔者认为能够更加的贴合<code>unix</code>风格，也更加方便。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;; Go - lsp-mode</span><br><span class="line">;; Set up before-save hooks to format buffer and add/delete imports.</span><br><span class="line">;; go install github.com/golang/tools/cmd/gopls</span><br><span class="line">;;(require &#x27;lsp-mode)</span><br><span class="line">(setq lsp-ui-mode nil)</span><br><span class="line">(defun lsp-go-install-save-hooks ()</span><br><span class="line">  (add-hook &#x27;before-save-hook #&#x27;lsp-format-buffer t t)</span><br><span class="line">  (add-hook &#x27;before-save-hook #&#x27;lsp-organize-imports t t))</span><br><span class="line">(add-hook &#x27;go-mode-hook #&#x27;lsp-go-install-save-hooks)</span><br><span class="line"></span><br><span class="line">;; Start LSP Mode and YASnippet mode</span><br><span class="line">(add-hook &#x27;go-mode-hook #&#x27;lsp-deferred)</span><br><span class="line">(add-hook &#x27;go-mode-hook #&#x27;yas-minor-mode)</span><br></pre></td></tr></table></figure>
<h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><p><code>python</code>的语言服务器，笔者目前使用的是<code>lsp-python-ms</code>进行配置的。这个插件解决了很多<code>python lsp</code>的问题（实际上，在碰到这个插件之前，笔者一度要放弃安装<code>python lsp</code>）。由于<code>python</code>是解释型语言，对象的成员都较为灵活，一般编码阶段很难确认对象的成员及其确切的类型。所以在<code>pylsp</code>使用过程中，往往会碰到无法有效提示的情况。满足一般提示需求吧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;;; set env for python</span><br><span class="line">;; copied from</span><br><span class="line">;; https://gitee.com/nutora-emacs/lsp-python-ms</span><br><span class="line">;; python lsp-server use python-lsp-server</span><br><span class="line">;; install as: pip3 install python-lsp-server</span><br><span class="line">(ensure-package-installed &#x27;lsp-python-ms)</span><br><span class="line">(require &#x27;lsp-python-ms)</span><br><span class="line">(setq lsp-python-ms-auto-install-server t)</span><br><span class="line">(add-hook &#x27;python-mode-hook #&#x27;lsp)</span><br></pre></td></tr></table></figure>
<h1 id="c-c"><a href="#c-c" class="headerlink" title="c/c++"></a>c/c++</h1><p>实际上，笔者很喜欢<code>c/c++</code>的语言服务器，简单、方便，安装时无比的顺畅。完全符合笔者对<code>c</code>语言简单、强大、靠谱的印象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;; set up lsp-mode for c/c++</span><br><span class="line">;; brew install llvm</span><br><span class="line">;; https://clangd.llvm.org/installation</span><br><span class="line">(unless (package-installed-p &#x27;eglot)</span><br><span class="line">  (w-install &#x27;eglot))</span><br><span class="line">(require &#x27;eglot)</span><br><span class="line">(add-to-list &#x27;eglot-server-programs &#x27;((c++-mode c-mode) &quot;clangd&quot;))</span><br><span class="line">(add-hook &#x27;c-mode-hook &#x27;eglot-ensure)</span><br><span class="line">(add-hook &#x27;c++-mode-hook &#x27;eglot-ensure)</span><br></pre></td></tr></table></figure>
<h1 id="使用的一点备注"><a href="#使用的一点备注" class="headerlink" title="使用的一点备注"></a>使用的一点备注</h1><p>这里唠叨一点</p>
<h2 id="lsp-的管理单位是文件目录"><a href="#lsp-的管理单位是文件目录" class="headerlink" title="lsp 的管理单位是文件目录"></a>lsp 的管理单位是文件目录</h2><p>这里对于<code>golang</code>及<code>rust</code>尤为明显。在使用<code>emacs</code>打开一个关联了有效语言服务器的文件时，底部会提示为当前文件选择一个工作目录。尤其是，当路径<code>A</code>已经设为工作目录时，再将<code>A/B</code>设为工作目录，<code>A/B</code>的打开状态是会出现异常的。所以尽量保持每个工作目录的独特。<br>这里附上一些<code>emacs lsp-mode</code>中笔者常用的函数： </p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>lsp-workspace-folders-remove</code></td>
<td>将工作目录移除</td>
</tr>
<tr>
<td><code>lsp-workspace-folders-add</code></td>
<td>添加工作目录</td>
</tr>
<tr>
<td><code>lsp-workspace-restart</code></td>
<td>重启工作目录</td>
</tr>
</tbody></table>
<h2 id="其他备注"><a href="#其他备注" class="headerlink" title="其他备注"></a>其他备注</h2><p>当安装了一个语言的<code>lsp</code>服务及对应的<code>emacs</code>客户端配置时，如果打开对应语言的文件发现<code>lsp</code>没有生效，且打开<code>toggle-debug-on-error</code>设置开启也没有发现任何报错，笔者建议重启<code>emacs</code>。似乎<code>emacs</code>热加载功能往往不会如人所愿。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://emacs-lsp.github.io/lsp-mode/">emacs lsp mode</a><br>及其他网络文献</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>emacs</tag>
        <tag>lsp</tag>
        <tag>rust</tag>
        <tag>python</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title>go-1.17+ 调用规约</title>
    <url>/2023/03/03/cljb83dm2001mkcs68hgf9o2s/</url>
    <content><![CDATA[<blockquote>
<p><code>go-1.17</code>是一个很不友好的版本，这里我指的是函数调用规约的变更。在此之前，虽然栈传参比较奇怪，但是在掌握了规律后，参数信息很好获取。升级到<code>go-1.17</code>之后，笔者发现变更后的寄存器传值方式并不是系统的调用规约，至少和<code>C/C++</code>的是完全不一致的。这个问题使得笔者在处理<code>ebpf</code>方案时，始终无法覆盖<code>go-1.17+</code>的版本。虽然短期不会造成影响，线上服务使用的大多还在<code>go-1.16</code>以下，但是这始终是一个绕不过去的问题。近期通过查阅资料和参考其他开源项目里对这部分内容的处理，整理了一下<code>go-1.17+</code>的调用规约。</p>
</blockquote>
<p><code>go</code>在<code>1.17</code>之前使用的是内存栈来传递参数，这种传参的方式使得<code>golang</code>的语言设计很灵活：<code>golang</code>函数的多返回值能够很容易的实现。同样的，由于<code>golang</code>需要这样灵活的能力，是的系统默认的调用规约方式并不适用。在<a href="https://go.googlesource.com/proposal/+/refs/changes/78/248178/1/design/40724-register-calling.md">Proposal: Register-based Go calling convention</a>文章里对这个问题进行了详细的讨论，总结起来是<code>golang</code>的特性使得使用系统默认规约并不能带来多语言交互上的收益，且<code>golang</code>希望保持独特。<br>本文下面会给出总结的调用规约，并且给出验证程序。本文档的整理所基于的平台是<code>x86_64</code>的<code>centos8</code>系统。其他架构下，寄存器名称可能不同。</p>
<span id="more"></span>

<h1 id="调用规约"><a href="#调用规约" class="headerlink" title="调用规约"></a>调用规约</h1><p>入参：  </p>
<table>
<thead>
<tr>
<th>参数序号</th>
<th>标准规约</th>
<th>golang规约</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>rdi</td>
<td>rax</td>
</tr>
<tr>
<td>2</td>
<td>rsi</td>
<td>rbx</td>
</tr>
<tr>
<td>3</td>
<td>rdx</td>
<td>rcx</td>
</tr>
<tr>
<td>4</td>
<td>rcx</td>
<td>rdi</td>
</tr>
<tr>
<td>5</td>
<td>r8</td>
<td>rsi</td>
</tr>
<tr>
<td>6</td>
<td>r9</td>
<td>r8</td>
</tr>
<tr>
<td>7</td>
<td>栈传值</td>
<td>r9</td>
</tr>
<tr>
<td>8</td>
<td>栈传值</td>
<td>r10</td>
</tr>
<tr>
<td>9</td>
<td>栈传值</td>
<td>r11</td>
</tr>
<tr>
<td>10</td>
<td>栈传值</td>
<td>栈传值</td>
</tr>
</tbody></table>
<p>返回值：</p>
<table>
<thead>
<tr>
<th>参数序号</th>
<th>标准规约</th>
<th>golang规约</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>rax</td>
<td>rax</td>
</tr>
<tr>
<td>2</td>
<td>-</td>
<td>rbx</td>
</tr>
<tr>
<td>3</td>
<td>-</td>
<td>rcx</td>
</tr>
<tr>
<td>4</td>
<td>-</td>
<td>rdi</td>
</tr>
<tr>
<td>5</td>
<td>-</td>
<td>rsi</td>
</tr>
<tr>
<td>6</td>
<td>-</td>
<td>r8</td>
</tr>
<tr>
<td>7</td>
<td>-</td>
<td>r9</td>
</tr>
<tr>
<td>8</td>
<td>-</td>
<td>r10</td>
</tr>
<tr>
<td>9</td>
<td>-</td>
<td>r11</td>
</tr>
<tr>
<td>10</td>
<td>-</td>
<td>栈传值</td>
</tr>
</tbody></table>
<h1 id="验证规约"><a href="#验证规约" class="headerlink" title="验证规约"></a>验证规约</h1><p>这个条件是比较好验证的，看下验证代码:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go version 1.18</span></span><br><span class="line"><span class="comment">// ./go_18/arg/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longArgs</span><span class="params">(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 <span class="keyword">uint64</span>)</span> <span class="params">(r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11 <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> a1 + <span class="number">1</span>, a2 + <span class="number">2</span>, a3 + <span class="number">3</span>, a4 + <span class="number">4</span>, a5 + <span class="number">5</span>, a6 + <span class="number">6</span>, a7 + <span class="number">7</span>, a8 + <span class="number">8</span>, a9 + <span class="number">9</span>, a10 + <span class="number">10</span>, a11 + <span class="number">11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 := longArgs(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>)</span><br><span class="line">	fmt.Println(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先生成<code>plan9</code>代码以说明参数传入和参数返回均是使用的寄存器，并且寄存器顺序是一致的（内存传参时也是）。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> build -gcflags <span class="string">&quot;-N -S -l&quot;</span> &gt;&gt; arg.info</span><br><span class="line"># 然后截取部分生成 plan9 汇编</span><br><span class="line"># go_18/arg</span><br><span class="line"><span class="string">&quot;&quot;</span>.longArgs STEXT nosplit size=<span class="number">411</span> args=<span class="number">0x68</span> locals=<span class="number">0x50</span> funcid=<span class="number">0x0</span> align=<span class="number">0x0</span></span><br><span class="line">	<span class="number">0x0000</span> <span class="number">00000</span> 	TEXT	<span class="string">&quot;&quot;</span>.longArgs(SB), NOSPLIT|ABIInternal, $<span class="number">80</span><span class="number">-104</span></span><br><span class="line">	<span class="number">0x0000</span> <span class="number">00000</span> 	SUBQ	$<span class="number">80</span>, SP</span><br><span class="line">	<span class="number">0x0004</span> <span class="number">00004</span> 	MOVQ	BP, <span class="number">72</span>(SP)</span><br><span class="line">	<span class="number">0x0009</span> <span class="number">00009</span> 	LEAQ	<span class="number">72</span>(SP), BP</span><br><span class="line">	<span class="number">0x000e</span> <span class="number">00014</span> 	FUNCDATA	$<span class="number">0</span>, gclocals·<span class="number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	<span class="number">0x000e</span> <span class="number">00014</span> 	FUNCDATA	$<span class="number">1</span>, gclocals·<span class="number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	<span class="number">0x000e</span> <span class="number">00014</span> 	FUNCDATA	$<span class="number">5</span>, <span class="string">&quot;&quot;</span>.longArgs.arginfo1(SB)</span><br><span class="line">	<span class="number">0x000e</span> <span class="number">00014</span> 	MOVQ	AX, <span class="string">&quot;&quot;</span>.a1+<span class="number">120</span>(SP)  # 注意这里的读取参数寄存器</span><br><span class="line">	<span class="number">0x0013</span> <span class="number">00019</span> 	MOVQ	BX, <span class="string">&quot;&quot;</span>.a2+<span class="number">128</span>(SP)</span><br><span class="line">	<span class="number">0x001b</span> <span class="number">00027</span> 	MOVQ	CX, <span class="string">&quot;&quot;</span>.a3+<span class="number">136</span>(SP)</span><br><span class="line">	<span class="number">0x0023</span> <span class="number">00035</span> 	MOVQ	DI, <span class="string">&quot;&quot;</span>.a4+<span class="number">144</span>(SP)</span><br><span class="line">	<span class="number">0x002b</span> <span class="number">00043</span> 	MOVQ	SI, <span class="string">&quot;&quot;</span>.a5+<span class="number">152</span>(SP)</span><br><span class="line">	<span class="number">0x0033</span> <span class="number">00051</span> 	MOVQ	R8, <span class="string">&quot;&quot;</span>.a6+<span class="number">160</span>(SP)</span><br><span class="line">	<span class="number">0x003b</span> <span class="number">00059</span> 	MOVQ	R9, <span class="string">&quot;&quot;</span>.a7+<span class="number">168</span>(SP)</span><br><span class="line">	<span class="number">0x0043</span> <span class="number">00067</span> 	MOVQ	R10, <span class="string">&quot;&quot;</span>.a8+<span class="number">176</span>(SP)</span><br><span class="line">	<span class="number">0x004b</span> <span class="number">00075</span> 	MOVQ	R11, <span class="string">&quot;&quot;</span>.a9+<span class="number">184</span>(SP)</span><br><span class="line">	<span class="number">0x0053</span> <span class="number">00083</span> 	MOVQ	$<span class="number">0</span>, <span class="string">&quot;&quot;</span>.r1+<span class="number">64</span>(SP)</span><br><span class="line">	<span class="number">0x005c</span> <span class="number">00092</span> 	MOVQ	$<span class="number">0</span>, <span class="string">&quot;&quot;</span>.r2+<span class="number">56</span>(SP)</span><br><span class="line">	<span class="number">0x0065</span> <span class="number">00101</span> 	MOVQ	$<span class="number">0</span>, <span class="string">&quot;&quot;</span>.r3+<span class="number">48</span>(SP)</span><br><span class="line">	<span class="number">0x006e</span> <span class="number">00110</span> 	MOVQ	$<span class="number">0</span>, <span class="string">&quot;&quot;</span>.r4+<span class="number">40</span>(SP)</span><br><span class="line">	<span class="number">0x0077</span> <span class="number">00119</span> 	MOVQ	$<span class="number">0</span>, <span class="string">&quot;&quot;</span>.r5+<span class="number">32</span>(SP)</span><br><span class="line">	<span class="number">0x0080</span> <span class="number">00128</span> 	MOVQ	$<span class="number">0</span>, <span class="string">&quot;&quot;</span>.r6+<span class="number">24</span>(SP)</span><br><span class="line">	<span class="number">0x0089</span> <span class="number">00137</span> 	MOVQ	$<span class="number">0</span>, <span class="string">&quot;&quot;</span>.r7+<span class="number">16</span>(SP)</span><br><span class="line">	<span class="number">0x0092</span> <span class="number">00146</span> 	MOVQ	$<span class="number">0</span>, <span class="string">&quot;&quot;</span>.r8+<span class="number">8</span>(SP)</span><br><span class="line">	<span class="number">0x009b</span> <span class="number">00155</span> 	MOVQ	$<span class="number">0</span>, <span class="string">&quot;&quot;</span>.r9(SP)</span><br><span class="line">	<span class="number">0x00a3</span> <span class="number">00163</span> 	MOVQ	$<span class="number">0</span>, <span class="string">&quot;&quot;</span>.r10+<span class="number">104</span>(SP)</span><br><span class="line">	<span class="number">0x00ac</span> <span class="number">00172</span> 	MOVQ	$<span class="number">0</span>, <span class="string">&quot;&quot;</span>.r11+<span class="number">112</span>(SP)</span><br><span class="line">	<span class="number">0x00b5</span> <span class="number">00181</span> 	MOVQ	<span class="string">&quot;&quot;</span>.a1+<span class="number">120</span>(SP), DX</span><br><span class="line">	<span class="number">0x00ba</span> <span class="number">00186</span> 	INCQ	DX</span><br><span class="line">	<span class="number">0x00bd</span> <span class="number">00189</span> 	MOVQ	DX, <span class="string">&quot;&quot;</span>.r1+<span class="number">64</span>(SP)</span><br><span class="line">	<span class="number">0x00c2</span> <span class="number">00194</span> 	MOVQ	<span class="string">&quot;&quot;</span>.a2+<span class="number">128</span>(SP), DX</span><br><span class="line">	<span class="number">0x00ca</span> <span class="number">00202</span> 	ADDQ	$<span class="number">2</span>, DX</span><br><span class="line">	<span class="number">0x00ce</span> <span class="number">00206</span> 	MOVQ	DX, <span class="string">&quot;&quot;</span>.r2+<span class="number">56</span>(SP)</span><br><span class="line">	<span class="number">0x00d3</span> <span class="number">00211</span> 	MOVQ	<span class="string">&quot;&quot;</span>.a3+<span class="number">136</span>(SP), DX</span><br><span class="line">	<span class="number">0x00db</span> <span class="number">00219</span> 	ADDQ	$<span class="number">3</span>, DX</span><br><span class="line">	<span class="number">0x00df</span> <span class="number">00223</span> 	MOVQ	DX, <span class="string">&quot;&quot;</span>.r3+<span class="number">48</span>(SP)</span><br><span class="line">	<span class="number">0x00e4</span> <span class="number">00228</span> 	MOVQ	<span class="string">&quot;&quot;</span>.a4+<span class="number">144</span>(SP), DX</span><br><span class="line">	<span class="number">0x00ec</span> <span class="number">00236</span> 	ADDQ	$<span class="number">4</span>, DX</span><br><span class="line">	<span class="number">0x00f0</span> <span class="number">00240</span> 	MOVQ	DX, <span class="string">&quot;&quot;</span>.r4+<span class="number">40</span>(SP)</span><br><span class="line">	<span class="number">0x00f5</span> <span class="number">00245</span> 	MOVQ	<span class="string">&quot;&quot;</span>.a5+<span class="number">152</span>(SP), DX</span><br><span class="line">	<span class="number">0x00fd</span> <span class="number">00253</span> 	ADDQ	$<span class="number">5</span>, DX</span><br><span class="line">	<span class="number">0x0101</span> <span class="number">00257</span> 	MOVQ	DX, <span class="string">&quot;&quot;</span>.r5+<span class="number">32</span>(SP)</span><br><span class="line">	<span class="number">0x0106</span> <span class="number">00262</span> 	MOVQ	<span class="string">&quot;&quot;</span>.a6+<span class="number">160</span>(SP), DX</span><br><span class="line">	<span class="number">0x010e</span> <span class="number">00270</span> 	ADDQ	$<span class="number">6</span>, DX</span><br><span class="line">	<span class="number">0x0112</span> <span class="number">00274</span> 	MOVQ	DX, <span class="string">&quot;&quot;</span>.r6+<span class="number">24</span>(SP)</span><br><span class="line">	<span class="number">0x0117</span> <span class="number">00279</span> 	MOVQ	<span class="string">&quot;&quot;</span>.a7+<span class="number">168</span>(SP), DX</span><br><span class="line">	<span class="number">0x011f</span> <span class="number">00287</span> 	ADDQ	$<span class="number">7</span>, DX</span><br><span class="line">	<span class="number">0x0123</span> <span class="number">00291</span> 	MOVQ	DX, <span class="string">&quot;&quot;</span>.r7+<span class="number">16</span>(SP)</span><br><span class="line">	<span class="number">0x0128</span> <span class="number">00296</span> 	MOVQ	<span class="string">&quot;&quot;</span>.a8+<span class="number">176</span>(SP), DX</span><br><span class="line">	<span class="number">0x0130</span> <span class="number">00304</span> 	ADDQ	$<span class="number">8</span>, DX</span><br><span class="line">	<span class="number">0x0134</span> <span class="number">00308</span> 	MOVQ	DX, <span class="string">&quot;&quot;</span>.r8+<span class="number">8</span>(SP)</span><br><span class="line">	<span class="number">0x0139</span> <span class="number">00313</span> 	MOVQ	<span class="string">&quot;&quot;</span>.a9+<span class="number">184</span>(SP), DX</span><br><span class="line">	<span class="number">0x0141</span> <span class="number">00321</span> 	ADDQ	$<span class="number">9</span>, DX</span><br><span class="line">	<span class="number">0x0145</span> <span class="number">00325</span> 	MOVQ	DX, <span class="string">&quot;&quot;</span>.r9(SP)</span><br><span class="line">	<span class="number">0x0149</span> <span class="number">00329</span> 	MOVQ	<span class="string">&quot;&quot;</span>.a10+<span class="number">88</span>(SP), DX   # 这里使用栈传递a10</span><br><span class="line">	<span class="number">0x014e</span> <span class="number">00334</span> 	ADDQ	$<span class="number">10</span>, DX</span><br><span class="line">	<span class="number">0x0152</span> <span class="number">00338</span> 	MOVQ	DX, <span class="string">&quot;&quot;</span>.r10+<span class="number">104</span>(SP)</span><br><span class="line">	<span class="number">0x0157</span> <span class="number">00343</span> 	MOVQ	<span class="string">&quot;&quot;</span>.a11+<span class="number">96</span>(SP), DX</span><br><span class="line">	<span class="number">0x015c</span> <span class="number">00348</span> 	ADDQ	$<span class="number">11</span>, DX</span><br><span class="line">	<span class="number">0x0160</span> <span class="number">00352</span> 	MOVQ	DX, <span class="string">&quot;&quot;</span>.r11+<span class="number">112</span>(SP)  # 这里使用栈传递 a11</span><br><span class="line">	<span class="number">0x0165</span> <span class="number">00357</span> 	MOVQ	<span class="string">&quot;&quot;</span>.r1+<span class="number">64</span>(SP), AX    # 注意这里返回参数的寄存器</span><br><span class="line">	<span class="number">0x016a</span> <span class="number">00362</span> 	MOVQ	<span class="string">&quot;&quot;</span>.r2+<span class="number">56</span>(SP), BX</span><br><span class="line">	<span class="number">0x016f</span> <span class="number">00367</span> 	MOVQ	<span class="string">&quot;&quot;</span>.r3+<span class="number">48</span>(SP), CX</span><br><span class="line">	<span class="number">0x0174</span> <span class="number">00372</span> 	MOVQ	<span class="string">&quot;&quot;</span>.r4+<span class="number">40</span>(SP), DI</span><br><span class="line">	<span class="number">0x0179</span> <span class="number">00377</span> 	MOVQ	<span class="string">&quot;&quot;</span>.r5+<span class="number">32</span>(SP), SI</span><br><span class="line">	<span class="number">0x017e</span> <span class="number">00382</span> 	MOVQ	<span class="string">&quot;&quot;</span>.r6+<span class="number">24</span>(SP), R8</span><br><span class="line">	<span class="number">0x0183</span> <span class="number">00387</span> 	MOVQ	<span class="string">&quot;&quot;</span>.r7+<span class="number">16</span>(SP), R9</span><br><span class="line">	<span class="number">0x0188</span> <span class="number">00392</span> 	MOVQ	<span class="string">&quot;&quot;</span>.r8+<span class="number">8</span>(SP), R10</span><br><span class="line">	<span class="number">0x018d</span> <span class="number">00397</span> 	MOVQ	<span class="string">&quot;&quot;</span>.r9(SP), R11</span><br><span class="line">	<span class="number">0x0191</span> <span class="number">00401</span> 	MOVQ	<span class="number">72</span>(SP), BP</span><br><span class="line">	<span class="number">0x0196</span> <span class="number">00406</span> 	ADDQ	$<span class="number">80</span>, SP</span><br><span class="line">	<span class="number">0x019a</span> <span class="number">00410</span> 	RET</span><br></pre></td></tr></table></figure>

<p>从上面的<code>plan9</code>可以看出来，函数入参和返回值确实是使用寄存器传递的，且寄存器信息是一致的。实际上到这里就足够了。但是笔者还需要确定下使用的寄存器名称并进行验证，因为这些参数是在做<code>ebpf</code>逻辑处理的时候使用的。</p>
<h1 id="使用ebpf获取入参并输出"><a href="#使用ebpf获取入参并输出" class="headerlink" title="使用ebpf获取入参并输出"></a>使用ebpf获取入参并输出</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这里表述下依据plan9寄存器符号推测的实际寄存器名称：</span><br><span class="line">#define GO_PARAM1(x) ((x)-&gt;rax)</span><br><span class="line">#define GO_PARAM2(x) ((x)-&gt;rbx)</span><br><span class="line">#define GO_PARAM3(x) ((x)-&gt;rcx)</span><br><span class="line">#define GO_PARAM4(x) ((x)-&gt;rdi)</span><br><span class="line">#define GO_PARAM5(x) ((x)-&gt;rsi)</span><br><span class="line">#define GO_PARAM6(x) ((x)-&gt;r8)</span><br><span class="line">#define GO_PARAM7(x) ((x)-&gt;r9)</span><br><span class="line">#define GO_PARAM8(x) ((x)-&gt;r10)</span><br><span class="line">#define GO_PARAM9(x) ((x)-&gt;r11)</span><br><span class="line"></span><br><span class="line">struct event &#123;</span><br><span class="line">    u32 pid;</span><br><span class="line">    u8 comm[64];</span><br><span class="line"></span><br><span class="line">    // args</span><br><span class="line">    u64 arg0;</span><br><span class="line">    u64 arg1;</span><br><span class="line">    u64 arg2;</span><br><span class="line">    u64 arg3;</span><br><span class="line">    u64 arg4;</span><br><span class="line">    u64 arg5;</span><br><span class="line">    u64 arg6;</span><br><span class="line">    u64 arg7;</span><br><span class="line">    u64 arg8;</span><br><span class="line">    u64 arg9;</span><br><span class="line">    u64 arg10;</span><br><span class="line">&#125;;</span><br><span class="line">SEC(&quot;uprobe/main.longArgs&quot;)</span><br><span class="line">int uprobe__main_long_args(struct pt_regs *ctx) &#123;</span><br><span class="line">    struct event args=&#123;&#125;;</span><br><span class="line">    args.pid = bpf_get_current_pid_tgid();</span><br><span class="line">    bpf_get_current_comm(&amp;args.comm, sizeof(args.comm));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // read args 0-8，从寄存器中获取</span><br><span class="line">    args.arg0 = GO_PARAM1(ctx);</span><br><span class="line">    args.arg1 = GO_PARAM2(ctx);</span><br><span class="line">    args.arg2 = GO_PARAM3(ctx);</span><br><span class="line">    args.arg3 = GO_PARAM4(ctx);</span><br><span class="line">    args.arg4 = GO_PARAM5(ctx);</span><br><span class="line">    args.arg5 = GO_PARAM6(ctx);</span><br><span class="line">    args.arg6 = GO_PARAM7(ctx);</span><br><span class="line">    args.arg7 = GO_PARAM8(ctx);</span><br><span class="line">    args.arg8 = GO_PARAM9(ctx);</span><br><span class="line">    </span><br><span class="line">    // read args 9-10，从栈上获取</span><br><span class="line">    bpf_probe_read(&amp;args.arg9, sizeof(args.arg9), (void*)(PT_REGS_SP(ctx))+8);</span><br><span class="line">    bpf_probe_read(&amp;args.arg10, sizeof(args.arg10), (void*)(PT_REGS_SP(ctx))+16);</span><br><span class="line"></span><br><span class="line">    bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;args, sizeof(args));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译完成后，启动这部分<code>ebpf</code>监听任务：</p>
<pre><code># 启动监听
./go_18 -bin_path ./arg/arg -uprobe main.longArgs
2023/03/03 22:07:32 Listening for events..
# 触发 ./arg/arg 执行
2023/03/03 22:07:46 pid: 756309, comm: arg
2023/03/03 22:07:46 /home/odin/pdliyan/blog/go_18/arg/arg: main.longArgs  value: &#123;Pid:756309 Comm:[97 114 103 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] _:[0 0 0 0] Arg0:1 Arg1:2 Arg2:3 Arg3:4 Arg4:5 Arg5:6 Arg6:7 Arg7:8 Arg8:9 Arg9:10 Arg10:11&#125;
# 请注意这里的参数是和我们的代码一致的。
2023/03/03 22:07:46 event info: &#123;Pid:756309 Comm:[97 114 103 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] _:[0 0 0 0] Arg0:1 Arg1:2 Arg2:3 Arg3:4 Arg4:5 Arg5:6 Arg6:7 Arg7:8 Arg8:9 Arg9:10 Arg10:11&#125;
# 退出
2023/03/03 22:08:38 Received signal, exiting program...
</code></pre>
<p>从上面的输出可以确定<code>plan9</code>的寄存器符号和实际寄存器的对应关系是正确的。  </p>
<p>以上就验证了困扰笔者的<code>go-17+</code>参数调用规约的问题。可以看到，依旧十分的奇葩。<br>周末愉快。</p>
]]></content>
      <categories>
        <category>ebpf</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>go-1.17</tag>
      </tags>
  </entry>
  <entry>
    <title>go-simplejson 插入数组</title>
    <url>/2021/07/22/cljb83dm2001pkcs62kxb4xe6/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://github.com/bitly/go-simplejson">go-simplejson</a>是go lang语言中操作json非常方便的开源库。最近使用simplejson进行数据插入操作时遇到了问题，经过排查后最终解决。现记录如下。</p>
</blockquote>
<span id="more"></span>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建了一个json对象J，需要从其他地方获取剩余json信息后，插入到J中的data字段中。初始版本如下：</span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">	simplejson &quot;github.com/bitly/go-simplejson&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	js, _ := simplejson.NewJson([]byte(`</span><br><span class="line">&#123;</span><br><span class="line">&quot;errno&quot;: 0,</span><br><span class="line">&quot;errmsg&quot;: &quot;test&quot;</span><br><span class="line">&#125;`))</span><br><span class="line"></span><br><span class="line">	var js_2 = new(simplejson.Json)</span><br><span class="line">	*js_2 = *js</span><br><span class="line">	jsArr := []*simplejson.Json&#123;&#125;</span><br><span class="line">	js1, _ := simplejson.NewJson([]byte(`&#123;&quot;num&quot;: 1&#125;`))</span><br><span class="line">	js2, _ := simplejson.NewJson([]byte(`&#123;&quot;num&quot;: 2&#125;`))</span><br><span class="line">	jsArr = append(jsArr, js1)</span><br><span class="line">	jsArr = append(jsArr, js2)</span><br><span class="line">	js.Set(&quot;data&quot;, jsArr)</span><br><span class="line">	js.Get(&quot;data&quot;).GetIndex(0).Set(&quot;test&quot;, 1)</span><br><span class="line">	jsB, _ := js.MarshalJSON()</span><br><span class="line">	fmt.Println(string(jsB)) </span><br><span class="line">&#125;</span><br><span class="line">// % go run js_check.go</span><br><span class="line">// &#123;&quot;data&quot;:[&#123;&quot;num&quot;:1&#125;,&#123;&quot;num&quot;:2&#125;],&quot;errmsg&quot;:&quot;test&quot;,&quot;errno&quot;:0&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h1><p>经过<code>dlv</code>逐行调试，实际问题出在<code>js.Get(&quot;data&quot;).GetIndex(0).Set(&quot;test&quot;, 1)</code>中。跳转至定义，该操作实际做如下转换:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr, ok := js.Get(&quot;data&quot;).data.([]interface&#123;&#125;)</span><br><span class="line">if ok &#123;</span><br><span class="line">    &amp;simplejson.Json(arr[index]).Set(&quot;test&quot;, 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里由于<code>jsArr</code>是<code>[]*simplejson.Json</code>，类型断言为<code>[]interface&#123;&#125;</code>失败。所以无法正常设置值。查看<code>simplejson.go</code>，其中的<code>Json</code>对象结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Json struct &#123;</span><br><span class="line">    data interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实可以通过<code>js.Interface()</code>获取其中的真实数据。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>变更为如下代码即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">	simplejson &quot;github.com/bitly/go-simplejson&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	js, _ := simplejson.NewJson([]byte(`</span><br><span class="line">&#123;</span><br><span class="line">&quot;errno&quot;: 0,</span><br><span class="line">&quot;errmsg&quot;: &quot;test&quot;</span><br><span class="line">&#125;`))</span><br><span class="line"></span><br><span class="line">	var js_2 = new(simplejson.Json)</span><br><span class="line">	*js_2 = *js</span><br><span class="line">	jsArr := []interface&#123;&#125;&#123;&#125;</span><br><span class="line">	js1, _ := simplejson.NewJson([]byte(`&#123;&quot;num&quot;: 1&#125;`))</span><br><span class="line">	js2, _ := simplejson.NewJson([]byte(`&#123;&quot;num&quot;: 2&#125;`))</span><br><span class="line">	jsArr = append(jsArr, js1.Interface())</span><br><span class="line">	jsArr = append(jsArr, js2.Interface())</span><br><span class="line">	js.Set(&quot;data&quot;, jsArr)</span><br><span class="line">	js.Get(&quot;data&quot;).GetIndex(0).Set(&quot;test&quot;, 1)</span><br><span class="line">	jsB, _ := js.MarshalJSON()</span><br><span class="line">	fmt.Println(string(jsB))</span><br><span class="line">&#125;</span><br><span class="line">// % go run js_check.go</span><br><span class="line">// &#123;&quot;data&quot;:[&#123;&quot;num&quot;:1,&quot;test&quot;:1&#125;,&#123;&quot;num&quot;:2&#125;],&quot;errmsg&quot;:&quot;test&quot;,&quot;errno&quot;:0&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>simplejson</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 封装</title>
    <url>/2021/04/08/cljb83dm4001ukcs6fs72fq91/</url>
    <content><![CDATA[<blockquote>
<p>golang作为一种高级语言，实现了面向对象语言的封装、继承、多态的特性。本文简要介绍下golang面向对象的这些特性。</p>
</blockquote>
<span id="more"></span>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h2><p><code>Golang</code>采用首字母大小写的方式控制访问权限。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// lib/pub.go</span><br><span class="line">package learn</span><br><span class="line"></span><br><span class="line">type A struct&#123;  // 定义对象</span><br><span class="line">    private int</span><br><span class="line">    Public  string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewA(private int, public string) A&#123;</span><br><span class="line">    return A&#123;private: private, Public: public&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a A) PrintInf()&#123; // 可通过a.PrintInf() 访问该函数</span><br><span class="line">	print(a.private, a.Public)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    private = 1</span><br><span class="line">    Public = &quot;aa&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// main.go</span><br><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;go_learn/lib&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    a := learn.NewA(1, &quot;aa&quot;)</span><br><span class="line">    print(a.Public, a.private) // a.private不可包外访问，编译报错</span><br><span class="line"></span><br><span class="line">    print(learn.private, learn.Public) // learn.private不可包外访问，编译报错</span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>和 <code>C++/Java/Python</code>等常见的面向对象语言不同，<code>Golang</code>的结构体中不支持函数的定义。某个结构体的函数，可以通过函数名前的归属生命来表示。</p>
<h2 id="访问结构体私有成员"><a href="#访问结构体私有成员" class="headerlink" title="访问结构体私有成员"></a>访问结构体私有成员</h2><p>这是个很有意思的话题。<code>C++</code>和<code>Python</code>都是有方法可以越过结构体的访问限制的，<code>Golang</code>通过<code>unsafe.Pointer</code>类型的转换也可以达到相同的目的。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// learn/pub.go</span><br><span class="line">package learn</span><br><span class="line"></span><br><span class="line">type A struct&#123;</span><br><span class="line">    private int</span><br><span class="line">    Public  string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a A) PrintInf()&#123;</span><br><span class="line">    print(a.private, a.Public)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewA(private int, public string) A&#123;</span><br><span class="line">    return A&#123;private: private, Public: public&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    private = 1</span><br><span class="line">    Public = &quot;aa&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// main.go</span><br><span class="line">/* 测试golang封装、继承、多态特性</span><br><span class="line"> */</span><br><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;unsafe&quot;</span><br><span class="line"></span><br><span class="line">    &quot;go_learn/lib&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type AA struct&#123;</span><br><span class="line">    Private int</span><br><span class="line">    Public  string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    a := learn.NewA(1, &quot;aa&quot;)</span><br><span class="line">    //print(a.Public, a.private)</span><br><span class="line"></span><br><span class="line">    //print(learn.Public, learn.private)</span><br><span class="line">    p := unsafe.Pointer(&amp;a)</span><br><span class="line">    aa := &amp;AA&#123;&#125;</span><br><span class="line">    aa = (*AA)(p) // golang unsafe.Pointer 更加接近 C/C++中指针的用法，编译器进行的校验较少；</span><br><span class="line">    print(aa.Private, aa.Public) // 可以正常运行。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简单备注了下<code>Golang</code>封装的特性。后续再备注下继承、多态的使用吧。由于<code>Golang</code>采用鸭子式的继承检查思想，继承和多态的特性使用会相对较繁琐。</p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang proto3 使用</title>
    <url>/2022/05/19/cljb83dm5001xkcs6727y17m4/</url>
    <content><![CDATA[<blockquote>
<p>一直都比较赞赏<a href="https://developers.google.com/protocol-buffers/docs/proto3"><code>protocol buffer</code></a>。由于其表现性强、压缩比高，可以把很多结构都写到<code>proto</code>文件中，同时添加很多的注释。当需要进行进行数据存储时，使用<code>proto</code>序列化结果替代<code>json</code>，可以省去很多的冗余字段。本篇找了一些<code>golang</code>中<code>protocol buffer</code>的使用示例，以及<code>protocol</code>对象与<code>json</code>对象互相转换的示例。  </p>
</blockquote>
<span id="more"></span>

<h1 id="依赖环境"><a href="#依赖环境" class="headerlink" title="依赖环境"></a>依赖环境</h1><p>这部分主要参照<a href="https://developers.google.com/protocol-buffers/docs/gotutorial">官网教程</a>来：</p>
<ul>
<li><code>protoc</code> 安装：<br><a href="https://github.com/protocolbuffers/protobuf/releases">github-protobuf-releases</a> 下载对应平台的 <code>protoc</code> 编译器即可；</li>
<li><code>protoc-gen-go</code> 安装：<br><code>go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</code> 需要能够安装对应语言的插件，<code>proto</code> 文件才被翻译为对应语言可调用的模块； </li>
</ul>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p>比较推荐将<code>proto</code>文件单独放入一个仓库。<code>proto</code>一般定义的是需要服务/模块间共享的，所以单独放在一个仓库里便于调用及约定的维护。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── main.go</span><br><span class="line">└── proto</span><br><span class="line">    └── user.proto</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;bytes&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">	&quot;proto/message&quot;</span><br><span class="line"></span><br><span class="line">	&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">	&quot;github.com/gogo/protobuf/jsonpb&quot;</span><br><span class="line">	jsoniter &quot;github.com/json-iterator/go&quot;</span><br><span class="line">	&quot;google.golang.org/protobuf/proto&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	msg := message.UserInfo&#123;UserList: []*message.UserInfo_User&#123;&#123;Username: &quot;test&quot;&#125;&#125;&#125;</span><br><span class="line">	msg.UserList = append(msg.UserList, &amp;message.UserInfo_User&#123;Username: &quot;test1&quot;&#125;)</span><br><span class="line"></span><br><span class="line">	// go message 可以直接序列化为 json byte</span><br><span class="line">	byt, err := jsoniter.Marshal(&amp;msg)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatal(&quot;cannot parse to json&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;json result: &quot;, string(byt))</span><br><span class="line"></span><br><span class="line">	// 可以将 json 对象反序列化为 go message 对象</span><br><span class="line">	msg1 := &amp;message.UserInfo&#123;&#125;</span><br><span class="line">	err = jsonpb.Unmarshal(bytes.NewReader(byt), msg1)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatal(&quot;parse failed, &quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(&quot;parsed: %+v\n&quot;, msg1)</span><br><span class="line"></span><br><span class="line">	// protobuf 本身的字符串表征</span><br><span class="line">	msg1Str := msg1.String()</span><br><span class="line">	fmt.Println(&quot;msg1 string, &quot;, msg1Str)</span><br><span class="line">    // protobuf 序列化</span><br><span class="line">	out, err := proto.Marshal(msg1)</span><br><span class="line">	fmt.Println(&quot;msg1 marshal result is, &quot;, string(out))</span><br><span class="line">	msg2 := message.UserInfo&#123;&#125;</span><br><span class="line">    // 将序列化后的结果，反序列化为 message 对象</span><br><span class="line">	proto.Unmarshal(out, &amp;msg2)</span><br><span class="line">	fmt.Printf(&quot;unmarshal result msg2 is: %+v\n&quot;, &amp;msg2)</span><br><span class="line"></span><br><span class="line">	engine := gin.Default()</span><br><span class="line">	engine.GET(&quot;check&quot;, func(c *gin.Context) &#123;</span><br><span class="line">    	// message 对象可以直接用来作为接口的返回值</span><br><span class="line">		c.JSON(http.StatusOK, &amp;msg1)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	srv := &amp;http.Server&#123;&#125;</span><br><span class="line">	srv.Addr = &quot;0.0.0.0:9988&quot;</span><br><span class="line">	srv.Handler = engine</span><br><span class="line">	srv.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// proto/user.proto</span><br><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package user_info;</span><br><span class="line"></span><br><span class="line">// 对于 golang 的使用说，这里的 go_package 是必须的。表述的是编译后的模块名</span><br><span class="line">option go_package = &quot;./message&quot;;</span><br><span class="line"></span><br><span class="line">message UserInfo&#123;</span><br><span class="line">  message User&#123;</span><br><span class="line">    string username = 1;</span><br><span class="line">    uint32 age = 2;</span><br><span class="line">    string graduate = 3;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  repeated User user_list = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行编译:<code>protoc -I./proto user.proto --go_out=./</code>，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">├── message</span><br><span class="line">│   └── user.pb.go</span><br><span class="line">└── proto</span><br><span class="line">    └── user.proto</span><br><span class="line"></span><br><span class="line">2 directories, 5 files</span><br></pre></td></tr></table></figure>

<p>执行 <code>go run main.go</code>。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go run main.go</span><br><span class="line">json result:  &#123;&quot;user_list&quot;:[&#123;&quot;username&quot;:&quot;test&quot;&#125;,&#123;&quot;username&quot;:&quot;test1&quot;&#125;]&#125;</span><br><span class="line">parsed: user_list:&#123;username:&quot;test&quot;&#125;  user_list:&#123;username:&quot;test1&quot;&#125;</span><br><span class="line">msg1 string,  user_list:&#123;username:&quot;test&quot;&#125;  user_list:&#123;username:&quot;test1&quot;&#125;</span><br><span class="line">msg1 marshal result is,</span><br><span class="line"></span><br><span class="line">test</span><br><span class="line"></span><br><span class="line">test1</span><br><span class="line">unmarshal result msg2 is: user_list:&#123;username:&quot;test&quot;&#125;  user_list:&#123;username:&quot;test1&quot;&#125;</span><br><span class="line">[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.</span><br><span class="line"></span><br><span class="line">[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.</span><br><span class="line"> - using env:	export GIN_MODE=release</span><br><span class="line"> - using code:	gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">[GIN-debug] GET    /check_must               --&gt; main.main.func1 (3 handlers)</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>protocol buffer</code> 在大多数场景下，都能兼容<code>json</code>对象的使用场景。其劣势为序列化相关操作时额外的性能开销。对于与外部进行交互、不会进行频繁序列化、反序列化的数据，可以考虑优先使用<code>protocol buffer</code>。</p>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 常见类型字节数</title>
    <url>/2022/06/06/cljb83dm60020kcs65s24d4jd/</url>
    <content><![CDATA[<blockquote>
<p><code>ebpf</code> 分析<code>golang</code>程序时，离不开对参数大小的判断。这里列出来一些基本类型的大小，并通过汇编对应验证函数的方式来肯定判断结果。</p>
</blockquote>
<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>这里列出基本类型及其作为参数传递时，占用的空间大小如下表。  </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>长度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>指针</td>
<td>8B</td>
<td>64位机为 8Byte, 32位机位4Byte</td>
</tr>
<tr>
<td>context</td>
<td>16B</td>
<td>interface 类型。其中，前8B是类型信息，后8B是对象的指针信息</td>
</tr>
<tr>
<td>interface</td>
<td>16B</td>
<td>2 个指针，详见<a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/">draveness-go-interface</a>，或者 runtime/runtime2.go iface/eface 定义</td>
</tr>
<tr>
<td>int64</td>
<td>8B</td>
<td>-</td>
</tr>
<tr>
<td>int</td>
<td>8B</td>
<td>64位机为 8Byte, 32位机位4Byte</td>
</tr>
<tr>
<td>string</td>
<td>16B</td>
<td>8B 地址 + 8B string长度</td>
</tr>
<tr>
<td>slice</td>
<td>24B</td>
<td>8B地址 + 8B slice 成员数量 + 8B slice capability</td>
</tr>
<tr>
<td>func</td>
<td>8B</td>
<td>func 作为函数参数时，传递的是 func 的地址</td>
</tr>
</tbody></table>
<p>需要注意的是，作为函数参数传递时，golang会对参数按照 8B 进行对齐。</p>
<span id="more"></span>


<h1 id="验证示例"><a href="#验证示例" class="headerlink" title="验证示例"></a>验证示例</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;context&quot;</span><br><span class="line"></span><br><span class="line">type A struct &#123;</span><br><span class="line">	p1 int64</span><br><span class="line">	a  byte</span><br><span class="line">	b  int64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type FuncPt func(A)</span><br><span class="line"></span><br><span class="line">type InterA interface &#123;</span><br><span class="line">	Echo(A)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func CheckPointer(a *A)            &#123;&#125;</span><br><span class="line">func CheckCtx(ctx context.Context) &#123;&#125;</span><br><span class="line">func CheckInterface(inter InterA)  &#123;&#125;</span><br><span class="line">func CheckString(s string)         &#123;&#125;</span><br><span class="line">func CheckSlice(arr []string)      &#123;&#125;</span><br><span class="line">func CheckFunc(fn FuncPt)          &#123;&#125;</span><br><span class="line">func CheckAlign(a byte)            &#123;&#125;</span><br><span class="line">func CheckStruct(a A)              &#123;&#125;</span><br><span class="line">func main()                        &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对该代码进行汇编:<br><code>go build -gcflags &quot;-S&quot; . &gt; main.s</code><br>可以得到汇编后的结果，并验证上述类型所占大小的描述。这里推荐下曹大的<a href="https://xargin.com/plan9-assembly/">plan9 汇编入门</a>，里面对<code>golang</code>汇编后的<code>plan9</code>进行了介绍。由其介绍可知，汇编后函数签名后的<code>$x-y</code>指代的是该函数的栈空间以及参数大小（入参+返回参数，<code>go-1.17</code>及之后的版本未验证）。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">&quot;&quot;.CheckPointer STEXT size=16 args=0x8 locals=0x0 funcid=0x0 leaf</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:17)	TEXT	&quot;&quot;.CheckPointer(SB), LEAF|NOFRAME|ABIInternal, $0-8</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:17)	FUNCDATA	ZR, gclocals·2a5305abe05176240e61b8620e19a815(SB)</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:17)	FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:17)	RET	(R30)</span><br><span class="line">	0x0000 c0 03 5f d6 00 00 00 00 00 00 00 00 00 00 00 00  .._.............</span><br><span class="line">&quot;&quot;.CheckCtx STEXT size=16 args=0x10 locals=0x0 funcid=0x0 leaf</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:18)	TEXT	&quot;&quot;.CheckCtx(SB), LEAF|NOFRAME|ABIInternal, $0-16</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:18)	FUNCDATA	ZR, gclocals·f207267fbf96a0178e8758c6e3e0ce28(SB)</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:18)	FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:18)	RET	(R30)</span><br><span class="line">	0x0000 c0 03 5f d6 00 00 00 00 00 00 00 00 00 00 00 00  .._.............</span><br><span class="line">&quot;&quot;.CheckInterface STEXT size=16 args=0x10 locals=0x0 funcid=0x0 leaf</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:19)	TEXT	&quot;&quot;.CheckInterface(SB), LEAF|NOFRAME|ABIInternal, $0-16</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:19)	FUNCDATA	ZR, gclocals·f207267fbf96a0178e8758c6e3e0ce28(SB)</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:19)	FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:19)	RET	(R30)</span><br><span class="line">	0x0000 c0 03 5f d6 00 00 00 00 00 00 00 00 00 00 00 00  .._.............</span><br><span class="line">&quot;&quot;.CheckString STEXT size=16 args=0x10 locals=0x0 funcid=0x0 leaf</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:20)	TEXT	&quot;&quot;.CheckString(SB), LEAF|NOFRAME|ABIInternal, $0-16</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:20)	FUNCDATA	ZR, gclocals·2a5305abe05176240e61b8620e19a815(SB)</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:20)	FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:20)	RET	(R30)</span><br><span class="line">	0x0000 c0 03 5f d6 00 00 00 00 00 00 00 00 00 00 00 00  .._.............</span><br><span class="line">&quot;&quot;.CheckSlice STEXT size=16 args=0x18 locals=0x0 funcid=0x0 leaf</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:21)	TEXT	&quot;&quot;.CheckSlice(SB), LEAF|NOFRAME|ABIInternal, $0-24</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:21)	FUNCDATA	ZR, gclocals·2a5305abe05176240e61b8620e19a815(SB)</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:21)	FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:21)	RET	(R30)</span><br><span class="line">	0x0000 c0 03 5f d6 00 00 00 00 00 00 00 00 00 00 00 00  .._.............</span><br><span class="line">&quot;&quot;.CheckFunc STEXT size=16 args=0x8 locals=0x0 funcid=0x0 leaf</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:22)	TEXT	&quot;&quot;.CheckFunc(SB), LEAF|NOFRAME|ABIInternal, $0-8</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:22)	FUNCDATA	ZR, gclocals·2a5305abe05176240e61b8620e19a815(SB)</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:22)	FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:22)	RET	(R30)</span><br><span class="line">	0x0000 c0 03 5f d6 00 00 00 00 00 00 00 00 00 00 00 00  .._.............</span><br><span class="line">&quot;&quot;.CheckAlign STEXT size=16 args=0x8 locals=0x0 funcid=0x0 leaf</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:23)	TEXT	&quot;&quot;.CheckAlign(SB), LEAF|NOFRAME|ABIInternal, $0-8</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:23)	FUNCDATA	ZR, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:23)	FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:23)	RET	(R30)</span><br><span class="line">	0x0000 c0 03 5f d6 00 00 00 00 00 00 00 00 00 00 00 00  .._.............</span><br><span class="line">&quot;&quot;.CheckStruct STEXT size=16 args=0x18 locals=0x0 funcid=0x0 leaf</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:24)	TEXT	&quot;&quot;.CheckStruct(SB), LEAF|NOFRAME|ABIInternal, $0-24</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:24)	FUNCDATA	ZR, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:24)	FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:24)	RET	(R30)</span><br><span class="line">	0x0000 c0 03 5f d6 00 00 00 00 00 00 00 00 00 00 00 00  .._.............</span><br><span class="line">&quot;&quot;.main STEXT size=16 args=0x0 locals=0x0 funcid=0x0 leaf</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:26)	TEXT	&quot;&quot;.main(SB), LEAF|NOFRAME|ABIInternal, $0-0</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:26)	FUNCDATA	ZR, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:26)	FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	0x0000 00000 (/Users/liyan/zone/go_learn/param/main.go:28)	RET	(R30)</span><br><span class="line">	0x0000 c0 03 5f d6 00 00 00 00 00 00 00 00 00 00 00 00  .._.............</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>ebpf</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang GMP</title>
    <url>/2021/04/15/cljb83dm60024kcs6dsycci8n/</url>
    <content><![CDATA[<blockquote>
<p>写点东西还是难，果然还是搬运工来的轻松些。今天搬运点Golang的<code>GMP</code>模型看看。最近在准备一篇<code>Golang</code>的<code>GC</code>实践。慢慢搞吧。</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Golang</code>作为语言层面支持并发的语言，使用<code>go</code>可以让搬砖体验飞起。但是从直觉来说，事情并没有这么简单：从操作系统层面来说，进程和线程是操作系统认可的并行机制。协程以及<code>Golang</code>的所谓<em>纤程</em>是期望一堆程序员期望将操作系统的工作拿过来，以满足一些优化的效果。所以诸如<code>Python</code>的协程以及<code>Golang</code>的纤程，总是能够对应到操作系统认可的执行单元上。对于<code>Python</code>的协程还好理解一些，是严格运行在自己的线程里的，只是语言层面实现了线程内的上下文切换优化。所以对于<code>CPU</code>密集型的操作，仅使用协程是无法达到优化效果的：这种场景下<code>Python</code>会推荐多进程。相比起来，<code>Golang</code>的<code>go</code>野心更大一些：期望给用户以<code>go</code>作为接口，在语言内实现与操作系统调度单元的交互。<code>Golang</code>里实际的调度模型是<code>GMP</code>。  </p>
<span id="more"></span>
<h1 id="搬运"><a href="#搬运" class="headerlink" title="搬运"></a>搬运</h1><p>这里搬运一些文章，介绍<code>GMP</code>。<br><a href="https://learnku.com/articles/41728">[典藏版] Golang 调度器 GMP 原理与调度全分析</a> 从单进程开始介绍，后面的调试部分能学到一些东西<br><a href="https://juejin.cn/post/6844904034449489933">Go语言学习 - GMP模型</a> <code>G</code>调度这块说的比较详细，可以看看<br><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/">6.5 调度器 #</a> 日常膜拜  </p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ul>
<li><code>goroutine</code>还是运行在一个进程里的。多线程想对比多进程，稳定性上会差一些：如果线程内出现了coredump等异常，整个进程可能就退出了。所以<code>goroutine</code>运行在一个进程内，会不会一个<code>g</code>出现了crash，整个程序崩溃？</li>
<li><code>Python</code>的进程及线程，解释器层面分别使用了<code>C</code>的<code>fork</code>以及<code>pthread</code>(Linux)进行实现。<code>g</code>的实现是怎么样的。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>http及websocket性能对比</title>
    <url>/2021/07/15/cljb83dm70026kcs68h1o4glg/</url>
    <content><![CDATA[<blockquote>
<p>从过往的经历中来看，使用websocket作为http协议的替代似乎是一种潮流。websocket以其小包头、全双工的优势，弥补了http协议的性能上的缺陷。对于长链接需求，完全可以在初始化时创建websocket连接，在业务交互时直接进行通信，使得通信过程更加流畅。相信在基于Quic的http3协议走向成熟应用前，websocket在性能上都具有优势。本文以golang语言为基础，构造场景进行两种协议的性能对比。</p>
</blockquote>
<span id="more"></span>

<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>在服务端分别启动了<code>http</code>服务及<code>websocket</code>服务，返回所接受到的信息。构造<code>BenchmarkHttp</code>、<code>BenchmarkWS</code>进行请求，发送递增字符串。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// server.go</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">	golang中使用的是http1.1协议，默认为长链接。仅第一次发送请求时进行握手。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;flag&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;io&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line"></span><br><span class="line">	&quot;github.com/gorilla/websocket&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var ws_addr = flag.String(&quot;ws_addr&quot;, &quot;localhost:9080&quot;, &quot;websocket http service address&quot;)</span><br><span class="line">var http_addr = flag.String(&quot;http_addr&quot;, &quot;localhost:9090&quot;, &quot;http address address&quot;)</span><br><span class="line"></span><br><span class="line">var upgrader = websocket.Upgrader&#123;&#125; // use default options</span><br><span class="line"></span><br><span class="line">func ws_echo(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	c, err := upgrader.Upgrade(w, r, nil)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Print(&quot;upgrade:&quot;, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	defer c.Close()</span><br><span class="line">	for &#123;</span><br><span class="line">		mt, message, err := c.ReadMessage()</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			log.Println(&quot;read:&quot;, err)</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">		log.Printf(&quot;recv: %s&quot;, message)</span><br><span class="line">		err = c.WriteMessage(mt, message)</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			log.Println(&quot;write:&quot;, err)</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func http_echo(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">	req.ParseForm()</span><br><span class="line">	echo_data := req.Form.Get(&quot;echo&quot;)</span><br><span class="line">	fmt.Println(echo_data)</span><br><span class="line">	io.WriteString(w, echo_data)</span><br><span class="line">	return</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func start_websocket() &#123;</span><br><span class="line">	http.HandleFunc(&quot;/ws_echo&quot;, ws_echo)</span><br><span class="line">	log.Fatal(http.ListenAndServe(*ws_addr, nil))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func start_http() &#123;</span><br><span class="line">	http.HandleFunc(&quot;/http_echo&quot;, http_echo)</span><br><span class="line">	log.Fatal(http.ListenAndServe(*http_addr, nil))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	log.SetFlags(0)</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(2)</span><br><span class="line">	go start_websocket()</span><br><span class="line">	go start_http()</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// web_test.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;io/ioutil&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">	&quot;net/url&quot;</span><br><span class="line">	&quot;strconv&quot;</span><br><span class="line">	&quot;testing&quot;</span><br><span class="line"></span><br><span class="line">	&quot;github.com/gorilla/websocket&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func BenchmarkHttp(b *testing.B) &#123;</span><br><span class="line">	client := &amp;http.Client&#123;&#125;</span><br><span class="line">	for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">		i_str := strconv.Itoa(i)</span><br><span class="line">		req, err := http.NewRequest(http.MethodGet, &quot;http://localhost:9090/http_echo?echo=&quot;+i_str, nil)</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			fmt.Println(&quot;create new request failed&quot;, err.Error())</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		//b.ResetTimer()</span><br><span class="line">		resp, err := client.Do(req)</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			fmt.Println(&quot;got http request error&quot;, err.Error())</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		_, _ = ioutil.ReadAll(resp.Body)</span><br><span class="line">		//fmt.Println(string(body))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkWs(b *testing.B) &#123;</span><br><span class="line">	addr := &quot;localhost:9080&quot;</span><br><span class="line">	u := url.URL&#123;Scheme: &quot;ws&quot;, Host: addr, Path: &quot;/ws_echo&quot;&#125;</span><br><span class="line">	c, _, err := websocket.DefaultDialer.Dial(u.String(), nil)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;Error, create websocket connect failed&quot;)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">		err = c.WriteMessage(websocket.TextMessage, []byte(strconv.Itoa(i)))</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			fmt.Println(&quot;write ws message failed, &quot;, err.Error())</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		_, message, err := c.ReadMessage()</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			fmt.Println(&quot;Error, recv message failed&quot;)</span><br><span class="line">			fmt.Println(string(message))</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		//fmt.Println(string(message))</span><br><span class="line">	&#125;</span><br><span class="line">	err = c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, &quot;&quot;))</span><br><span class="line">	c.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go test -bench=. -benchtime=3s -run=none</span><br><span class="line">BenchmarkHttp-8   	   57764	     62737 ns/op</span><br><span class="line">BenchmarkWs-8     	  101538	     36740 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok  	web_perf	8.850s</span><br></pre></td></tr></table></figure>
<p>从结果中可以直观的看到，<code>websocket</code>协议有明显的性能优势。</p>
<h1 id="问题结论"><a href="#问题结论" class="headerlink" title="问题结论"></a>问题结论</h1><p>上次提出了两个问题，后来经过测试，有了结论。这里贴一下。</p>
<ul>
<li>单个goroutine 崩溃时，该进程内其他的goroutine也会崩溃。通常的做法是使用一层wrapper，进行recover获取及现场、日志等保存；</li>
<li>golang中线程的实现，runtime中，初始化时会申请内核态线程；见<code>runtime/proc.go</code>；</li>
</ul>
<h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><ul>
<li>http1.0, http1.1, http2.0, http3.0, websocket, quic协议的介绍；</li>
<li>rpc调用与websocket通信之间的网络延时对比；</li>
</ul>
<h1 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247484725&idx=1&sn=63941cdb8ba8961457ae7667eed84448&scene=21#wechat_redirect">net/http长链接&amp;连接池使用时的超时陷阱</a><br><a href="https://blog.csdn.net/qq_39898645/article/details/109181736">换电脑后，hexo-next 窝火的报错</a><br><a href="https://blog.csdn.net/diaosssss/article/details/92830934">golang调度器初始化</a></p>
]]></content>
  </entry>
  <entry>
    <title>golang常见类型作为参数的eBPF解析</title>
    <url>/2022/12/30/cljb83dm8002akcs6gzk6axk0/</url>
    <content><![CDATA[<blockquote>
<p>即将过去的2022年，笔者相当比例的精力都投入在了eBPF上。最初的时候，写了一篇<a href="https://liyan-ah.github.io/2022/06/06/golang-%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E5%AD%97%E8%8A%82%E6%95%B0/">golang 常见类型字节数
</a>，开启了<code>eBPF+golang</code>的总结性工作。此后陆续整理了一些关于<code>ebpf</code>的使用文章，同时项目也在逐步的推进。<code>eBPF</code>的实际落地有很大的挑战，但是最终还是找到了一些落地的场景。年底了，结合最近的调研工作，笔者整理了这篇文章。既算是对之前文章的呼应，也是对今年整理内容的总结。  </p>
</blockquote>
<p><code>eBPF</code>能够提供一种切入服务细节的独特视角。本文即通过实例，对<code>golang</code>常见类型作为函数参数时进行解析，期望读者能够感受这一视角。需要说明的是，本文是基于<code>golang-1.16</code>来整理的。</p>
<span id="more"></span>

<h1 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h1><p>目前<code>golang</code>支持的数值类型大概有<code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>及相对应的无符号类型。无符号类型在传递时和对应的有符号类型是一致的，这里不再赘述。<code>int</code>在不同平台上大小会不同，<code>64</code>位操作系统时，<code>sizeof(int)=sizeof(int64)</code>。作为参数传递时，数值类型会直接传递值。<br>一般来说，<code>int8</code>, <code>int16</code>, <code>int32</code>在作为参数传递时，基于内存对齐的原则，会使用<code>8B</code>的空间来传递。但是并不绝对，笔者在准备本篇文章时，就找到了这样的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// type/main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">// 如果严格按照&quot;内存对齐&quot;来推算，int_p 的参数大小应为 8B*5</span><br><span class="line">//go:noinline</span><br><span class="line">func int_p(a int8, b int16, c int32, d int64, e int) &#123;</span><br><span class="line">	fmt.Println(a, b, c, d, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	int_p(1, 2, 3, 4, 5)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">从输出结果来看，int_p 参数列表带大小为 3*8B，其中第一个 8B 的分布为：</span><br><span class="line"> |int8|--|int16|int32|</span><br><span class="line"> | 1B |1B| 2B  | 4B  |</span><br><span class="line"> type/type.bt</span><br><span class="line">*/</span><br><span class="line">uprobe:./type:&quot;main.int_p&quot;</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;int8:  %d\n&quot;, (int8)(sarg0));</span><br><span class="line">    printf(&quot;int16: %d\n&quot;, (int16)(sarg0&gt;&gt;16));</span><br><span class="line">    printf(&quot;int32: %d\n&quot;, (int32)(sarg0&gt;&gt;32));</span><br><span class="line">    printf(&quot;int64: %d\n&quot;, sarg1);</span><br><span class="line">    printf(&quot;int:   %d\n&quot;, sarg2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 运行结果</span><br><span class="line">Attaching 1 probe...</span><br><span class="line">int8:  1</span><br><span class="line">int16: 2</span><br><span class="line">int32: 3</span><br><span class="line">int64: 4</span><br><span class="line">int:   5</span><br></pre></td></tr></table></figure>

<p>由此可知，当数值类型作为函数参数时，需要结合前后参数来判断是否触发了内存对齐，进而判断数值类型参数的具体位置。</p>
<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p><code>string</code>是由<code>8B addr + 8B length</code>来描述的。作为函数参数传递时，亦通过这样的方式来解析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// type/main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func string_p(name string) &#123;</span><br><span class="line">	fmt.Println(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	name := string(&quot;didi&quot;)</span><br><span class="line">	string_p(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// type/type.bt</span><br><span class="line">uprobe:./type:&quot;main.string_p&quot;</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;addr:   %d\n&quot;, sarg0);</span><br><span class="line">    printf(&quot;length: %d\n&quot;, sarg1);</span><br><span class="line">    printf(&quot;name:   %s\n&quot;, str(sarg0, sarg1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bpftrace ./type.bt</span><br><span class="line">Attaching 1 probe...</span><br><span class="line">addr:   4958864        // 所谓的地址，就是这么个东西 @V@</span><br><span class="line">length: 4</span><br><span class="line">name:   didi</span><br></pre></td></tr></table></figure>

<p>由于<code>string</code>的地址和长度都是<code>8B</code>，所以不会触发内存对齐。</p>
<h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><p><code>slice</code>是由<code>8B addr + 8B length + 8B cap</code>来描述的。作为函数值来传递时，需要关注地址及长度，以防止出现过解析的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// type/main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func slice_p(slices []int64) &#123;</span><br><span class="line">	fmt.Println(slices)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	slices := []int64&#123;1, 2, 3&#125;</span><br><span class="line">	slice_p(slices)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// type/type.bt</span><br><span class="line">uprobe:./type:&quot;main.slice_p&quot;</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;addr:   %d\n&quot;, sarg0);</span><br><span class="line">    printf(&quot;length: %d\n&quot;, sarg1);</span><br><span class="line">    printf(&quot;cap:    %d\n&quot;, sarg2);</span><br><span class="line"></span><br><span class="line">    $pos = 0;</span><br><span class="line">    $offset = 0;</span><br><span class="line">    unroll(10)&#123;</span><br><span class="line">        if ($pos &gt;= sarg1)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        $value = *(int64*)(sarg0+$offset);</span><br><span class="line">        printf(&quot;%d: %d\n&quot;, $pos, $value);</span><br><span class="line"></span><br><span class="line">        $offset = $offset+8;</span><br><span class="line">        $pos = $pos + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bpftrace ./type.bt</span><br><span class="line">Attaching 1 probe...</span><br><span class="line">addr:   1310720</span><br><span class="line">length: 3</span><br><span class="line">cap:    3</span><br><span class="line">0: 1</span><br><span class="line">1: 2</span><br><span class="line">2: 3</span><br></pre></td></tr></table></figure>

<p>由于<code>eBPF</code>对循环的长度是有限制的，所以通过循环来读取数据会麻烦。一般可以直接将所有的数据都读出来，记录长度并将其传递到用户空间处理。</p>
<h1 id="定长数组"><a href="#定长数组" class="headerlink" title="定长数组"></a>定长数组</h1><p><code>golang</code>的定长数组在传递时，会直接将数据拷贝上去。所以一般是不建议使用定长数组作为函数参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// type/main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func array_p(slices [4]int64) &#123;</span><br><span class="line">	fmt.Println(slices)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	arrays := [4]int64&#123;1, 2, 3, 4&#125;</span><br><span class="line">	array_p(arrays)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// type/type.bt</span><br><span class="line">uprobe:./type:&quot;main.array_p&quot;</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;arr[0]: %d\n&quot;, sarg0);</span><br><span class="line">    printf(&quot;arr[1]: %d\n&quot;, sarg1);</span><br><span class="line">    printf(&quot;arr[2]: %d\n&quot;, sarg2);</span><br><span class="line">    printf(&quot;arr[3]: %d\n&quot;, sarg3);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bpftrace ./type.bt</span><br><span class="line">Attaching 1 probe...</span><br><span class="line">arr[0]: 1</span><br><span class="line">arr[1]: 2</span><br><span class="line">arr[2]: 3</span><br><span class="line">arr[3]: 4</span><br></pre></td></tr></table></figure>

<p>需要注意的是，定长数组作为结构体参数时，也是直接将参数堆积的，而不是类似<code>slice</code>的由指针及长度组成。</p>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p><code>golang</code>结构体作为函数参数传递时，会直接将结构体内的成员逐个传递。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// type/main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type S struct &#123;</span><br><span class="line">	X int64</span><br><span class="line">	Y int64</span><br><span class="line">	Z [3]int64</span><br><span class="line">	A int64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 请注意 other 参数，虽然其作为函数的第二个参数，但其在函数列表中的偏移量是 48B</span><br><span class="line">//go:noinline</span><br><span class="line">func struct_p(s S, other int64) &#123;</span><br><span class="line">	fmt.Println(s, other)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	s := S&#123;</span><br><span class="line">		X: 1,</span><br><span class="line">		Y: 2,</span><br><span class="line">		Z: [3]int64&#123;3, 4, 5&#125;,</span><br><span class="line">		A: 6,</span><br><span class="line">	&#125;</span><br><span class="line">	struct_p(s, 7)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// type/type.bt</span><br><span class="line">uprobe:./type:&quot;main.struct_p&quot;</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;X: %d\n&quot;, sarg0);</span><br><span class="line">    printf(&quot;Y: %d\n&quot;, sarg1);</span><br><span class="line">    printf(&quot;A: %d\n&quot;, sarg5);</span><br><span class="line">    printf(&quot;other: %d\n&quot;, sarg6);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bpftrace ./type.bt</span><br><span class="line">Attaching 1 probe...</span><br><span class="line">X: 1</span><br><span class="line">Y: 2</span><br><span class="line">A: 6</span><br><span class="line">other: 7</span><br></pre></td></tr></table></figure>

<p>结构体作为函数参数，往往会涉及到内存对齐的问题。需要逐个分析了。</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p><code>golang</code>指针作为函数参数时，会直接传递指针数值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// type/main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type P struct &#123;</span><br><span class="line">	X int64</span><br><span class="line">	Y int64</span><br><span class="line">	Z [3]int64</span><br><span class="line">	A int64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func pointer_p(p *P) &#123;</span><br><span class="line">	fmt.Println(*p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	p := &amp;P&#123;</span><br><span class="line">		X: 1,</span><br><span class="line">		Y: 2,</span><br><span class="line">		Z: [3]int64&#123;3, 4, 5&#125;,</span><br><span class="line">		A: 6,</span><br><span class="line">	&#125;</span><br><span class="line">	pointer_p(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// type/type.bt</span><br><span class="line">uprobe:./type:&quot;main.pointer_p&quot;</span><br><span class="line">&#123;</span><br><span class="line">    $p = sarg0;</span><br><span class="line">    printf(&quot;X: %d\n&quot;, *(int64*)($p+0));</span><br><span class="line">    printf(&quot;Y: %d\n&quot;, *(int64*)($p+8));</span><br><span class="line">    printf(&quot;A: %d\n&quot;, *(int64*)($p+40));</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bpftrace ./type.bt</span><br><span class="line">Attaching 1 probe...</span><br><span class="line">X: 1</span><br><span class="line">Y: 2</span><br><span class="line">A: 6</span><br></pre></td></tr></table></figure>

<p>解析<code>golang</code>指针成员的时候，需要提前知晓指针结构体的内容。</p>
<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p><code>golang</code>的<code>map</code>实现比较复杂，详细的介绍可以看下这篇文章：<a href="https://golang.design/go-questions/map/principal/">golang map</a>。<code>map</code>作为参数传递时，实际上传递的是<code>hmap</code>的指针。<br>由于<code>golang</code>的<code>map</code>实际的结构及具体结构体的大小会受到<code>map key, map value</code>的影响，这对使用<code>eBPF</code>来解析<code>golang map</code>带来了额外的挑战。所幸本文并不期望提供一个<code>golang map</code>解析的通用方法，我们可以提前定义所需要解析的<code>map</code>为<code>map[int64]int64</code>，在这个条件下，<code>bmap</code>的结构就为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// sizeof(bmap) = 144B</span><br><span class="line">type bmap struct &#123;</span><br><span class="line">    topbits  [8]uint8 // 8B</span><br><span class="line">    keys     [8]int64 // 64B</span><br><span class="line">    values   [8]int64 // 64B</span><br><span class="line">    //pad      uintptr //不需要添加内存对齐参数</span><br><span class="line">    overflow uintptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确定了<code>bmap</code>的信息后，可以看到，<code>keys</code>及<code>values</code>的偏移信息就确定了，可以直接读取。但是由于<code>key</code>实际映射时是通过<code>hash</code>来决定其位置的，完整的读取<code>map</code>显然是很困难的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// type/main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func map_p(m map[int64]int64) &#123;</span><br><span class="line">	fmt.Println(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	m := map[int64]int64&#123;&#125;</span><br><span class="line">	for i := int64(1); i &lt;= int64(10); i++ &#123;</span><br><span class="line">		m[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">	map_p(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// type/type.bt</span><br><span class="line">uprobe:./type:&quot;main.map_p&quot;</span><br><span class="line">&#123;</span><br><span class="line">    $hmap_addr = sarg0;</span><br><span class="line">    $bucket_addr = *(uint64*)($hmap_addr+16);</span><br><span class="line">    $bucket_offset = 0;</span><br><span class="line">    unroll(2)&#123; // 尝试读取两个 bmap</span><br><span class="line">        $bmap_addr = $bucket_addr + $bucket_offset;</span><br><span class="line">        $key_addr = $bmap_addr + 8;</span><br><span class="line">        $value_addr = $bmap_addr + 72;</span><br><span class="line"></span><br><span class="line">        $offset = 0;</span><br><span class="line">        unroll(8)&#123; // 读取每个 bmap 的所有 key-value</span><br><span class="line">            $key = *(int64*)($key_addr+$offset);</span><br><span class="line">            $value = *(int64*)($value_addr+$offset);</span><br><span class="line">            printf(&quot;key: %d, value: %d\n&quot;, $key, $value);</span><br><span class="line">            $offset = $offset + 8;</span><br><span class="line">        &#125;</span><br><span class="line">        $bucket_offset = $bucket_offset + 144;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 笔者的这次运行，把[1,10]所有的key都输出了</span><br><span class="line">bpftrace ./type.bt</span><br><span class="line">Attaching 1 probe...</span><br><span class="line">key: 2, value: 2</span><br><span class="line">key: 3, value: 3</span><br><span class="line">key: 5, value: 5</span><br><span class="line">key: 6, value: 6</span><br><span class="line">key: 7, value: 7</span><br><span class="line">key: 8, value: 8</span><br><span class="line">key: 9, value: 9</span><br><span class="line">key: 10, value: 10</span><br><span class="line">key: 1, value: 1</span><br><span class="line">key: 4, value: 4</span><br><span class="line">key: 0, value: 0</span><br><span class="line">key: 0, value: 0</span><br><span class="line">key: 0, value: 0</span><br><span class="line">key: 0, value: 0</span><br><span class="line">key: 0, value: 0</span><br><span class="line">key: 0, value: 0</span><br></pre></td></tr></table></figure>

<p>使用<code>eBPF</code>来读取<code>map</code>，不得不预设一个确定的大小。至于是否能够读取所有的<code>map</code>值，就不好说了。</p>
<h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><p><code>golang</code>的<code>interface</code>是由<code>8B type pointer</code>+<code>8B struct pointer</code>组成的。当解析<code>interface</code>的时候，需要的往往是<code>struct pointer</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// type/main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Inter interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">type S struct &#123;</span><br><span class="line">	X int64</span><br><span class="line">	Y int64</span><br><span class="line">	Z [3]int64</span><br><span class="line">	A int64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func struct_p(i Inter, other int64) &#123;</span><br><span class="line">	s, _ := i.(S)</span><br><span class="line">	fmt.Println(s, other)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	s := S&#123;</span><br><span class="line">		X: 1,</span><br><span class="line">		Y: 2,</span><br><span class="line">		Z: [3]int64&#123;3, 4, 5&#125;,</span><br><span class="line">		A: 6,</span><br><span class="line">	&#125;</span><br><span class="line">	struct_p(s, 7)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// type/type.bt</span><br><span class="line">uprobe:./type:&quot;main.struct_p&quot;</span><br><span class="line">&#123;</span><br><span class="line">    $addr = sarg1;</span><br><span class="line">    printf(&quot;X: %d\n&quot;, *(int64*)($addr+0));</span><br><span class="line">    printf(&quot;Y: %d\n&quot;, *(int64*)($addr+8));</span><br><span class="line">    printf(&quot;A: %d\n&quot;, *(int64*)($addr+40));</span><br><span class="line">    printf(&quot;other: %d\n&quot;, sarg2);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bpftrace ./type.bt</span><br><span class="line">Attaching 1 probe...</span><br><span class="line">X: 1</span><br><span class="line">Y: 2</span><br><span class="line">A: 6</span><br><span class="line">other: 7</span><br></pre></td></tr></table></figure>

<p>从示例中可以看出，当解析<code>interface</code>时，<code>interface</code>具体的结构体成员对我们而言更加重要。在实际的工程里，往往会出现多个结构体实现同一个<code>interface</code>，并且均可以作为该<code>interface</code>来传递值的情况。这时就需要依据所实际期望解析的结构体来进行实际采集的过滤或者适配了。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>本文编写的文章超过了笔者的估计时间 :)。<code>anyway</code>，这篇文章最终整理完成了。期望有读者能够籍此对<code>eBPF</code>有直观的认识，同时体会到其观察<code>golang</code>的独特视角。<br>周末愉快，新年快乐！</p>
]]></content>
  </entry>
  <entry>
    <title>lisp-do循环</title>
    <url>/2019/06/03/cljb83dm9002dkcs6fbh012is/</url>
    <content><![CDATA[<p>lisp中，do循环形象如下:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(do (variable-definition*)</span><br><span class="line">    (end-test-form result-form*)</span><br><span class="line">    statement*);</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>其中，<code>(variable-definition*)</code>是一些行日<code>(var init next)</code>的赋值结构。在<code>do</code>开始时，<code>var</code>会被赋值为<code>init</code>。并且在一次循环结束后，<code>var</code>会被赋值为<code>next</code>所表示的内容。<br>形如：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(do ((n 0 (+ 1 n))</span><br><span class="line">     (cur 0 next)</span><br><span class="line">     (next 1 (+ cur next)))</span><br><span class="line">    ((= 10 n) (format t &quot;|end ~d&quot; cur))</span><br><span class="line">  (format t &quot;~d|&quot; cur));</span><br></pre></td></tr></table></figure>
<p>输出：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0|1|1|2|3|5|8|13|21|34||end 55</span><br></pre></td></tr></table></figure>
<p>类似于python中的：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cur = 0</span><br><span class="line">next = 1</span><br><span class="line">for i in range(10):</span><br><span class="line">    print(&quot;%d|&quot; % cur)</span><br><span class="line">    cur, next = next, cur + next</span><br><span class="line">print(&quot;|end %d&quot; % cur)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>lisp</tag>
      </tags>
  </entry>
  <entry>
    <title>lisp-lambda函数</title>
    <url>/2019/05/29/cljb83dma002hkcs6d79ga13s/</url>
    <content><![CDATA[<p>lisp中的lambda表达式，显然和python中的很相似。<br>参照《实用common lisp编程》：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;按照 min max, 步长step为参数的fn计算的长度输出 *</span><br><span class="line">(defun plot (fn min max step)</span><br><span class="line">  (loop for i from min to max by step do</span><br><span class="line">        (loop repeat (funcall fn i) do (format t &quot;*&quot;))</span><br><span class="line">        (format t &quot;~%&quot;)))</span><br><span class="line"></span><br><span class="line">(plot #&#x27;exp 0 4 1/2);</span><br><span class="line">(plot #&#x27;(lambda (x) (* 2 x)) 0 10 1);</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">*****</span><br><span class="line">********</span><br><span class="line">*************</span><br><span class="line">*********************</span><br><span class="line">**********************************</span><br><span class="line">*******************************************************</span><br><span class="line"></span><br><span class="line">**</span><br><span class="line">****</span><br><span class="line">******</span><br><span class="line">********</span><br><span class="line">**********</span><br><span class="line">************</span><br><span class="line">**************</span><br><span class="line">****************</span><br><span class="line">******************</span><br><span class="line">********************</span><br></pre></td></tr></table></figure>
<p><code>#'</code>为lisp语言的语法糖，展开表示为<code>function</code>。后者将会把一个函数生成为一个函数对象，后者可以通过<code>funcall</code>调用。<br>interesting。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>lisp</tag>
      </tags>
  </entry>
  <entry>
    <title>org-mode使用备注</title>
    <url>/2021/01/11/cljb83dmc002kkcs61b303w2w/</url>
    <content><![CDATA[<blockquote>
<p>org-mode agenda界面变更任务状态、添加备注、添加日记（每日总结）、编辑记录</p>
</blockquote>
<p>以下操作均在<code>org-agenda</code>中的<code>agenda for current week or day</code>视图下快速编辑：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>变更任务状态</td>
<td>t</td>
</tr>
<tr>
<td>添加备注</td>
<td>z</td>
</tr>
<tr>
<td>添加日记</td>
<td>i</td>
</tr>
<tr>
<td>编辑note</td>
<td>z</td>
</tr>
<tr>
<td>重建agenda</td>
<td>r</td>
</tr>
<tr>
<td>打开日历</td>
<td>a</td>
</tr>
<tr>
<td>下周任务列表</td>
<td>f</td>
</tr>
<tr>
<td>上周任务列表</td>
<td>b</td>
</tr>
<tr>
<td>打开任务所在原始文件</td>
<td>enter</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>code</category>
        <category>life</category>
      </categories>
      <tags>
        <tag>emacs</tag>
        <tag>org-mode</tag>
        <tag>效率工具</tag>
      </tags>
  </entry>
  <entry>
    <title>lisp-let变量声明</title>
    <url>/2019/05/30/cljb83dmd002nkcs6al8834ao/</url>
    <content><![CDATA[<p>lisp声明、使用变量的一种方法，是使用<code>let</code>语句。<br>形如：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;(let ((variable declare1) (variable declare2) (...))</span><br><span class="line">;  (varaible used here));</span><br><span class="line">(defun foo(x)</span><br><span class="line">  (format t &quot;Parameter: ~a~%&quot; x)</span><br><span class="line">  (let ((x 2))</span><br><span class="line">    (format t &quot;Outer LET: ~a~%&quot; x)</span><br><span class="line">    (let ((x 3))</span><br><span class="line">      (format t &quot;Inner LET: ~a~%&quot; x))</span><br><span class="line">    (format t &quot;Outer LET: ~a~%&quot; x))</span><br><span class="line">  (format t &quot;Parameter: ~a~%&quot; x));</span><br><span class="line"></span><br><span class="line">(foo 10);</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>声明的作用域，和C语言很相似，存在覆盖的特点。输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Parameter: 10</span><br><span class="line">Outer LET: 2</span><br><span class="line">Inner LET: 3</span><br><span class="line">Outer LET: 2</span><br><span class="line">Parameter: 10</span><br></pre></td></tr></table></figure>
<p>使用<code>let</code>声明时，变量声明域内，无法使用前一个在本声明域内声明的变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(defun year-day(y)</span><br><span class="line">  (let ((m (* y 12)) (d (* m 30)))</span><br><span class="line">    (format t &quot;Year:~d~%Month:~d~%Day:~d~%&quot; y m d)));</span><br><span class="line">(year-day 1);</span><br><span class="line"></span><br><span class="line">*** - LET: variable M has no value</span><br></pre></td></tr></table></figure>
<p>使用<code>let*</code>可以进行如此操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(defun year-day(y)</span><br><span class="line">  (let* ((m (* y 12)) (d (* m 30)))</span><br><span class="line">    (format t &quot;Year:~d~%Month:~d~%Day:~d~%&quot; y m d)));</span><br><span class="line">(year-day 1);</span><br><span class="line">Year:1</span><br><span class="line">Month:12</span><br><span class="line">Day:360</span><br></pre></td></tr></table></figure>
<p>just like this.</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>lisp</tag>
      </tags>
  </entry>
  <entry>
    <title>lisp-hello world</title>
    <url>/2019/05/28/cljb83dmd002pkcs6hwvq3oec/</url>
    <content><![CDATA[<p>lisp语言的基本表达式为S-表达式。这与受<a href="https://en.wikipedia.org/wiki/ALGOL">Algol</a>语言影响的C系语言有很大的不同。显然，这很有趣：</p>
<pre><code>;the bellow is hello world function in lisp
  (defun hello-world()
    &quot;hello world function in lisp&quot;
    (format t &quot;hello, world!&quot;));```
由&lt;code&gt;()&lt;/code&gt;所包围的内容，为*列表*，其余内容为原子。显然，lisp表达式有很多列表表示（List Processing)。
</code></pre>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>lisp</tag>
      </tags>
  </entry>
  <entry>
    <title>emacs! start org-mode! --org-mod使用备注</title>
    <url>/2021/01/10/cljb83dme002skcs65rgf3gmt/</url>
    <content><![CDATA[<blockquote>
<p>为了更好的<code>live in emacs</code>，一款合适的日程管理工具总是需要的。在挣扎了若干次后，最终还是把<code>org-mode</code>这一优秀的日程管理工具捡起来了。本文简单记录下使用的方法。</p>
</blockquote>
<h1 id="org-mode介绍"><a href="#org-mode介绍" class="headerlink" title="org-mode介绍"></a>org-mode介绍</h1><p>在<code>神的编辑器emacs</code>的传说中，往往有<code>org-mode</code>的身影。虽然按照(org官网)<a href="https://orgmode.org/">orgmode</a>官网的描述，<code>org-mode</code>并不仅限于在<code>emacs</code>中使用，如<a href="https://zhuanlan.zhihu.com/p/57800574">开始使用 Org 模式吧，在没有 Emacs 的情况下</a>这篇文章就详细讲解了在<code>vscode</code>中使用<code>org-mode</code>的方式，但是配合<code>emacs</code>的万物皆系于<code>kbd</code>之上的使用习惯，<code>org-mode</code>确实能够发挥最大的功能。<br><code>org-mode</code>的基本功能包括设置待办事项、设置待办的标签、查看日历、查看某一天的待办及进度。基本上，满足了对优秀日程管理工具的所有想象。</p>
<span id="more"></span>
<p>这里贴一下<a href="https://wizardforcel.gitbooks.io/os-world-trip/content/42.html">开源世界旅行手册</a>中涉及的<code>org-mode</code>与<code>oneNote</code>的对比，能够更加直观的了解<code>org-mode</code>的功能：</p>
<table>
<thead>
<tr>
<th>org-mode vs oneNote</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>Org-mode</td>
<td>OneNote</td>
</tr>
<tr>
<td>标签</td>
<td>强大</td>
<td>不支持</td>
</tr>
<tr>
<td>日程表</td>
<td>强大</td>
<td>不支持</td>
</tr>
<tr>
<td>界面</td>
<td>字符</td>
<td>漂亮</td>
</tr>
<tr>
<td>TablePC</td>
<td>不支持</td>
<td>非常好</td>
</tr>
<tr>
<td>摘录</td>
<td>保持源格式</td>
<td></td>
</tr>
<tr>
<td>便捷</td>
<td>Emacs 内置</td>
<td>安装麻烦</td>
</tr>
</tbody></table>
<h1 id="基本使用流程"><a href="#基本使用流程" class="headerlink" title="基本使用流程"></a>基本使用流程</h1><p>目前还处于探索阶段了，简单描述下<code>org-mode</code>的配置流程。<br>0. 版本<br>使用的是<code>emacs-27.1</code>版本，默认内置了<code>org-mode</code>(值得一提的是，当我在写一篇文章时，发现hexo#admin编辑器是支持部分<code>emacs</code>快捷键的，又反映了<code>emacs</code>影响之广)。</p>
<ol>
<li>设置<br><code>org-mode</code>在使用时，一般是在文本文档中编辑待办内容，将待办内容加入<code>org-mode</code>的日程表。而后通过<code>org-agenda</code>来查看指定日期的待办内容，并随着待办内容设置事务的进度。<br>使用前，如果是使用<code>emacs</code>进行编辑的话，可以在<code>emacs</code>配置文件中作如下设置：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;; 将.org结尾的文档，均以org-mode打开</span><br><span class="line">(add-to-list &#x27;auto-mode-alist &#x27;(&quot;\\.org\\&#x27;&quot; . org-mode))</span><br><span class="line">;; 将org-agenda绑定为Ctrl-c a 快捷键</span><br><span class="line">(global-set-key (kbd &quot;C-c a&quot;) &#x27;org-agenda)</span><br></pre></td></tr></table></figure>
重新打开<code>emacs</code>使配置生效，重新载入<code>emacs</code>配置文件即可。<br>使用时，可以单独建立一个文件夹，来存储不同需求的日程文档（如，笔者在<code>~/.org/</code>目录下创建了<code>2021.org</code>,<code>learn.org</code>等多个文档）。以下是一个简单的待办文档内容（引用自<a href="https://wizardforcel.gitbooks.io/os-world-trip/content/42.html">文章3</a>）：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#+STARTUP: overview  </span><br><span class="line">#+TAGS: &#123; 桌面(d) 服务器(s) &#125;  编辑器(e) 浏览器(f) 多媒体(m) 压缩(z)</span><br><span class="line">#+TAGS:  &#123; @Windows(w)  @Linux(l) &#125;    </span><br><span class="line">#+TAGS:  &#123; 糟糕(1) 凑合(2) 不错(3) 很好(4) 极品(5) &#125;  </span><br><span class="line">#+SEQ_TODO: TODO(T) WAIT(W) | DONE(D!) CANCELED(C@)  </span><br><span class="line">#+COLUMNS: %10ITEM  %10PRIORITY %15TODO %65TAGS  </span><br><span class="line">* 工作  &lt;2021-01-10&gt;-&lt;2022-01-10&gt;</span><br><span class="line">** Emacs  &lt;2021-01-10 21:00 ++1d&gt;</span><br><span class="line">   神之编辑器  </span><br><span class="line">*** org-mode  </span><br><span class="line">    组织你的意念  </span><br></pre></td></tr></table></figure>
（更多的内容可以查看下<a href="https://wizardforcel.gitbooks.io/os-world-trip/content/42.html">原文</a>，本文仅简单介绍）<br>以<code>#+</code>开头的可以认为是本地设置内容。<code>#+TAGS: </code>后设置的内容，是本日程中预设的日程标签，标签<code>()</code>中的是该标签的缩写，需要保持唯一。在下面的日程（或者<code>标题</code>，可以很容易的看出来，和<code>markdown</code>是类似的语法）上使用快捷键<code>Ctrl-c Ctrl-c</code>(或者说，<code>C-c C-c</code>)，即可给日程打上标签。每个<code>&#123;&#125;</code>内的标签是互斥的，在设置时，可以注意下。<br>下面的日程中,<code>&lt;2021-01-10&gt;-&lt;2022-01-10&gt;</code>表示该事件时间范围为<code>2021-01-10</code>至<code>2022-01-10</code>结束。<code>&lt;2021-01-10 21:00 ++1d&gt;</code>表示这个子任务的时间开始于<code>2021-01-10 21:00</code>而后每天重复一次(++1w，++1m为周、月，以此类推)。<br>而后，保存文件。使用<code>Ctrl-c [</code>将当前日程文件纳入<code>org-mode</code>的日程表。使用前面配置的快捷键<code>C-c a</code>唤出日历，会出现如下提示：</li>
</ol>
<p>|Press key for an agenda command:|<br>|—-|—-|<br>|a|    本周事件|<br>|t|    显示所有事件|<br>|m|    查询标签|<br>|L|    当前缓冲区时间线|<br>|s|    查询关键词|<br>|T|    查询带 TODO 关键词的项|<br>|M|    查询带 TODO 关键词的标签|<br>|#|    显示已停止事件|<br>|q|    退出日程表|<br>选择<code>a</code>，可以查看本周的事件。如果已经到了所设置的事件区间，即可看到我们设置的事件内容。<br>以上算是简单的入门了。</p>
<h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><ol>
<li><a href="https://victor72.github.io/blog/2016/06/20/with-org-page-manage-lives/">使用org-mode 管理日常事务- 日知录</a>  </li>
<li><a href="https://www.cnblogs.com/holbrook/archive/2012/04/17/2454619.html">用Org-mode实现GTD</a>  </li>
<li><a href="https://wizardforcel.gitbooks.io/os-world-trip/content/42.html">组织你的意念：Emacs org mode</a>.</li>
</ol>
]]></content>
      <categories>
        <category>code</category>
        <category>life</category>
      </categories>
      <tags>
        <tag>emacs</tag>
        <tag>org-mode</tag>
        <tag>日程管理</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>ratelimit服务流量限制</title>
    <url>/2021/02/07/cljb83dme002vkcs65rngepnq/</url>
    <content><![CDATA[<blockquote>
<p>在日常的工作中，固定QPS或者固定并发数是常用的两个衡量系统容量时采用的流量控制手段。本文以<a href="https://chai2010.cn/advanced-go-programming-book/">Go语言高级编程</a> 服务流量限制的内容为开端，对服务流量限制进行展开描述，同时对<code>Jmeter</code>及<code>golang ratelimit</code>中的流量限制方法进行描述。</p>
</blockquote>
<ol>
<li>起因</li>
<li>漏桶法</li>
<li>令牌桶法</li>
<li>Jmeter中流量吞吐控制</li>
<li>golang ratelimit<span id="more"></span></li>
</ol>
<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>流量限制手段在系统流量控制以及系统质量评估上都有广泛的应用。对于有多个子模块/下游的系统，如果已知其中一个模块/下游是整个系统处理能力的瓶颈，从系统的入口添加流量限制并添加超量告警，不失为是保护系统的有效手段。从质量保证的手段来说，在衡量一个系统的稳定性时，需要有一个有效的手段来控制给予系统的压力并进行控制。<br>固定并发数量的流量控制方式是相对容易实现的：对于系统而言，可以添加一个连接池；对于请求方而言，维护一个请求并发池即可。对于固定QPS的流量控制手段而言，则又复杂一些：由于基本指令的直接支持，所以固定QPS的流量控制手段多在基于并发的流量控制上进行二次的封装。封装的措施实际上又会影响控制的效果。笔者曾经在搜索系统上，尝试基于Jmeter，使用1000个线程来产生一个固定的100QPS的并发数。由于Jmeter固定吞吐量实现的特点，导致实际产生的效果中，100个请求多集中在1分钟的前几秒，甚至是最开始1s的前若干ms。使得服务承受的顺势并发非常大，服务出现异常也是可以预见的事情了。<br>了解一些流量控制的手段还是有必要的。本文主要梳理一下<a href="https://chai2010.cn/advanced-go-programming-book/">Go语言高级编程</a>提到的漏桶及令牌桶两种方法，并且进行简单的实现。</p>
<h1 id="漏桶法"><a href="#漏桶法" class="headerlink" title="漏桶法"></a>漏桶法</h1><p>基于<a href="https://en.wikipedia.org/wiki/Leaky_bucket">Leaky_bucket</a>的描述，目前广泛流行的漏桶法存在两种模式：度量法（the leaky bucket as a meter）及队列法（the leaky bucket as a queue）。<br>度量法在处理时，单位时间内的请求如果超过了预设的数量，会将请求丢弃。比如，需要固定的流量为100QPS，我们以100ms作为一个衡量单元，即10 query/100ms。则，在单位的100ms内，如果请求数量超过了10，则将超过10的请求丢弃。对于队列法，则会将超过的请求均放在一个队列里，在下个时间单位内，按照先进先出的原则，处理队列内的请求。<br>在请求数量较多且分布均匀的场景下，度量法更加适用。系统已经处于处理的极限，额外的请求存储似乎不太现实。对于流量分布不均的场景下，队列法能够抹平流量的不均匀。在队列长度可控的场景下，队列法能够兼顾请求方（尽量不丢请求）及服务方（控制流量）。至于超出的部分，应该考虑引入告警等方式来把控风险。</p>
<h1 id="令牌桶法"><a href="#令牌桶法" class="headerlink" title="令牌桶法"></a>令牌桶法</h1><p>对令牌桶法的详细介绍见<a href="https://en.wikipedia.org/wiki/Token_bucket">Token bucket</a>。令牌桶法可以认为是更加一般的漏桶法。严格意义上的漏桶法要求每次仅有一个单位的请求被允许，令牌桶法则将其扩展为固定时间段内，产出多个令牌，被请求申请。当令牌桶法每次仅允许一个令牌时，显然就成了漏桶法。</p>
<h1 id="Jmeter中吞吐量的控制逻辑"><a href="#Jmeter中吞吐量的控制逻辑" class="headerlink" title="Jmeter中吞吐量的控制逻辑"></a>Jmeter中吞吐量的控制逻辑</h1><p>笔者找到的Jmeter最新版本为<a href="https://github.com/apache/jmeter/blob/master/src/components/src/main/java/org/apache/jmeter/timers/ConstantThroughputTimer.java">ConstantThroughputTimer</a>。在该实现中，主要分为单线程、多线程、共享线程等模式下的吞吐量（Jmeter中的吞吐量为Query Per Minutes)等模式。可以看出，Jmeter在不同的限流逻辑下，计算每个线程需要的delay时间实现jmeter的请求调度，体现了漏桶法的思路。<br>相关代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Calculate the delay based on the mode</span><br><span class="line">private long calculateDelay() &#123;</span><br><span class="line">    long delay;</span><br><span class="line">    // N.B. we fetch the throughput each time, as it may vary during a test</span><br><span class="line">    double msPerRequest = MILLISEC_PER_MIN / getThroughput();</span><br><span class="line">    switch (mode) &#123;</span><br><span class="line">    case AllActiveThreads: // Total number of threads</span><br><span class="line">        delay = Math.round(JMeterContextService.getNumberOfThreads() * msPerRequest);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case AllActiveThreadsInCurrentThreadGroup: // Active threads in this group</span><br><span class="line">        delay = Math.round(JMeterContextService.getContext().getThreadGroup().getNumberOfThreads() * msPerRequest);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case AllActiveThreads_Shared: // All threads - alternate calculation</span><br><span class="line">        delay = calculateSharedDelay(allThreadsInfo,Math.round(msPerRequest));</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case AllActiveThreadsInCurrentThreadGroup_Shared: //All threads in this group - alternate calculation</span><br><span class="line">        final org.apache.jmeter.threads.AbstractThreadGroup group =</span><br><span class="line">            JMeterContextService.getContext().getThreadGroup();</span><br><span class="line">        ThroughputInfo groupInfo = threadGroupsInfoMap.get(group);</span><br><span class="line">        if (groupInfo == null) &#123;</span><br><span class="line">            groupInfo = new ThroughputInfo();</span><br><span class="line">            ThroughputInfo previous = threadGroupsInfoMap.putIfAbsent(group, groupInfo);</span><br><span class="line">            if (previous != null) &#123; // We did not replace the entry</span><br><span class="line">                groupInfo = previous; // so use the existing one</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        delay = calculateSharedDelay(groupInfo,Math.round(msPerRequest));</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case ThisThreadOnly:</span><br><span class="line">    default: // e.g. 0</span><br><span class="line">        delay = Math.round(msPerRequest); // i.e. * 1</span><br><span class="line">        break;</span><br><span class="line">    return delay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="golang-ratelimit介绍"><a href="#golang-ratelimit介绍" class="headerlink" title="golang ratelimit介绍"></a>golang ratelimit介绍</h1><p>golang中也有很多请求控制的方法。工程中经常使用的 <code>chan(bool)</code>+<code>WaitGroup</code>池化了请求限制，可以认为是令牌桶法的思路的一种简化；golang自带的<code>Ticker</code>则会在固定的时间间隔内产生一个就绪的状态，可以看出漏桶法的思想。更加工程化的选择，可以看下<a href="https://github.com/uber-go/ratelimit">golang ratelimit</a>uber开源的这个golang版本的ratelimit实现。水平优先，就贴一个网上找来的源码分析文章<a href="https://www.cyhone.com/articles/analysis-of-uber-go-ratelimit/">uber-go 漏桶限流器使用与原理分析</a>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文对常用的两个限流方法<code>漏桶法</code>及<code>令牌桶法</code>进行了简单的描述。同时简单涉及了下<code>Jmeter</code>中的流量限制及<code>golang</code>中不同请求限制措施的思路。  </p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>系统稳定性</tag>
        <tag>压力测试</tag>
        <tag>自我修养</tag>
        <tag>读代码</tag>
      </tags>
  </entry>
  <entry>
    <title>python调试方法（其一）</title>
    <url>/2019/07/17/cljb83dmf002ykcs6fpnq8slw/</url>
    <content><![CDATA[<p>&lt;一&gt; 这里记录一些python调试的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># coding=UTF-8</span><br><span class="line">&#x27;&#x27;&#x27; python debug method 1</span><br><span class="line">use print function to get output informatino</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">DEBUG = True</span><br><span class="line"></span><br><span class="line">def _debug_(*args, **kwds):</span><br><span class="line">	&#x27;&#x27;&#x27; depends on DEBUG value, print some function &#x27;&#x27;&#x27;</span><br><span class="line">    global DEBUG</span><br><span class="line">    if DEBUG:</span><br><span class="line">    	print(args, kwds)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">	_debug_(&quot;this is a test&quot;)</span><br></pre></td></tr></table></figure>
<p>最常见的调试方法了。<code>print</code>可以依据需求调整为其他的方式（<code>logging</code>输出日志或者直接输出到文件中均可）。  </p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 输出结果如下：</span><br><span class="line">((&#x27;this is a test&#x27;,), &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>&lt;二&gt;然后就是更直接一些的调试方法了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># coding=UTF-8</span><br><span class="line">import pdb</span><br><span class="line">def test_function():</span><br><span class="line">	&#x27;&#x27;&#x27; regard it as a test funcion &#x27;&#x27;&#x27;</span><br><span class="line">    try:</span><br><span class="line">    	a = 1</span><br><span class="line">        b = 0</span><br><span class="line">    	c = a / b</span><br><span class="line">    except Exception, e:</span><br><span class="line">    	pdb.set_trace()</span><br><span class="line">    return</span><br><span class="line">    </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">	test_function()</span><br></pre></td></tr></table></figure>
<p>直接一点了，直接在代码中显式设置断点。这样，在异常发生时，就可以直接中断调试了。<br><code>python</code>中的<code>pdb</code>应该可以认为是一种阉割版的<code>gdb</code>了。仅对<code>list</code><code>print</code>及其他的<code>python</code>的内置函数有较好的支持。相互配合来看的话，也能发现很多问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 输出如下：</span><br><span class="line">&gt; test_debug.py(11)test_function()</span><br><span class="line">-&gt; return</span><br><span class="line">(Pdb) list</span><br><span class="line">  6             a = 1</span><br><span class="line">  7             b = 0</span><br><span class="line">  8             c = a / b</span><br><span class="line">  9         except Exception, e:</span><br><span class="line"> 10             pdb.set_trace()</span><br><span class="line"> 11  -&gt;     return</span><br><span class="line"> 12</span><br><span class="line"> 13     if __name__ == &quot;__main__&quot;:</span><br><span class="line"> 14         test_function()</span><br><span class="line">[EOF]</span><br><span class="line">(Pdb) print(e)</span><br><span class="line">integer division or modulo by zero</span><br><span class="line">(Pdb) print(a, b, c)</span><br><span class="line">*** NameError: name &#x27;c&#x27; is not defined</span><br><span class="line">(Pdb) print(a, b)</span><br><span class="line">(1, 0)</span><br><span class="line">(Pdb) quit()</span><br></pre></td></tr></table></figure>
<p>唔，先这样吧。可以考虑收集一些<code>python</code>的内置解析包来配合调试了。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>redisgo 连接报错</title>
    <url>/2021/08/18/cljb83dmf0031kcs61rkd5ig0/</url>
    <content><![CDATA[<blockquote>
<p>记一次<code>redisgo</code>库使用时，连接远程<code>redis</code>服务写数据报错的问题。</p>
</blockquote>
<p> <code>redis</code>写数据时，出现报错<code>write: broken pipe</code>及<code>write: connection reset by peer</code>。看着都是网络的问题，使用<code>redis-cli</code>可以登陆并且执行查询等操作。经过排查，是写的数据量过大，导致写数据持续时间过长，排查的思路是猜想-&gt;验证<code>@A@</code>。<br> 对于多个数据可以进行拆分。对于单个完整的数据，还没有太好的拆分思路（或许基于 <code>pb</code> 进行压缩，会是个好方式？）</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p> <a href="https://blog.csdn.net/xieganyu3460/article/details/82884346">python redis读写报错：Broken Pipe Error Redis</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>redisgo</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>sed使用备注</title>
    <url>/2020/11/12/cljb83dmg0033kcs630pzhrue/</url>
    <content><![CDATA[<h2 id="sed功能介绍"><a href="#sed功能介绍" class="headerlink" title="sed功能介绍"></a>sed功能介绍</h2><p>先看下官方的介绍</p>
<blockquote>
<p>Sed  is a stream editor. A stream editor is used to perform basic text transformations on an input stream (a file or input from a pipeline).<br>While in some ways similar to an editor which permits scripted edits (such as ed), sed works by making only one pass over the  input(s),  and<br>is consequently more efficient.  But it is sed’s ability to filter text in a pipeline which particularly distinguishes it from other types of<br>editors.</p>
</blockquote>
<p>大概的意思，是面向流的文本编辑工具。一般用来对文件中的文本进行替换等操作。<br>以下备注一些常用的操作方式了。  </p>
<span id="more"></span>
<h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><p>我们以上段文字为例，使用<code>sed</code>进行文本的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &quot;s#Sed#SED#g&quot; text</span><br><span class="line">使用 -i 才可以直接修改 text 里面的内容，否则无法修改（但是会将修改后的内容输出到标准输出）</span><br><span class="line">这里使用#作为sed的限位符而非/，是因为一般文本中，/符号出现的频率要较#高。直接使用#就不需要频繁转义了。</span><br><span class="line"></span><br><span class="line">sed -i &#x27;2,2 s#in#in_#g&#x27; text</span><br><span class="line">将 行号 [2,2] 中的 in 全部替换为 in_，注意，input也会被替换为in_put</span><br><span class="line"></span><br><span class="line">sed -i &#x27;/While.*/, /.*editors/ s#in#in_#g&#x27; text</span><br><span class="line">将 While.* .*editors 之间的 in 全部替换为 in_</span><br><span class="line"></span><br><span class="line">sed -i &#x27;2,+1 s#in#in_#g&#x27; text</span><br><span class="line">将 [2, 2+1=3] 行内的 in 全部替换为 in_</span><br></pre></td></tr></table></figure>
<p>基本上常用的一些 <code>sed</code>替换方式就是这些了。<code>man</code>文档中还有一些基于倍数的替换范围决定方式，这里就不说明了。使用的时候，还是尽量使用通俗易懂的方式。</p>
]]></content>
  </entry>
  <entry>
    <title>x86_64 寄存器传参方式</title>
    <url>/2022/08/31/cljb83dmg0036kcs6fn5o4rls/</url>
    <content><![CDATA[<blockquote>
<p>x86_64 架构下，寄存器传参时，仅 arg1-arg6 会通过寄存器进行，arg7+ 的参数，将会放到栈上进行。</p>
</blockquote>
<h1 id="验证代码"><a href="#验证代码" class="headerlink" title="验证代码"></a>验证代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 环境</span><br><span class="line">├── arg.bt</span><br><span class="line">├── arg_test</span><br><span class="line">└── hello.c</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// hello.c, gcc -o arg_test hello.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void print_arg(int arg1, int arg2, int arg3, int arg4, int arg5, int arg6,</span><br><span class="line">               int arg7, int arg8)&#123;</span><br><span class="line">    printf(&quot;%d, %d, %d, %d, %d, %d, %d, %d\n&quot;, arg1, arg2, arg3, arg4, arg5,</span><br><span class="line">           arg6, arg7, arg8);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    print_arg(1,2,3,4,5,6,7,8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// arg.bt</span><br><span class="line">#!/bin/bpftrace</span><br><span class="line"></span><br><span class="line">uprobe:./arg_test:print_arg</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;== enter print_arg\n&quot;);</span><br><span class="line">    printf(&quot;arg1: %d\n&quot;, arg0);</span><br><span class="line">    printf(&quot;arg2: %d\n&quot;, arg1);</span><br><span class="line">    printf(&quot;arg3: %d\n&quot;, arg2);</span><br><span class="line">    printf(&quot;arg4: %d\n&quot;, arg3);</span><br><span class="line">    printf(&quot;arg5: %d\n&quot;, arg4);</span><br><span class="line">    printf(&quot;arg6: %d\n&quot;, arg5);</span><br><span class="line">    printf(&quot;arg7: %d\n&quot;, sarg0);</span><br><span class="line">    printf(&quot;arg8: %d\n&quot;, sarg1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo bpftrace arg.bt</span><br><span class="line">Attaching 1 probe...</span><br><span class="line">== enter print_arg</span><br><span class="line">arg1: 1</span><br><span class="line">arg2: 2</span><br><span class="line">arg3: 3</span><br><span class="line">arg4: 4</span><br><span class="line">arg5: 5</span><br><span class="line">arg6: 6</span><br><span class="line">arg7: 7</span><br><span class="line">arg8: 8</span><br><span class="line"></span><br><span class="line">./arg_test</span><br></pre></td></tr></table></figure>

<h1 id="参照"><a href="#参照" class="headerlink" title="参照"></a>参照</h1><p><a href="https://wiki.cdot.senecacollege.ca/wiki/X86_64_Register_and_Instruction_Quick_Start">X86 64 Register and Instruction Quick Start</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>ebpf</tag>
      </tags>
  </entry>
  <entry>
    <title>shell-访问字符串同名变量</title>
    <url>/2019/06/04/cljb83dmh0039kcs61oqb0934/</url>
    <content><![CDATA[<p>考虑以下场景：<br>期望通过给定的变量名称<code>var_str</code>，打印出该名称对应的变量值<code>$&#123;var_str&#125;</code>。使用指令<code>eval</code>可以很方便的实现：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var_str=&quot;1213&quot;;</span><br><span class="line">ned_param_name=&quot;var_str&quot;;</span><br><span class="line">eval echo &#x27;$&#x27;&quot;$&#123;ned_param_name&#125;&quot;;</span><br></pre></td></tr></table></figure>
<p>输出结果为<code>1213</code>;</p>
<span id="more"></span>
<p><code>eval</code>命令解释如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval [arg ...]</span><br><span class="line">    The  args  are read and concatenated together into a single command. </span><br><span class="line">    This command is then read and executed by the shell, and its exit status is returned as</span><br><span class="line">the value of eval.  If there are no args, or only null arguments, eval returns 0.</span><br><span class="line">eval [参数 ...]</span><br><span class="line">    参数将会被读取并作为一个指令被读入。然后这个指令将会被shell读取并执行，执行结果</span><br><span class="line">将会作为eval的结果。如果没有参数传入，或者只有空参数，eval指令将会返回0。</span><br></pre></td></tr></table></figure>
<p>对于上述的例子，<code>echo $var_str</code>将会被读入，并被shell重新执行。输出结果为<code>1213</code>。该结果即作为<code>eval</code>的输出结果。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>无侵入观测服务拓扑四元组的一种实现</title>
    <url>/2023/03/29/cljb83dmh003dkcs61joe1kfh/</url>
    <content><![CDATA[<blockquote>
<p>最近有了些时间，继续整理下之前的项目。服务四元组的信息对于故障处置、根因定位等都有重要意义。使用eBPF可以做到无侵入用户代码获取服务四元组信息的功能。这一点在工程应用上很有意义。笔者在这方面投入了一些精力，这里做一下简单的总结。</p>
</blockquote>
<p>服务四元组指的是[caller, caller_func, callee, callee_func]四元组。如下图是一个调用示例，站在服务<code>A</code>的角度，就存在如下两个四元组: [A, /a, B, /b]，[A, /a, C, /c]。站在服务<code>B</code>, <code>C</code>的角度，也存在两个四元组（可能有不同的理解）: [B, /b, none, none], [C, /c, none, none]。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                  service call                  </span><br><span class="line">                                                </span><br><span class="line">,-------.          ,-.          ,-.          ,-.</span><br><span class="line">|outisde|          |A|          |B|          |C|</span><br><span class="line">`---+---&#x27;          `+&#x27;          `+&#x27;          `+&#x27;</span><br><span class="line">    |      /a       |            |            | </span><br><span class="line">    |--------------&gt;|            |            | </span><br><span class="line">    |               |            |            | </span><br><span class="line">    |               |    /b      |            | </span><br><span class="line">    |               |-----------&gt;|            | </span><br><span class="line">    |               |            |            | </span><br><span class="line">    |               |           /c            | </span><br><span class="line">    |               |------------------------&gt;| </span><br><span class="line">,---+---.          ,+.          ,+.          ,+.</span><br><span class="line">|outisde|          |A|          |B|          |C|</span><br><span class="line">`-------&#x27;          `-&#x27;          `-&#x27;          `-&#x27;</span><br></pre></td></tr></table></figure>

<p>在弄清楚四元组是什么之后，下面进入今天的话题：如何使用<code>BPF</code>来采集四元组。需要说明的是，笔者这里的语言使用的是<code>golang-1.16</code>。<code>golang</code>不同语言版本间的区别，见：<a href="https://liyan-ah.github.io/2023/03/03/golang-1-17-%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E7%BA%A6/#more">golang-1.17+调用规约</a>。<br>值得注意的是，关于观测服务数据，是有很多解决方案的。本文仅是笔者实践的一种解决方案，在文末会简单提到这种方案的优缺点。<br>按照惯例，先看下效果吧：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动采集</span><br><span class="line">bpftrace ./http.bt</span><br><span class="line">Attaching 2 probes...  # 未触发请求前，停止在这里</span><br><span class="line">caller:                # 触发请求后，输出</span><br><span class="line">  	caller_path: /handle</span><br><span class="line">callee:</span><br><span class="line">  	method: GET</span><br><span class="line">  	host: 0.0.0.0:9932</span><br><span class="line">  	url: /echo</span><br><span class="line">  </span><br><span class="line">caller:</span><br><span class="line">  	caller_path: /echo</span><br><span class="line">callee: none</span><br><span class="line">  </span><br><span class="line"># 开始服务</span><br><span class="line">./http_demo &amp;</span><br><span class="line"># 触发请求</span><br><span class="line">curl http://0.0.0.0:9932/handle</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h1 id="一段golang代码示例"><a href="#一段golang代码示例" class="headerlink" title="一段golang代码示例"></a>一段golang代码示例</h1><p>下面是一段<code>golang</code>的<code>http</code>服务的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;io/ioutil&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">	&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Resp struct &#123;</span><br><span class="line">	Errno  int    `json:&quot;errno&quot;`</span><br><span class="line">	Errmsg string `json:&quot;errmsg&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func echo(c *gin.Context) &#123;</span><br><span class="line">	c.JSON(http.StatusOK, &amp;Resp&#123;</span><br><span class="line">		Errno:  0,</span><br><span class="line">		Errmsg: &quot;ok&quot;,</span><br><span class="line">	&#125;)</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func handle(c *gin.Context) &#123;</span><br><span class="line">	client := http.Client&#123;&#125;</span><br><span class="line">	req, _ := http.NewRequest(http.MethodGet, &quot;http://0.0.0.0:9932/echo&quot;, nil)</span><br><span class="line">	resp, err := client.Do(req)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;failed to request&quot;, err.Error())</span><br><span class="line">		c.JSON(http.StatusOK, &amp;Resp&#123;</span><br><span class="line">			Errno:  1,</span><br><span class="line">			Errmsg: &quot;failed to request&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	respB, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;read resp failed&quot;)</span><br><span class="line">		c.JSON(http.StatusOK, &amp;Resp&#123;</span><br><span class="line">			Errno:  2,</span><br><span class="line">			Errmsg: &quot;failed to read request&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	defer resp.Body.Close()</span><br><span class="line">	fmt.Println(&quot;resp: &quot;, string(respB))</span><br><span class="line">	c.JSON(http.StatusOK, &amp;Resp&#123;</span><br><span class="line">		Errno:  0,</span><br><span class="line">		Errmsg: &quot;request okay&quot;,</span><br><span class="line">	&#125;)</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	s := http.Server&#123;</span><br><span class="line">		Addr: &quot;0.0.0.0:9932&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(&quot;/echo&quot;, echo)</span><br><span class="line">	r.GET(&quot;/handle&quot;, handle)</span><br><span class="line">	s.Handler = r</span><br><span class="line">	if err := s.ListenAndServe(); err != nil &#123;</span><br><span class="line">		fmt.Println(&quot;error, &quot;, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一段比较简单的<code>golang</code>代码。需要注意的是，这里的四元组是：[local, /handle, local, /echo]。为了便于示例说明，这里的<code>handle</code>的逻辑和请求下游的逻辑是串行的，没有开新的<code>goroutine</code>。这一点很重要，后面会说明。</p>
<h1 id="采集的逻辑"><a href="#采集的逻辑" class="headerlink" title="采集的逻辑"></a>采集的逻辑</h1><p>下面是采集的逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">type Request struct &#123;</span><br><span class="line">	Method string</span><br><span class="line">	URL *url.URL</span><br><span class="line">&#125;</span><br><span class="line">type URL struct &#123;</span><br><span class="line">	Scheme      string</span><br><span class="line">	Opaque      string    // encoded opaque data</span><br><span class="line">	User        *Userinfo // username and password information</span><br><span class="line">	Host        string    // host or host:port</span><br><span class="line">	Path        string    // path (relative paths may omit leading slash)</span><br><span class="line">	RawPath     string    // encoded path hint (see EscapedPath method)</span><br><span class="line">	ForceQuery  bool      // append a query (&#x27;?&#x27;) even if RawQuery is empty</span><br><span class="line">	RawQuery    string    // encoded query values, without &#x27;?&#x27;</span><br><span class="line">	Fragment    string    // fragment for references, without &#x27;#&#x27;</span><br><span class="line">	RawFragment string    // encoded fragment hint (see EscapedFragment method)</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">uprobe:./http_demo:net/http.serverHandler.ServeHTTP</span><br><span class="line">&#123;</span><br><span class="line">    $req_addr = sarg3;</span><br><span class="line"></span><br><span class="line">    $url_addr = *(uint64*)($req_addr+16);</span><br><span class="line"></span><br><span class="line">    $path_addr = *(uint64*)($url_addr+56);</span><br><span class="line">    $path_len  = *(uint64*)($url_addr+64);</span><br><span class="line"></span><br><span class="line">	// 在http请求触发处，依据pid将caller_func存储起来</span><br><span class="line">    @caller_path_addr[pid] = $path_addr;</span><br><span class="line">    @caller_path_len[pid]  = $path_len;</span><br><span class="line">    @callee_set[pid] = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">type Request struct &#123;</span><br><span class="line">	Method string</span><br><span class="line">	URL *url.URL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Client) do(req *Request) (retres *Response, reterr error) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">uprobe:./http_demo:&quot;net/http.(*Client).do&quot;</span><br><span class="line">&#123;</span><br><span class="line">	// 依据 pid 获取 caller 信息</span><br><span class="line">    printf(&quot;caller: \n  caller_path: %s\n&quot;,</span><br><span class="line">           str(@caller_path_addr[pid], @caller_path_len[pid]));</span><br><span class="line"></span><br><span class="line">    $req_addr = sarg1;</span><br><span class="line"></span><br><span class="line">	// 获取 callee 信息</span><br><span class="line">    $addr = *(uint64*)($req_addr);</span><br><span class="line">    $len  = *(uint64*)($req_addr + 8);</span><br><span class="line">    printf(&quot;callee: \n  method: %s\n&quot;, str($addr, $len));</span><br><span class="line"></span><br><span class="line">    $url_addr = *(uint64*)($req_addr + 16);</span><br><span class="line"></span><br><span class="line">    $addr = *(uint64*)($url_addr + 40);</span><br><span class="line">    $len  = *(uint64*)($url_addr + 48);</span><br><span class="line">    printf(&quot;  host: %s\n&quot;, str($addr, $len));</span><br><span class="line"></span><br><span class="line">    $addr = *(uint64*)($url_addr + 56);</span><br><span class="line">    $len  = *(uint64*)($url_addr + 64);</span><br><span class="line">    printf(&quot;  url: %s\n\n&quot;, str($addr, $len));</span><br><span class="line"></span><br><span class="line">    @callee_set[pid] = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./http_demo:&quot;net/http.(*response).finishRequest&quot;</span><br><span class="line">&#123;</span><br><span class="line">	// 如果没有下游请求，单独输出</span><br><span class="line">    if (@callee_set[pid] == 0)&#123;</span><br><span class="line">        printf(&quot;caller: \n  caller_path: %s\n&quot;,</span><br><span class="line">               str(@caller_path_addr[pid], @caller_path_len[pid]));</span><br><span class="line">        printf(&quot;callee: none\n\n&quot;);</span><br><span class="line">        @callee_set[pid] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里就基本上把主要思路介绍清楚了。需要说明的是，示例里使用的是<code>pid</code>作为<code>caller_map</code>里的<code>key</code>，当存在并发时，<code>pid</code>肯定是不够的。对于<code>golang</code>语言，可以使用<code>goid</code>作为<code>caller_map</code>的<code>key</code>。目前对于使用<code>golang</code>常规的使用来说，就足够了。引入<code>goid</code>的另一个问题是，业务代码里可能使用新的<code>goroutine</code>来进行<code>callee</code>的请求、处理。这里就需要引入<code>goroutine</code>的派生关系维护，或者<code>session trace</code>。关于<code>session trace</code>，可以参见<a href="https://liyan-ah.github.io/2022/11/25/%E5%9F%BA%E4%BA%8Eebpf%E5%AE%9E%E7%8E%B0%E7%9A%84gls/#more">基于ebpf实现的gls</a>这部分的逻辑，思路都是一致的。<br>但是<code>session trace</code>能够覆盖所有的场景么？看一下下面的逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var(</span><br><span class="line">	info = make(chan interface&#123;&#125;, 1000)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func handle(info chan interface&#123;&#125;)&#123;</span><br><span class="line">	for&#123;</span><br><span class="line">    	select&#123;</span><br><span class="line">    		case inf,ok &lt;- info:</span><br><span class="line">        	// do some request</span><br><span class="line">    		...</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Resp struct&#123;</span><br><span class="line">	Code int 	`json:&quot;code&quot;`</span><br><span class="line">    Msg string 	`json:&quot;msg&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Handler(ctx *gin.Context)&#123;</span><br><span class="line">	info &lt;- ctx</span><br><span class="line">    c.JSON(http.StatusOk, &amp;Resp&#123;Code: 0, Msg: &quot;okay&quot;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">	go handle(info)</span><br><span class="line">    // normal http register and start </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是一种<code>http</code>请求的处理方式，大抵的意思是对于每个请求，<code>handleFunc</code>并没有立即有效响应，而是通过<code>channel</code>将一部分的请求信息传递到其他<code>goroutine</code>里处理。这样虽然<code>callerFunc</code>的响应客观上触发了<code>callee</code>的请求，但是<code>handle()</code>所在的<code>goroutine</code>并不是<code>handleFunc</code>派生的。这种场景下，<code>trace</code>也就断掉了。同理，如果是开了<code>goroutine pool</code>来处理，也会丢失。  </p>
<h1 id="方案的优缺点"><a href="#方案的优缺点" class="headerlink" title="方案的优缺点"></a>方案的优缺点</h1><ol>
<li>优点。一如笔者在示例及<code>demo</code>中介绍的，对于方案<code>trace</code>能够覆盖的通信类型，<code>callerFunc, callee, calleeFunc</code>等的获取可以直接通过解析函数的参数来获取。对比基于<code>kprobe</code>的报文解析方案，即通过<code>hook tcp_send tcp_rcv</code>等来获取传输层报文，不需要进行复杂的报文解析。这就使得整个解析的触发次数接近<code>O(n)</code>，即一次<code>http</code>交互，一次<code>probe</code>的触发。此外，<code>hook kprobe</code>显然会对机器上所有会调用这个<code>kprobe</code>的进程造成影响，因为其他进程也会等待着调用<code>kprobe</code>。但是本方案里涉及的还仅是目标程序启动后的进程受到影响，并不会从调用角度来影响其他进程（但是<code>CPU</code>的抢占等是会产生轻微影响的）。</li>
<li>缺点。本方案的缺点同样很明显：它把语言及框架的依赖引入进来了。相对于<code>kprobe</code>可以直接面向协议进行解析，本方案需要考虑各种语言。同时，如果同一个语言中存在多种<code>http</code>的实现，也需要进行逐个适配。从这一角度而言，<code>golang</code>天然贴合本方案：其拥有官方统一维护的<code>net/http</code>库，同时，下游的请求方式也一并维护了。  </li>
</ol>
<p>以上是本次介绍的全部内容。在<code>ebpf</code>落地上，笔者还有很多内容需要探索，期望将来能够落地更多有价值的场景。周末愉快～</p>
]]></content>
      <categories>
        <category>code</category>
        <category>可观测</category>
      </categories>
      <tags>
        <tag>ebpf</tag>
        <tag>golang</tag>
        <tag>可观测</tag>
      </tags>
  </entry>
  <entry>
    <title>黑魔法--用 ebpf 构建用户空间数据的桥梁</title>
    <url>/2022/11/04/cljb83dmi003gkcs6bdo5h6fq/</url>
    <content><![CDATA[<p>在之前的示例中，仅涉及到<code>ebpf</code>对用户空间数据的读取。工程性较强的如：<a href="https://liyan-ah.github.io/2022/10/21/ebpf%E9%87%87%E9%9B%86mysql%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF%E5%8F%8Aebpf%E5%AF%B9%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E7%9A%84%E6%80%9D%E8%80%83/">ebpf采集mysql请求信息及ebpf对应用安全的思考</a>也仅是通过<code>urpobe</code>采集用户空间的数据。本文介绍点<code>ebpf</code>的“黑魔法”：将用户空间数据的读取、用户空间数据的写入结合起来，成为用户空间数据交互的桥梁。</p>
<span id="more"></span>

<h1 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h1><p>在看运行效果之前，需要先看下目标示例的代码以便更好的理解本文介绍的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// user/obj/obj.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var Len = 5</span><br><span class="line"></span><br><span class="line">// 预设的 uprobe</span><br><span class="line">//go:noinline</span><br><span class="line">func Set(info []byte) &#123;</span><br><span class="line">	fmt.Println(&quot;info: &quot;, string(info))</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 预设的 uprobe</span><br><span class="line">//go:noinline</span><br><span class="line">func Get(info []byte) []byte &#123;</span><br><span class="line">	fmt.Printf(&quot;info addr: %p\n&quot;, info)</span><br><span class="line">	fmt.Println(string(info))         // 请注意这里的输出操作</span><br><span class="line">	return info</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Third struct &#123;</span><br><span class="line">	Info string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t *Third) SetSomething(info string) &#123;</span><br><span class="line">	infoByt := []byte(info)</span><br><span class="line">	// 这里假设是个约束</span><br><span class="line">	infoByt = infoByt[:Len]</span><br><span class="line">	Set(infoByt)  // 在这里调用预设的处理函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t *Third) GetSomething() string &#123;</span><br><span class="line">	infoByt := make([]byte, Len, Len)</span><br><span class="line">	infoByt = Get(infoByt) // 在这里调用预设的处理函数</span><br><span class="line">	return string(infoByt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	third1 := Third&#123;&#125;</span><br><span class="line">	info := &quot;12345&quot;</span><br><span class="line">	third1.SetSomething(info)  // 请注意，这里进行写入的对象</span><br><span class="line"></span><br><span class="line">	/* very long handle logic, many goroutines or proces happend here */</span><br><span class="line"></span><br><span class="line">	third2 := Third&#123;&#125;</span><br><span class="line">    // 请注意，这里读取的对象和上述执行写入的对象是完全没有关系的</span><br><span class="line">	infoGet := third2.GetSomething()</span><br><span class="line">	fmt.Printf(&quot;after getInfo, [%s]\n&quot;, infoGet)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码非常简单，下面进行了两次执行来说明<code>ebpf</code>达到的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./obj  // 第一次，没有使用 ebpf 生效。代码的正常输出结果</span><br><span class="line">info:  12345</span><br><span class="line">info addr: 0xc0000180f0</span><br><span class="line">                         // 请注意这里</span><br><span class="line">after getInfo, []</span><br><span class="line"></span><br><span class="line">$ ./obj  // 第二次，开始执行前开启 ebpf 监听</span><br><span class="line">info:  12345</span><br><span class="line">info addr: 0xc0000180f0</span><br><span class="line">12345                    // 请注意这里</span><br><span class="line">after getInfo, [12345]</span><br></pre></td></tr></table></figure>

<p>请关注上述示例里的注释。通过<code>ebpf</code>的<code>attach</code>，实现了数据从用户空间-&gt;<code>ebpf</code>空间-&gt;用户空间，这个过程并不关心用户代码里发生了什么，<code>ebpf</code>只关注预设的<code>uprobe</code>是怎么被调用的。</p>
<h1 id="应用及思考"><a href="#应用及思考" class="headerlink" title="应用及思考"></a>应用及思考</h1><p><code>ebpf</code>的这个功能显然具有很广泛的应用，但是具体的应用就需要结合业务的应用来说明了（颇有一些拿着锤子找钉子的感觉），比如：结合调用了特定埋点<code>sdk</code>的使用，能够用来对<code>traceId</code>信息的补全。<br>事物自然都有两面性，<code>ebpf</code>提供了变更用户空间数据的潜力，自然就会带来风险：代码里的逻辑似乎不再靠谱了。而且，想象下将代码里的读操作，变更为删除操作，将会对用户空间的安全造成很大的破坏。</p>
<h1 id="ebpf-逻辑"><a href="#ebpf-逻辑" class="headerlink" title="ebpf 逻辑"></a>ebpf 逻辑</h1><p>之前一直是使用<code>bpftrace</code>来进行示例演示的，但是本文涉及的功能需要使用<code>long bpf_probe_write_user(void *dst, const void *src, u32 len)</code>这个<code>bpf-helper</code>函数。笔者没有找到<code>bpftrace</code>里的调用方式，因此采用<code>cilium-ebpf</code>来进行示例演示。其中涉及的主要<code>bpf</code>代码附在下面，基本表述了相对原生的<code>bpf-helper</code>的调用方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct&#123;</span><br><span class="line">    __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line">    __uint(key_size, sizeof(u32));</span><br><span class="line">    __uint(value_size, sizeof(u8)*5);</span><br><span class="line">    __uint(max_entries, 100);</span><br><span class="line">&#125; info_map SEC(&quot;.maps&quot;);</span><br><span class="line"></span><br><span class="line">struct event&#123;</span><br><span class="line">    u64 pid_tgid;</span><br><span class="line"></span><br><span class="line">    u8 info[5];  // 这里的成员长度，请结合 obj.go 来看</span><br><span class="line">    uintptr_t addr;</span><br><span class="line">    long res;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct event event_t;</span><br><span class="line">// Force emitting struct event into the ELF.</span><br><span class="line">const struct event *unused __attribute__((unused));</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">  __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);</span><br><span class="line">&#125; events SEC(&quot;.maps&quot;);</span><br><span class="line"></span><br><span class="line">SEC(&quot;uprobe/main_set&quot;)</span><br><span class="line">int uprobe__main_set(struct pt_regs *ctx)&#123;</span><br><span class="line">    uintptr_t info_p = 0;</span><br><span class="line">    u8 info[5];</span><br><span class="line">    u64 pid_tgid = bpf_get_current_pid_tgid();</span><br><span class="line"></span><br><span class="line">    SARG(ctx, 0, info_p);</span><br><span class="line"></span><br><span class="line">    bpf_probe_read(&amp;info, sizeof(info), (const void*)info_p);</span><br><span class="line">    u32 tgid = (u32)(pid_tgid &gt;&gt; 32);</span><br><span class="line">    bpf_map_update_elem(&amp;info_map, &amp;tgid, &amp;info, BPF_ANY);</span><br><span class="line"></span><br><span class="line">    event_t event = &#123;&#125;;</span><br><span class="line">    event.pid_tgid = pid_tgid;</span><br><span class="line">    memcpy(event.info, info, sizeof(info));</span><br><span class="line">    bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;event, sizeof(event));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(&quot;uprobe/main_get&quot;)</span><br><span class="line">int uprobe__main_get(struct pt_regs *ctx)&#123;</span><br><span class="line">    uintptr_t info_p = 0;</span><br><span class="line">    u64 pid_tgid = bpf_get_current_pid_tgid();</span><br><span class="line"></span><br><span class="line">    void* r_info_p = NULL;</span><br><span class="line">    u32 tgid = (u32)(pid_tgid &gt;&gt; 32);</span><br><span class="line">    r_info_p = bpf_map_lookup_elem(&amp;info_map, &amp;tgid);</span><br><span class="line">    if (r_info_p == NULL)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    event_t event = &#123;&#125;;</span><br><span class="line">    event.pid_tgid = pid_tgid;</span><br><span class="line"></span><br><span class="line">    SARG(ctx, 0, info_p);</span><br><span class="line"></span><br><span class="line">    u8 info[5];</span><br><span class="line">    memcpy(info, r_info_p, sizeof(info));</span><br><span class="line"></span><br><span class="line">    memcpy(event.info, info, sizeof(event.info));</span><br><span class="line"></span><br><span class="line">    event.res = bpf_probe_write_user((u8*)info_p, info, sizeof(info));</span><br><span class="line">    event.addr = info_p;</span><br><span class="line"></span><br><span class="line">    bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;event, sizeof(event));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，周末愉快。</p>
]]></content>
      <categories>
        <category>程序人生</category>
        <category>ebpf</category>
      </categories>
      <tags>
        <tag>ebpf</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>基于ebpf实现的gls</title>
    <url>/2022/11/25/cljb83dmi003jkcs6cvug6nsb/</url>
    <content><![CDATA[<blockquote>
<p>虽然<code>golang</code>并不推荐使用<code>goid</code>来构建<code>gls</code>(<code>goroutine local storage</code>)，仍然有着很多的实现<code>gls</code>并使用的尝试。<a href="https://github.com/jtolio/gls">github-gls</a>这里是一个常见的实现，基本表述了<code>golang</code>里<code>gls</code>的实现思路：获取<code>goid</code>，基于<code>goid</code>构建一个存储。本文中笔者尝试基于<code>ebpf</code>来构建一个<code>golang</code>的<code>gls</code>。</p>
</blockquote>
<h1 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h1><p>本文中基于<code>ebpf</code>实现的<code>gls</code>具有如下功能：  </p>
<ul>
<li>基于<code>goid</code>的存储。即<code>map[goid]=value</code>；</li>
<li>基于<code>goroutine</code>派生关系设置的<code>value</code>缺省值。即<code>map[goid=1]=121</code>，且<code>goid=1</code>派生<code>goid=2</code>，则<code>map[goid=2]=map[goid=1]=121</code>；<br>本文建议参照<a href="https://liyan-ah.github.io/2022/11/04/%E9%BB%91%E9%AD%94%E6%B3%95-ebpf-%E5%AF%B9%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%9A%84%E5%86%99%E5%85%A5/#more">黑魔法-ebpf-对用户空间数据的写入</a>进行理解。  <span id="more"></span></li>
</ul>
<h1 id="用户态代码及效果"><a href="#用户态代码及效果" class="headerlink" title="用户态代码及效果"></a>用户态代码及效果</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;strconv&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var Len = 5</span><br><span class="line"></span><br><span class="line">// 当 info 为空时，使用父 goid 设置的值，否则存入 info</span><br><span class="line">func Go1(ctx context.Context, info string, wg *sync.WaitGroup) &#123;</span><br><span class="line">	defer wg.Done()</span><br><span class="line">	third := Third&#123;&#125;</span><br><span class="line">	if info != &quot;&quot; &#123;</span><br><span class="line">		third.Store(info)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 诸多其他的逻辑 */</span><br><span class="line">    </span><br><span class="line">	info1 := third.Get()</span><br><span class="line">	fmt.Printf(&quot;raw info: [%s], info get: [%s]\n&quot;, info, info1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func Set(info []byte) &#123;</span><br><span class="line">	if len(info) &gt; Len &#123;</span><br><span class="line">		info = info[:Len]</span><br><span class="line">	&#125;</span><br><span class="line">	if len(info) &lt; Len &#123;</span><br><span class="line">		tmp := make([]byte, Len-len(info))</span><br><span class="line">		info = append(tmp, info...)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;info: &quot;, string(info))</span><br><span class="line"></span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func Get(info []byte) []byte &#123;</span><br><span class="line">	// alalalala, magic come</span><br><span class="line">	return info</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Third struct &#123;</span><br><span class="line">	Info string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t *Third) Store(info string) &#123;</span><br><span class="line">	infoByt := []byte(info)</span><br><span class="line">	// 这里假设是个约束</span><br><span class="line">	infoByt = infoByt[:Len]</span><br><span class="line">	Set(infoByt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t *Third) Get() string &#123;</span><br><span class="line">	infoByt := make([]byte, Len, Len)</span><br><span class="line">	infoByt = Get(infoByt)</span><br><span class="line">	return string(infoByt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	third1 := Third&#123;&#125;</span><br><span class="line">	info := &quot;12345&quot;</span><br><span class="line">	third1.Store(info)</span><br><span class="line">	wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	wg.Add(1)</span><br><span class="line">	go Go1(ctx, &quot;&quot;, wg) // 写入空数据，预期使用父 goid 数据，即 12345</span><br><span class="line">	for i := 1125; i &lt; 1130; i++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		v := strconv.Itoa(i)</span><br><span class="line">		if i%10 == 0 &#123;</span><br><span class="line">			v = &quot;&quot;</span><br><span class="line">		&#125;</span><br><span class="line">		go Go1(ctx, v, wg)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	/* very long handle logic*/</span><br><span class="line"></span><br><span class="line">	third2 := Third&#123;&#125;</span><br><span class="line">	infoGet := third2.Get()</span><br><span class="line">	fmt.Printf(&quot;in main, getInfo, [%s]\n&quot;, infoGet)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 未开启 bpf </span><br><span class="line">info:  12345</span><br><span class="line">info:  1129</span><br><span class="line">raw info: [1129], info get: []</span><br><span class="line">info:  1126</span><br><span class="line">raw info: [1126], info get: []</span><br><span class="line">info:  1128</span><br><span class="line">raw info: [1128], info get: []</span><br><span class="line">raw info: [], info get: []</span><br><span class="line">info:  1125</span><br><span class="line">info:  1127</span><br><span class="line">raw info: [1125], info get: []</span><br><span class="line">raw info: [1127], info get: []</span><br><span class="line">in main, getInfo, []</span><br><span class="line"></span><br><span class="line">// 开启 bpf</span><br><span class="line">info:  12345</span><br><span class="line">info:  1129</span><br><span class="line">raw info: [], info get: [12345]  // 传入空值，使用父 goid 存入数据</span><br><span class="line">raw info: [1129], info get: [1129]</span><br><span class="line">info:  1126</span><br><span class="line">raw info: [1126], info get: [1126]</span><br><span class="line">info:  1127</span><br><span class="line">raw info: [1127], info get: [1127]</span><br><span class="line">info:  1125</span><br><span class="line">raw info: [1125], info get: [1125]</span><br><span class="line">info:  1128</span><br><span class="line">raw info: [1128], info get: [1128]</span><br><span class="line">in main, getInfo, [12345]</span><br></pre></td></tr></table></figure>
<p>上述示例对比了开启<code>bpf</code>前后的用户态代码输出。可以看到，当子<code>goroutine</code>缺少某个信息时，可以获取父<code>goroutine</code>的数据作为缺省值。  </p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>意味着我们可以在父<code>goroutine</code>中存入我们需要的数据，而后无论是否创建新的<code>goroutine</code>，均能获取该信息。维护了<code>goroutine session</code>的数据。  </p>
<h1 id="ebpf-逻辑"><a href="#ebpf-逻辑" class="headerlink" title="ebpf 逻辑"></a>ebpf 逻辑</h1><p>这里仍然附上了<code>ebpf</code>的主要逻辑以便说明实现过程。除了之前文章中涉及的<code>ebpf</code>向用户态写入数据，本文使用了<code>golang</code>创建<code>goroutine</code>相关的<code>uprobe</code>来维护<code>goroutine session</code>状态。  </p>
<pre><code>struct &#123;
  __uint(type, BPF_MAP_TYPE_LRU_HASH);
  __uint(key_size, sizeof(u64));   // pid_tgid
  __uint(value_size, sizeof(u64)); // parent goid
  __uint(max_entries, MAX_ENTRIES);
&#125; go_goid_map SEC(&quot;.maps&quot;);  // 用来获取 goid 状态

struct &#123;
  __uint(type, BPF_MAP_TYPE_HASH);
  __uint(key_size, sizeof(u64));
  __uint(value_size, sizeof(u8) * 5);
  __uint(max_entries, 100);
&#125; info_map SEC(&quot;.maps&quot;);  // 用来存储 goid-&gt;info

struct &#123;
  __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);
&#125; events SEC(&quot;.maps&quot;);

static __always_inline u64 get_goid(u32 tgid, u32 pid) &#123;
  unsigned long task_addr = (unsigned long)bpf_get_current_task();
  unsigned long fsbase    = 0;
  unsigned long g         = 0;
  u64           goid      = 0;
  // 直接基于 偏移量进行处理了
  // offset(task_struct, thread) = 4992
  // offset(thread_struct, fsbase) = 40
  bpf_probe_read(&amp;fsbase, sizeof(fsbase),
                 (void *)(task_addr + OFF_TASK_THRD + OFF_THRD_FSBASE));
  bpf_probe_read(&amp;g, sizeof(g), (void *)(fsbase - 8));
  bpf_probe_read(&amp;goid, sizeof(goid), (void *)(g + GOID_OFFSET));
  return goid;
&#125;

SEC(&quot;uprobe/main_set&quot;)
int uprobe__main_set(struct pt_regs *ctx) &#123;
  uintptr_t info_p = 0;
  u8        info[5];
  u64       pid_tgid = bpf_get_current_pid_tgid();
  u32       pid      = (u32)(pid_tgid &amp; 0x00FF);
  u32       tgid     = (u32)(pid_tgid &gt;&gt; 32);
  u64       goid     = 0;

  goid = get_goid(tgid, pid);
  SARG(ctx, 0, info_p);

  bpf_probe_read(&amp;info, sizeof(info), (const void *)info_p);
  bpf_map_update_elem(&amp;info_map, &amp;goid, &amp;info, BPF_ANY);

  event_t event  = &#123;&#125;;
  event.pid_tgid = pid_tgid;
  memcpy(event.info, info, sizeof(info));
  bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;event, sizeof(event));

  return 0;
&#125;

SEC(&quot;uprobe/main_get&quot;)
int uprobe__main_get(struct pt_regs *ctx) &#123;
  uintptr_t info_p   = 0;
  u64       pid_tgid = bpf_get_current_pid_tgid();
  u32       pid      = (u32)(pid_tgid &amp; 0x00FF);
  u32       tgid     = (u32)(pid_tgid &gt;&gt; 32);
  u64       goid     = 0;

  goid = get_goid(tgid, pid);

  void *r_info_p = NULL;
  r_info_p       = bpf_map_lookup_elem(&amp;info_map, &amp;goid);
  if (r_info_p == NULL) &#123;
    return 0;
  &#125;
  event_t event  = &#123;&#125;;
  event.pid_tgid = pid_tgid;

  SARG(ctx, 0, info_p);

  u8 info[5];
  memcpy(info, r_info_p, sizeof(info));

  memcpy(event.info, info, sizeof(event.info));

  event.res  = bpf_probe_write_user((u8 *)info_p, info, sizeof(info));
  event.addr = info_p;

  bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;event, sizeof(event));
  return 0;
&#125;

/* golang_runtime_newproc1
   func newproc1(fn *funcval, argp unsafe.Pointer, narg int32, callergp *g,
 callerpc uintptr) *g &#123;
*/
SEC(&quot;uprobe/golang_runtime_newproc1&quot;)
int uprobe__golang_runtime_newproc1(struct pt_regs *ctx) &#123;
  u64       pid_tgid = bpf_get_current_pid_tgid();
  uintptr_t g_addr   = 0;
  u64       cur_goid = 0;

  SARG(ctx, 3, g_addr);
  bpf_probe_read(&amp;cur_goid, sizeof(cur_goid), (void *)(g_addr + GOID_OFFSET));
  bpf_map_update_elem(&amp;go_goid_map, &amp;pid_tgid, &amp;cur_goid, BPF_ANY);
  return 0;
&#125;

SEC(&quot;uprobe/golang_runtime_runqput&quot;)
int uprobe__golang_runtime_runqput(struct pt_regs *ctx) &#123;
  u64       pid_tgid    = bpf_get_current_pid_tgid();
  uintptr_t g_addr      = 0;
  u64      *parent_goid = NULL;
  u64       child_goid  = 0;
  void     *v_p         = NULL;

  parent_goid = bpf_map_lookup_elem(&amp;go_goid_map, &amp;pid_tgid);
  if (parent_goid == NULL) &#123;
    return 0;
  &#125;

  // 1. 获取新 goroutine 的 goid
  SARG(ctx, 1, g_addr);
  bpf_probe_read(&amp;child_goid, sizeof(child_goid),
                 (void *)(g_addr + GOID_OFFSET));

  // 2. 设置新 goid 绑定的 caller 信息
  v_p = bpf_map_lookup_elem(&amp;info_map, parent_goid);
  if (v_p == NULL) &#123;
    return 0;
  &#125;
  // 设置子 goid 绑定 caller 为 父 goid 信息
  bpf_map_update_elem(&amp;info_map, &amp;child_goid, v_p, BPF_ANY);

  bpf_map_delete_elem(&amp;go_goid_map, &amp;pid_tgid);
  return 0;
&#125;
</code></pre>
<p>以上。</p>
]]></content>
      <categories>
        <category>code life</category>
      </categories>
      <tags>
        <tag>ebpf</tag>
        <tag>golang</tag>
        <tag>code</tag>
        <tag>gls</tag>
      </tags>
  </entry>
  <entry>
    <title>让emacs在保存文件时自动格式化代码</title>
    <url>/2022/07/15/cljb83dmj003nkcs631e0dp4e/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://liam.page/">liam</a>同学在<a href="https://liam.page/2020/11/04/Vim-auto-format-codes-on-save/">让 Vim 在保存文件时自动格式化代码</a>一文中展示了保存时自动化格式代码的<code>vim</code>配置。作为<code>emacs</code>用户，自然有自己的解决方案。以下呈现。</p>
</blockquote>
<span id="more"></span>

<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><code>emacs</code>进行<code>c/c++</code>的开发，离不开支持代码自动补全、库函数联想等功能，所以本文顺带把<a href="https://microsoft.github.io/language-server-protocol/"><code>lsp</code></a>配置也一并带上了，不同于<a href="https://blacker1230.github.io/2021/10/12/emacs-%E8%8B%A5%E5%B9%B2%E8%AF%AD%E8%A8%80-lsp-%E9%85%8D%E7%BD%AE%E5%A4%87%E6%B3%A8/">emacs-若干语言 lsp 配置备注</a>里的<code>eglot</code>，这里使用的是<code>ccls</code>。直接上配置吧，比较简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;; 使用国内 elpa 源来加速插件安装</span><br><span class="line">(defun w-install(pkg)</span><br><span class="line">  ;; would be a wrapper for package-install</span><br><span class="line">  (require &#x27;package)</span><br><span class="line">  (setq package-archives</span><br><span class="line">	&#x27;((&quot;gnu&quot;   . &quot;http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/&quot;)</span><br><span class="line">	   (&quot;melpa&quot; . &quot;http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/&quot;)))</span><br><span class="line">  (package-initialize)</span><br><span class="line">  (package-refresh-contents)</span><br><span class="line">  (unless (package-installed-p pkg)</span><br><span class="line">    (package-install pkg)))</span><br><span class="line"></span><br><span class="line">;; 辅助判断插件安装通用函数</span><br><span class="line">(defun ensure-package-installed (&amp;rest packages)</span><br><span class="line">  &quot;Assure every package was installed, ask for installation if it&#x27;s not.</span><br><span class="line">a list of installed packages or nil for every skipped package.&quot;</span><br><span class="line">  (mapcar</span><br><span class="line">   (lambda (package)</span><br><span class="line">          (if (package-installed-p package)</span><br><span class="line">              nil</span><br><span class="line">            (if (y-or-n-p (format &quot;Package %s is missing. Install it?&quot; package))</span><br><span class="line">                (w-install package)</span><br><span class="line">              package)))</span><br><span class="line">   packages))</span><br><span class="line"></span><br><span class="line">;; clang-format 在文件保存时格式化代码</span><br><span class="line">(ensure-package-installed &#x27;clang-format)</span><br><span class="line">(defun clang-format-on-save-hook()</span><br><span class="line">  &quot;Create a buffer local save hook.&quot;</span><br><span class="line">  (add-hook &#x27;before-save-hook</span><br><span class="line">            (lambda ()</span><br><span class="line">              (when (locate-dominating-file &quot;.&quot; &quot;.clang-format&quot;)</span><br><span class="line">                (clang-format-buffer))</span><br><span class="line">              ;; Continue to save</span><br><span class="line">              nil)</span><br><span class="line">            nil</span><br><span class="line">            ;; Buffer local hook.</span><br><span class="line">            t))</span><br><span class="line"></span><br><span class="line">;; Run this hook for c-mode-hook and c++-mode-hook</span><br><span class="line">(add-hook &#x27;c-mode-hook   (lambda () (clang-format-on-save-hook)))</span><br><span class="line">(add-hook &#x27;c++-mode-hook (lambda () (clang-format-on-save-hook)))</span><br><span class="line">;; create default clang-format file</span><br><span class="line">;; https://releases.llvm.org/3.6.2/tools/docs/ClangFormatStyleOptions.html</span><br><span class="line">;; clang-format -style=llvm -dump-config &gt; .clang-format</span><br><span class="line"></span><br><span class="line">;; 另外，这里列出使用的 lsp-language-server 配置。</span><br><span class="line">;; 服务端使用 ccls，客户端则使用 ccls.el。同时将 ccls 作为 c-mode 的hook运行</span><br><span class="line">;; https://github.com/MaskRay/ccls/wiki/Build</span><br><span class="line">;; set up lsp-mode for c/c++</span><br><span class="line">(ensure-package-installed &#x27;ccls)</span><br><span class="line">(use-package ccls</span><br><span class="line">  :hook ((c-mode c++-mode objc-mode cuda-mode) .</span><br><span class="line">         (lambda() (require &#x27;ccls) (lsp))))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码格式部分则主要由<code>.clang-format</code>文件控制。其配置方法可以参见官网：<a href="https://clang.llvm.org/docs/ClangFormat.html">ClangFormat</a>。</p>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>emacs</tag>
        <tag>lsp</tag>
        <tag>c-mode</tag>
        <tag>clang-format</tag>
      </tags>
  </entry>
  <entry>
    <title>BPF追踪Go程序的挑战</title>
    <url>/2023/06/25/cljb83dne006tkcs6dms6f3u0/</url>
    <content><![CDATA[<blockquote>
<p>原文地址<a href="https://blog.0x74696d.com/posts/challenges-of-bpf-tracing-go/">Challenges of BPF Tracing Go</a>。翻译不尽如人意，继续努力。</p>
</blockquote>
<h1 id="BPF追踪Go程序的挑战"><a href="#BPF追踪Go程序的挑战" class="headerlink" title="BPF追踪Go程序的挑战"></a>BPF追踪Go程序的挑战</h1><p>当大家对<code>Go 1.17</code>语言调用规约(<code>function calling convention</code>)调整带来的性能优化感到兴奋时，我却遗憾的看到<code>Go 1.17</code>并没有让<code>BPF uretprobe</code>变得可行。事实证明，我还没有完全意识到<code>Go</code>的可调整的栈空间会让事情变得多复杂。</p>
<span id="more"></span>

<p><code>Go</code>极短的编译时间使得“输出调试”变得非常便捷。当你知道问题处在一个特定的变量时，往往会随手塞入一个<code>fmt.Printf</code>或者<code>log.Debug</code>或者<code>spew.Dump</code>来观察感兴趣的点。但是我经常工作在一个有状态的系统中，在这样的环境下“输出调试”变<br>得非常受限。重新编入一个<code>log</code>语句并且重启系统，往往意味着丢失掉可能导致异常的状态，并且日志输出可能会带来性能开销并掩盖掉<code>bug</code>。在这种背景下，我选择<code>BPF</code>工具，比如<code>bpftrace</code>，来定位问题。</p>
<p>对应用程序开发者而言，<code>BPF</code>的一大强力功能是用户态的动态程序观测，在<code>uprobe</code>及<code>uretprobe</code>的基础上构建起来。<code>uprobe</code>会嵌入一个<code>BPF</code>探针在函数被调用的地方，<code>uretprobe</code>则会嵌入一个探针在函数返回的地方。</p>
<p>比如，这里是一个使用<code>C</code>语言写的程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sum(int a, int b)&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用如下的<code>bpftrace</code>程序可以输出上述程序的参数及返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env bpftrace</span><br><span class="line"></span><br><span class="line">uprobe:./sum:&quot;sum&quot;</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;args: %d + %d\n&quot;, arg0, arg1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uretprobe:./sum:&quot;sum&quot;</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;result: %d\n&quot;, reg(&quot;ax&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们运行这个<code>bptrace</code>脚本是，它会等待我们在另一个终端运行目标<code>C</code>程序，然后输出如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo ./sum.bt</span><br><span class="line">Attaching 2 probes...</span><br><span class="line">args: 2 + 3</span><br><span class="line">result: 5</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>

<p>对于一个有状态的服务来说是这是一种不可思议的强力功能，因为你可以将这些探针附加在一个运行中的程序而不需重新编译它，并且几乎不会带来性能损失。这种思想诞生在<a href="http://dtrace.org/blogs/about/">DTrace</a>，而后由<code>BPF</code>将这种观测能力<br>移植到<code>Linux</code>中。</p>
<p>但是<code>Go</code>在<code>1.17</code>之前的调用规约(<code>calling convention</code>)使得<code>Go</code>的追踪变得复杂。在<a href="https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI">System V AMD64调用规约</a>中，函数入参及返回值均通<br>寄存器传递。<code>BPF</code>的工具也假定编译器会遵循这一规约，但是<code>Go</code>没有。不同的是，<code>Go</code>遵循<code>Plan9</code>的调用规约，即通过栈来传递参数。返回值也会通过出栈来返回。</p>
<p>对于<code>uprobe</code>而言这意味着我们不能遵循AMD64调用规约，使用<code>arg</code>参数来将寄存器里的参数读出。与此相对应的是，我们需要从栈里将参数读出来。从栈里读参会比较繁琐，因为你需要获取栈帧(<code>stack pointer</code>)，从中读取参数地址，然后读取地址里<br>的参数。在<code>bpftrace-0.9.3</code>里，这些操作被封装成了<a href="https://github.com/iovisor/bpftrace/issues/740">sargx</a>，所以还不算特别糟。</p>
<p>但是对于<code>uretprobe</code>就不一样了。不同于每个<code>goroutine</code>使用一个线程，<code>Go</code>的是多个<code>goroutine</code>对应多个线程的（”M:N调度”）。所以不同于每个线程拥有2MB的栈空间，每个goroutine只有被goroutine自己维护而非操作系统维护的，短短的<br>2KB的栈空间。当程序需要为一个<code>goroutine</code>增加栈空间并且当前空间内没有足够多的空余时，运行时会将整个<code>goroutine</code>的栈拷贝到另外一个有足够多空间用来扩展的内存空间中。</p>
<p>当你配置<a href="https://github.com/torvalds/linux/blob/v5.8/kernel/events/uprobes.c#L1861-L1925">uretprobe</a>时，内核也会创建一个拥有返回探针处理的<code>uprobe</code>。当这个<code>uprobe</code>触发时，它会劫持返回地址并且使用一个中断<br>的“跳转地址”(tramponline)来替代它。</p>
<p>如果这个地址在<code>uprobe</code>触发时被移动了，返回地址将不再有效，所以一个<code>uretprobe</code>将会读取其他地方的内存。这将会使得程序崩溃。</p>
<p>为了解决这个问题，你需要从程序的入口处使用<code>uprobe</code>来追踪程序调用，然后记录函数每个<code>return</code>点的偏移信息。这显得格外的粗暴并且涉及二进制信息的反汇编。</p>
<p>你大概不会花费一整天来学习汇编，我当然也不会。所以让我们快速的来看下如何读取<code>go</code>反汇编后的内容。假设这是我们的程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func swap(x, y string) (string, string) &#123;</span><br><span class="line">	return y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	args := os.Args</span><br><span class="line">	if len(args) &lt; 3 &#123;</span><br><span class="line">		panic(&quot;needs 2 args&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	a, b := swap(args[1], args[2])</span><br><span class="line">	fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这段程序比较简短，<code>Go</code>可能会把<code>swap</code>函数进行内联。为了能够说明问题，我们将会使用<code>go build -gcflags &#39;-l&#39; -o swapper .</code>进行编译以防止内联。</p>
<p>首先我们使用<code>GDB</code>来反汇编程序。你当然也可以使用<code>objdump</code>来进行，但是这里我们希望能够多获取些内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gdb --args ./swapper hello go</span><br><span class="line">...</span><br><span class="line">Reading symbols from ./swapper...</span><br><span class="line">Loading Go Runtime support.</span><br><span class="line">(gdb) b main.swap</span><br><span class="line">Breakpoint 1 at 0x497800: file /home/tim/swapper/main.go, line 9</span><br><span class="line">.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/tim/swapper/swapper hello world</span><br><span class="line">[New LWP 3413956]</span><br><span class="line">[New LWP 3413957]</span><br><span class="line">[New LWP 3413958]</span><br><span class="line">[New LWP 3413959]</span><br><span class="line">[New LWP 3413960]</span><br><span class="line"></span><br><span class="line">Thread 1 &quot;swapper&quot; hit Breakpoint 1, main.swap (x=..., y=..., ~r2=..., ~r3=...)</span><br><span class="line">    at /home/tim/swapper/main.go:9</span><br><span class="line">9               return y, x</span><br><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function main.swap:</span><br><span class="line">=&gt; 0x0000000000497800 &lt;+0&gt;:     mov    rax,QWORD PTR [rsp+0x18]</span><br><span class="line">   0x0000000000497805 &lt;+5&gt;:     mov    QWORD PTR [rsp+0x28],rax</span><br><span class="line">   0x000000000049780a &lt;+10&gt;:    mov    rax,QWORD PTR [rsp+0x20]</span><br><span class="line">   0x000000000049780f &lt;+15&gt;:    mov    QWORD PTR [rsp+0x30],rax</span><br><span class="line">   0x0000000000497814 &lt;+20&gt;:    mov    rax,QWORD PTR [rsp+0x8]</span><br><span class="line">   0x0000000000497819 &lt;+25&gt;:    mov    QWORD PTR [rsp+0x38],rax</span><br><span class="line">   0x000000000049781e &lt;+30&gt;:    mov    rax,QWORD PTR [rsp+0x10]</span><br><span class="line">   0x0000000000497823 &lt;+35&gt;:    mov    QWORD PTR [rsp+0x40],rax</span><br><span class="line">   0x0000000000497828 &lt;+40&gt;:    ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>总的来看，我们有4个指针需要移动：每个<code>string</code>都有一个长度以及一段字节码，并且我们有两个<code>string</code>。函数将指针重新排列在栈上，并且当函数返回时，这些值会从栈上弹出。</p>
<p>第一个指令是将栈帧上偏移量为<code>0x18</code>的值移动到暂存寄存器<code>rax</code>。让我们查看下这个地址，然后看看它是否是一个可读的<code>string</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/a $rsp+0x18</span><br><span class="line">0xc00011af18:   0x7fffffffddcd</span><br><span class="line">(gdb) x/s 0x7fffffffddcd</span><br><span class="line">0x7fffffffddcd: &quot;go&quot;</span><br></pre></td></tr></table></figure>

<p>妙啊！所以第一个指令的意思是，我们将值喜庆<code>string</code>的64-bit的指针(<code>QWORD PTR</code>)赋给了暂存寄存器。下一个指令是将同一个指针从暂存区移动到栈顶(rsp+0x28)。</p>
<p>下一个指令是将<code>0x20</code>上的任意值移动到暂存区。这是个整数：我们字符串的长度！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/a $rsp+0x20</span><br><span class="line">0xc00011af20:   0x2</span><br></pre></td></tr></table></figure>

<p>然后这个整数就被从暂存区移动到栈顶(rsp+0x30)。接下来的四个指令对另外两个参数做了相同的事情：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/a $rsp+0x8</span><br><span class="line">0xc00011af08:   0x7fffffffddc7</span><br><span class="line">(gdb) x/s 0x7fffffffddc7</span><br><span class="line">0x7fffffffddc7: &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">(gdb) x/a $rsp+0x10</span><br><span class="line">0xc00011af10:   0x5</span><br></pre></td></tr></table></figure>

<p>我们单步执行(<code>si</code>)8次，直到来到<code>ret</code>指令处：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">(gdb) si</span><br><span class="line">0x0000000000497828 in main.swap (x=..., y=..., ~r2=..., ~r3=...)</span><br><span class="line">    at /home/tim/swapper/main.go:9</span><br><span class="line">9               return y, x</span><br><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function main.swap:</span><br><span class="line">   0x0000000000497800 &lt;+0&gt;:     mov    rax,QWORD PTR [rsp+0x18]</span><br><span class="line">   0x0000000000497805 &lt;+5&gt;:     mov    QWORD PTR [rsp+0x28],rax</span><br><span class="line">   0x000000000049780a &lt;+10&gt;:    mov    rax,QWORD PTR [rsp+0x20]</span><br><span class="line">   0x000000000049780f &lt;+15&gt;:    mov    QWORD PTR [rsp+0x30],rax</span><br><span class="line">   0x0000000000497814 &lt;+20&gt;:    mov    rax,QWORD PTR [rsp+0x8]</span><br><span class="line">   0x0000000000497819 &lt;+25&gt;:    mov    QWORD PTR [rsp+0x38],rax</span><br><span class="line">   0x000000000049781e &lt;+30&gt;:    mov    rax,QWORD PTR [rsp+0x10]</span><br><span class="line">   0x0000000000497823 &lt;+35&gt;:    mov    QWORD PTR [rsp+0x40],rax</span><br><span class="line">=&gt; 0x0000000000497828 &lt;+40&gt;:    ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>函数已经完成了所有的功能，并且我们来到了这个函数将会返回给调用者的地方。现在我们可以确认下栈顶的内存地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/a $rsp+0x40</span><br><span class="line">0xc00011af40:   0x5</span><br><span class="line">(gdb) x/a $rsp+0x38</span><br><span class="line">0xc00011af38:   0x7fffffffddc7</span><br><span class="line">(gdb) x/s  0x7fffffffddc7</span><br><span class="line">0x7fffffffddc7: &quot;hello&quot;</span><br></pre></td></tr></table></figure>

<p>此时，我们可以看到我们已经将返回值移动到距离栈顶一定偏移量的指针上，而指针指向字符串。因为是在栈上，所以是“后进先出”的。这里可能会有些困惑因为函数的主要功能是交换这两个字符串。</p>
<p>如果你跟上了我的思路，自然的就能画出这样的分布：<br><img src="/images/stack.png" alt="upload successful"></p>
<p>如何将我们所学的内容应用到BPF呢？</p>
<p>首先，我们知道了尽管<code>Go</code>函数仅定义了两个参数，但实际上栈上有四个参数。所以我们需要定义两组栈上的参数。我们可以将它们正确的通过<code>bpftrace</code>里的<code>str</code>函数：<code>bpftrace:str(sarg0, sarg1)</code>来输出<code>x</code>，<code>str(sarg2, sarg3)</code>来<br>输出<code>y</code>。</p>
<p>然后，尽管<code>uretprobe</code>无法工作，我们可以通过添加一个指向<code>return</code>指令偏移量的<code>uprobe</code>来模拟它。如果你再看下汇编指令，就能看到这个偏移地址是<code>+40</code>。所以<code>uprobe</code>最终看起来<br>是：<code>uprobe:./bin/swapper:&quot;main.swap&quot;+40</code>。当我们触发这个探针时，我们仅查看返回值寄存器无法满足目标。我们需要检查上述发现的每个返回值的偏移地址。最终的<code>bpftrace</code>程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env bpftrace</span><br><span class="line"></span><br><span class="line">uprobe:./swapper:&quot;main.swap&quot;</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;swapping \&quot;%s\&quot; and \&quot;%s\&quot;\n&quot;,</span><br><span class="line">        str(sarg0, sarg1), str(sarg2, sarg3));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./swapper:&quot;main.swap&quot;+40</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;results: \&quot;%s\&quot; and \&quot;%s\&quot;\n&quot;,</span><br><span class="line">        str(*(reg(&quot;sp&quot;)+0x28), *(reg(&quot;sp&quot;)+0x30)),</span><br><span class="line">        str(*(reg(&quot;sp&quot;)+0x38), *(reg(&quot;sp&quot;)+0x40))</span><br><span class="line">        )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在一个终端运行这段代码，在另一个终端运行<code>./swapper hello world</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo ./swapper.bt</span><br><span class="line">Attaching 2 probes...</span><br><span class="line">swapping &quot;hello&quot; and &quot;go&quot;</span><br><span class="line">results: &quot;go&quot; and &quot;hello&quot;</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>

<p>如你所见，仅一个<code>return probe</code>就需要做很多的准备。如果我们的程序有很多的返回点，我们不得不为每个返回点都做一次相同的事情。</p>
<p>对于一些复杂的函数，如<code>Nomad</code>的<code>FSM</code> <a href="https://github.com/hashicorp/nomad/blob/v1.1.4/nomad/fsm.go#L193-L322">Apply</a>方法，我不得不采用如下方式生成<code>bpftrace</code>代码的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF</span><br><span class="line">#!/usr/bin/env bpftrace</span><br><span class="line">/*</span><br><span class="line">Get Nomad FSM.Apply latency</span><br><span class="line">Note: using sarg with offsets isn&#x27;t really concurrency safe and emits a warning</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">base=$(objdump --disassemble=&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot; \</span><br><span class="line">               -Mintel -S ./bin/nomad \</span><br><span class="line">               | awk &#x27;/hashicorp/&#123;print $1&#125;&#x27; \</span><br><span class="line">               | head -1)</span><br><span class="line"></span><br><span class="line">objdump --disassemble=&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot; \</span><br><span class="line">        -Mintel -S ./bin/nomad \</span><br><span class="line">        | awk -F&#x27; |:&#x27; &#x27;/ret/&#123;print $2&#125;&#x27; \</span><br><span class="line">        | xargs -I % \</span><br><span class="line">        python3 -c &quot;print(&#x27;uprobe:./bin/nomad:\&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply\&quot;+&#x27; + hex(0x% - 0x$base))</span><br><span class="line">print(&#x27;&#123;&#x27;)</span><br><span class="line">print(&#x27;  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);&#x27;)</span><br><span class="line">print(&#x27;  delete(@start[str(*sarg1)]);&#x27;)</span><br><span class="line">print(&#x27;&#125;&#x27;)</span><br><span class="line">print(&#x27;&#x27;)</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure>

<p>这样就得到了下面近300行的庞然大物：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env bpftrace</span><br><span class="line">/*</span><br><span class="line">Get Nomad FSM.Apply latency</span><br><span class="line">Note: using sarg with offsets isn&#x27;t really concurrency safe and emits a warning</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x1d3</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x257</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x2f3</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x377</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x3fb</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x49b</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x51b</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x5a0</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x634</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x6b4</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x738</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x7e7</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x86e</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x8ee</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x982</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0xa06</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0xa8e</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0xb27</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0xbae</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0xc2e</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0xcc2</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0xd46</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0xdce</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0xe77</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0xefb</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0xf80</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x1014</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x1098</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x111c</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x11b7</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x123b</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x12c0</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x1350</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x13d0</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x1450</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x14f7</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x1577</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x15f7</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x168f</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x170f</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x178f</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x18ca</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x1948</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x19ce</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x1a52</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x1a6d</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x1b07</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x1b87</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./bin/nomad:&quot;github.com/hashicorp/nomad/nomad.(*nomadFSM).Apply&quot;+0x1c0e</span><br><span class="line">&#123;</span><br><span class="line">  @usecs = hist((nsecs - @start[str(*sarg1)]) / 1000);</span><br><span class="line">  delete(@start[str(*sarg1)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>Go 1.17</code>引入的新的调用规约使得这种情况得到改善，但是仍没有解决<code>uretprobe</code>的问题。相同的<code>swapper</code>代码在<code>Go 1.17</code>上将会反汇编成如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function main.swap:</span><br><span class="line">=&gt; 0x000000000047e260 &lt;+0&gt;:     mov    QWORD PTR [rsp+0x8],rax</span><br><span class="line">   0x000000000047e265 &lt;+5&gt;:     mov    QWORD PTR [rsp+0x18],rcx</span><br><span class="line">   0x000000000047e26a &lt;+10&gt;:    mov    rdx,rax</span><br><span class="line">   0x000000000047e26d &lt;+13&gt;:    mov    rax,rcx</span><br><span class="line">   0x000000000047e270 &lt;+16&gt;:    mov    rsi,rbx</span><br><span class="line">   0x000000000047e273 &lt;+19&gt;:    mov    rbx,rdi</span><br><span class="line">   0x000000000047e276 &lt;+22&gt;:    mov    rcx,rdx</span><br><span class="line">   0x000000000047e279 &lt;+25&gt;:    mov    rdi,rsi</span><br><span class="line">   0x000000000047e27c &lt;+28&gt;:    ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>所有的值传递操作都通过寄存器进行了，减少了指针寻址的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/s $rax</span><br><span class="line">0x7fffffffddca: &quot;hello&quot;</span><br><span class="line">(gdb) i r $rbx</span><br><span class="line">rbx            0x5                 5</span><br><span class="line">(gdb) x/s $rcx</span><br><span class="line">0x7fffffffddd0: &quot;go&quot;</span><br><span class="line">(gdb) i r $rdi</span><br><span class="line">rdi            0x2                 2</span><br></pre></td></tr></table></figure>

<p>（我确实不知道为什么第二个参数的长度存储在<code>rdi</code>而非<code>rdx</code>，如果你知道的话，我很乐意知晓下）（译者按：参见<a href="https://liyan-ah.github.io/2023/03/03/golang-1-17-%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E7%BA%A6/#more">golang-1.17参数调用规约</a>）。</p>
<p>返回值也放到了寄存器里，这意味着我们可以通过<code>uretprobe</code>来直接获取。我们的<code>bpftrace</code>程序变得简洁了许多：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env bpftrace</span><br><span class="line"></span><br><span class="line">uprobe:./swapper:&quot;main.swap&quot;</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;swapping \&quot;%s\&quot; and \&quot;%s\&quot;\n&quot;,</span><br><span class="line">      str(reg(&quot;ax&quot;)), str(reg(&quot;cx&quot;)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uretprobe:./swapper:&quot;main.swap&quot;</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;results: \&quot;%s\&quot; and \&quot;%s\&quot;\n&quot;,</span><br><span class="line">      str(reg(&quot;ax&quot;)), str(reg(&quot;cx&quot;)));</span><br><span class="line">&#125;</span><br><span class="line">$ sudo ./swapper.bt</span><br><span class="line">Attaching 2 probes...</span><br><span class="line">swapping &quot;hello&quot; and &quot;go&quot;</span><br><span class="line">results: &quot;go&quot; and &quot;hello&quot;</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>


<p>所以问题是什么？这样不是很好么？目前为止，我们关注的示例都没有需要很多栈空间以至于运行时需要对栈进行调整。而运行时的调整是<code>uretprobe</code>失败的原因。  </p>
<p>看下下面的示例。<code>temp</code>变量从没有逃逸到对上（我们可以通过添加<code>-gcflags -m</code>进行编译以验证这一点），所以我们需要在<code>goroutine</code>栈上申请<code>sizeof(Example)*count</code>大小的空间。如果我们执行<code>./stacker 1000000</code>，将会申请<br>多余能够提供的空闲内存，<code>Go</code>的运行时将不得不移动栈空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;os&quot;</span><br><span class="line">	&quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Example struct &#123;</span><br><span class="line">	ID   int</span><br><span class="line">	Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func stacker(count int) string &#123;</span><br><span class="line">	var result int</span><br><span class="line">	for i := 0; i &lt; count; i++ &#123;</span><br><span class="line">		temp := Example&#123;ID: i * 2, Name: fmt.Sprintf(&quot;%d&quot;, result)&#125;</span><br><span class="line">		result += temp.ID</span><br><span class="line">	&#125;</span><br><span class="line">	s := fmt.Sprintf(&quot;hello: %d&quot;, result)</span><br><span class="line">	return s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	args := os.Args</span><br><span class="line">	if len(args) &lt; 2 &#123;</span><br><span class="line">		panic(&quot;needs 1 arg&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	count, err := strconv.Atoi(args[1])</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		panic(&quot;arg needs to be a number&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s := stacker(count)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是我们的<code>bpftrace</code>程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env bpftrace</span><br><span class="line"></span><br><span class="line">uretprobe:./stacker:&quot;main.stacker&quot;</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;result: \&quot;%s\&quot;\n&quot;, str(reg(&quot;ax&quot;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们在<code>uretprobe</code>加载的同时，给<code>stacker</code>一个巨大的参数<code>count</code>，程序将会崩溃！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./stacker 1000000</span><br><span class="line">runtime: unexpected return pc for main.stacker called from 0x7fffffffe000</span><br><span class="line">stack: frame=&#123;sp:0xc000074ef0, fp:0xc000074f48&#125; stack=[0xc000074000,0xc000075000)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<p>这里是崩溃时完整的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./stacker 1000000</span><br><span class="line">runtime: unexpected return pc for main.stacker called from 0x7fffffffe000</span><br><span class="line">stack: frame=&#123;sp:0xc000074ef0, fp:0xc000074f48&#125; stack=[0xc000074000,0xc000075000)</span><br><span class="line">0x000000c000074df0:  0x0000000000000002  0x000000c000508100</span><br><span class="line">0x000000c000074e00:  0x000000c000508000  0x00000000004672e0 &lt;sync.(*Pool).pinSlow·dwrap·3+0x0000000000000000&gt;</span><br><span class="line">0x000000c000074e10:  0x0000000000557f58  0x000000c000074e08</span><br><span class="line">0x000000c000074e20:  0x0000000000419860 &lt;runtime.gcAssistAlloc.func1+0x0000000000000000&gt;  0x000000c0000001a0</span><br><span class="line">0x000000c000074e30:  0x0000000000010000  0x000000c000074eb8</span><br><span class="line">0x000000c000074e40:  0x000000000040b305 &lt;runtime.mallocgc+0x0000000000000125&gt;  0x000000c0000001a0</span><br><span class="line">0x000000c000074e50:  0x0000000000000002  0x000000c000074e88</span><br><span class="line">0x000000c000074e60:  0x000000c000074e88  0x000000000047a06a &lt;fmt.(*pp).free+0x00000000000000ca&gt;</span><br><span class="line">0x000000c000074e70:  0x0000000000522100  0x00000000004938e0</span><br><span class="line">0x000000c000074e80:  0x000000c00007a820  0x000000c000074ee0</span><br><span class="line">0x000000c000074e90:  0x000000000047a245 &lt;fmt.Sprintf+0x0000000000000085&gt;  0x000000c00007a820</span><br><span class="line">0x000000c000074ea0:  0x000000c00012b230  0x000000000000000b</span><br><span class="line">0x000000c000074eb0:  0x000000c0000001a0  0x000000c000074ee0</span><br><span class="line">0x000000c000074ec0:  0x00000000004095e5 &lt;runtime.convT64+0x0000000000000045&gt;  0x0000000000000008</span><br><span class="line">0x000000c000074ed0:  0x0000000000487ee0  0x000000c00007a800</span><br><span class="line">0x000000c000074ee0:  0x000000c000074f38  0x0000000000480d7b &lt;main.stacker+0x000000000000003b&gt;</span><br><span class="line">0x000000c000074ef0: &lt;0x0000000644e0732a  0x0000000000000002</span><br><span class="line">0x000000c000074f00:  0x000000c000074f28  0x0000000000000001</span><br><span class="line">0x000000c000074f10:  0x0000000000000001  0x0000000644e0732a</span><br><span class="line">0x000000c000074f20:  0x00000000000280fa  0x0000000000000000</span><br><span class="line">0x000000c000074f30:  0x0000000000000000  0x000000c000074f70</span><br><span class="line">0x000000c000074f40: !0x00007fffffffe000 &gt;0x00000000000f4240</span><br><span class="line">0x000000c000074f50:  0x0000000000000007  0x0000000000415d45 &lt;runtime.gcenable+0x0000000000000085&gt;</span><br><span class="line">0x000000c000074f60:  0x00000000004873a0  0x000000c0000001a0</span><br><span class="line">0x000000c000074f70:  0x000000c000074fd0  0x0000000000432047 &lt;runtime.main+0x0000000000000227&gt;</span><br><span class="line">0x000000c000074f80:  0x000000c000022060  0x0000000000000000</span><br><span class="line">0x000000c000074f90:  0x0000000000000000  0x0000000000000000</span><br><span class="line">0x000000c000074fa0:  0x0100000000000000  0x0000000000000000</span><br><span class="line">0x000000c000074fb0:  0x000000c0000001a0  0x0000000000432180 &lt;runtime.main.func2+0x0000000000000000&gt;</span><br><span class="line">0x000000c000074fc0:  0x000000c000074fa6  0x000000c000074fb8</span><br><span class="line">0x000000c000074fd0:  0x0000000000000000  0x000000000045ab01 &lt;runtime.goexit+0x0000000000000001&gt;</span><br><span class="line">0x000000c000074fe0:  0x0000000000000000  0x0000000000000000</span><br><span class="line">0x000000c000074ff0:  0x0000000000000000  0x0000000000000000</span><br><span class="line">fatal error: unknown caller pc</span><br><span class="line"></span><br><span class="line">runtime stack:</span><br><span class="line">runtime.throw(&#123;0x4988ba, 0x516760&#125;)</span><br><span class="line">        /usr/local/go/src/runtime/panic.go:1198 +0x71</span><br><span class="line">runtime.gentraceback(0x400, 0x400, 0x80, 0x7f73bbffafff, 0x0, 0x0, 0x7fffffff, 0x7ffc46fe0e28, 0x7f73bbe23200, 0x0)</span><br><span class="line">        /usr/local/go/src/runtime/traceback.go:274 +0x1956</span><br><span class="line">runtime.scanstack(0xc0000001a0, 0xc000030698)</span><br><span class="line">        /usr/local/go/src/runtime/mgcmark.go:748 +0x197</span><br><span class="line">runtime.markroot.func1()</span><br><span class="line">        /usr/local/go/src/runtime/mgcmark.go:232 +0xb1</span><br><span class="line">runtime.markroot(0xc000030698, 0x14)</span><br><span class="line">        /usr/local/go/src/runtime/mgcmark.go:205 +0x170</span><br><span class="line">runtime.gcDrainN(0xc000030698, 0x10000)</span><br><span class="line">        /usr/local/go/src/runtime/mgcmark.go:1134 +0x14b</span><br><span class="line">runtime.gcAssistAlloc1(0xc0000001a0, 0xc000074b58)</span><br><span class="line">        /usr/local/go/src/runtime/mgcmark.go:537 +0xef</span><br><span class="line">runtime.gcAssistAlloc.func1()</span><br><span class="line">        /usr/local/go/src/runtime/mgcmark.go:448 +0x25</span><br><span class="line">runtime.systemstack()</span><br><span class="line">        /usr/local/go/src/runtime/asm_amd64.s:383 +0x49</span><br><span class="line"></span><br><span class="line">goroutine 1 [GC assist marking (scan)]:</span><br><span class="line">runtime.systemstack_switch()</span><br><span class="line">        /usr/local/go/src/runtime/asm_amd64.s:350 fp=0xc000074de8 sp=0xc000074de0 pc=0x458a20</span><br><span class="line">runtime.gcAssistAlloc(0xc0000001a0)</span><br><span class="line">        /usr/local/go/src/runtime/mgcmark.go:447 +0x18b fp=0xc000074e48 sp=0xc000074de8 pc=0x41974b</span><br><span class="line">runtime.mallocgc(0x8, 0x487ee0, 0x0)</span><br><span class="line">        /usr/local/go/src/runtime/malloc.go:959 +0x125 fp=0xc000074ec8 sp=0xc000074e48 pc=0x40b305</span><br><span class="line">runtime.convT64(0x644e0732a)</span><br><span class="line">        /usr/local/go/src/runtime/iface.go:364 +0x45 fp=0xc000074ef0 sp=0xc000074ec8 pc=0x4095e5</span><br><span class="line">runtime: unexpected return pc for main.stacker called from 0x7fffffffe000</span><br><span class="line">stack: frame=&#123;sp:0xc000074ef0, fp:0xc000074f48&#125; stack=[0xc000074000,0xc000075000)</span><br><span class="line">0x000000c000074df0:  0x0000000000000002  0x000000c000508100</span><br><span class="line">0x000000c000074e00:  0x000000c000508000  0x00000000004672e0 &lt;sync.(*Pool).pinSlow·dwrap·3+0x0000000000000000&gt;</span><br><span class="line">0x000000c000074e10:  0x0000000000557f58  0x000000c000074e08</span><br><span class="line">0x000000c000074e20:  0x0000000000419860 &lt;runtime.gcAssistAlloc.func1+0x0000000000000000&gt;  0x000000c0000001a0</span><br><span class="line">0x000000c000074e30:  0x0000000000010000  0x000000c000074eb8</span><br><span class="line">0x000000c000074e40:  0x000000000040b305 &lt;runtime.mallocgc+0x0000000000000125&gt;  0x000000c0000001a0</span><br><span class="line">0x000000c000074e50:  0x0000000000000002  0x000000c000074e88</span><br><span class="line">0x000000c000074e60:  0x000000c000074e88  0x000000000047a06a &lt;fmt.(*pp).free+0x00000000000000ca&gt;</span><br><span class="line">0x000000c000074e70:  0x0000000000522100  0x00000000004938e0</span><br><span class="line">0x000000c000074e80:  0x000000c00007a820  0x000000c000074ee0</span><br><span class="line">0x000000c000074e90:  0x000000000047a245 &lt;fmt.Sprintf+0x0000000000000085&gt;  0x000000c00007a820</span><br><span class="line">0x000000c000074ea0:  0x000000c00012b230  0x000000000000000b</span><br><span class="line">0x000000c000074eb0:  0x000000c0000001a0  0x000000c000074ee0</span><br><span class="line">0x000000c000074ec0:  0x00000000004095e5 &lt;runtime.convT64+0x0000000000000045&gt;  0x0000000000000008</span><br><span class="line">0x000000c000074ed0:  0x0000000000487ee0  0x000000c00007a800</span><br><span class="line">0x000000c000074ee0:  0x000000c000074f38  0x0000000000480d7b &lt;main.stacker+0x000000000000003b&gt;</span><br><span class="line">0x000000c000074ef0: &lt;0x0000000644e0732a  0x0000000000000002</span><br><span class="line">0x000000c000074f00:  0x000000c000074f28  0x0000000000000001</span><br><span class="line">0x000000c000074f10:  0x0000000000000001  0x0000000644e0732a</span><br><span class="line">0x000000c000074f20:  0x00000000000280fa  0x0000000000000000</span><br><span class="line">0x000000c000074f30:  0x0000000000000000  0x000000c000074f70</span><br><span class="line">0x000000c000074f40: !0x00007fffffffe000 &gt;0x00000000000f4240</span><br><span class="line">0x000000c000074f50:  0x0000000000000007  0x0000000000415d45 &lt;runtime.gcenable+0x0000000000000085&gt;</span><br><span class="line">0x000000c000074f60:  0x00000000004873a0  0x000000c0000001a0</span><br><span class="line">0x000000c000074f70:  0x000000c000074fd0  0x0000000000432047 &lt;runtime.main+0x0000000000000227&gt;</span><br><span class="line">0x000000c000074f80:  0x000000c000022060  0x0000000000000000</span><br><span class="line">0x000000c000074f90:  0x0000000000000000  0x0000000000000000</span><br><span class="line">0x000000c000074fa0:  0x0100000000000000  0x0000000000000000</span><br><span class="line">0x000000c000074fb0:  0x000000c0000001a0  0x0000000000432180 &lt;runtime.main.func2+0x0000000000000000&gt;</span><br><span class="line">0x000000c000074fc0:  0x000000c000074fa6  0x000000c000074fb8</span><br><span class="line">0x000000c000074fd0:  0x0000000000000000  0x000000000045ab01 &lt;runtime.goexit+0x0000000000000001&gt;</span><br><span class="line">0x000000c000074fe0:  0x0000000000000000  0x0000000000000000</span><br><span class="line">0x000000c000074ff0:  0x0000000000000000  0x0000000000000000</span><br><span class="line">main.stacker(0xf4240)</span><br><span class="line">        /home/tim/stacker/main.go:17 +0x3b fp=0xc000074f48 sp=0xc000074ef0 pc=0x480d7b</span><br></pre></td></tr></table></figure>


<p>这样，我们仍然不得不使用之前实践的<code>uprobe+offset</code>的方式来进行<code>uretprobe</code>的实现。<code>bpftrace</code>程序会正常工作，但是地址的偏移量将很大程度上取决于使用的<code>Go</code>版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env bpftrace</span><br><span class="line"></span><br><span class="line">uprobe:./stacker:&quot;main.stacker&quot;+213</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;result: \&quot;%s\&quot;\n&quot;, str(reg(&quot;ax&quot;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个问题看起来不会在<code>Go</code>的运行时侧修复，因为可重新分配的栈空间是整个<code>goroutine</code>内存模型的基础。但是通过<code>uprobe</code>以及一点小小的调整，你可以实现<code>uretprobe</code>的功能。</p>
]]></content>
      <categories>
        <category>BPF</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>bpf</tag>
      </tags>
  </entry>
  <entry>
    <title>eBPF tail-calls示例</title>
    <url>/2023/08/26/cllrixflf0001qrfy74pjh88x/</url>
    <content><![CDATA[<blockquote>
<p>最近在整理一些技术文章。本来希望把涉及ELF的内容整理出来，结果发现太难了。ELF涉及的内容要多很多，如果要把希望整理的内容表述清楚，还需要做一些准备的工作。刚好最近完成了tail-calls 的调研，先把关于eBPF的tail-calls的功能整理下吧。</p>
</blockquote>
<p><code>eBPF</code>程序是事件驱动的，这就意味着当目标事件触发后，程序才能执行。考虑这样一个场景：有几个不同的<code>BPF</code>程序均挂载在相同的<code>hook</code>点上，而执行需要保持一定的顺序。这时就需要借助<code>tail calls</code>的功能来实现。</p>
<span id="more"></span>

<h1 id="一、tail-calls-与-bpf2bpf-calls的对比"><a href="#一、tail-calls-与-bpf2bpf-calls的对比" class="headerlink" title="一、tail calls 与 bpf2bpf calls的对比"></a>一、tail calls 与 bpf2bpf calls的对比</h1><p>首先要说明的是，将不同的逻辑分支都放到一个<code>bpf</code>程序里是很难进行的，因为<code>bpf</code>程序存在严格的限制：比如512B的执行栈。处理逻辑复杂，往往意味着需要使用的结构体就多，很容易就超出了512B的限制，编译时会报类似如下的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd uretprobe &amp;&amp; go generate</span><br><span class="line">./uretprobe.c:24:15: error: Looks like the BPF stack limit of 512 bytes is exceeded. Please move large on stack variables into BPF per-cpu array map.</span><br><span class="line">        struct event event = &#123;&#125;;</span><br><span class="line">                     ^</span><br><span class="line">./uretprobe.c:24:15: error: Looks like the BPF stack limit of 512 bytes is exceeded. Please move large on stack variables into BPF per-cpu array map.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于使用而言，<code>tail calls</code>从一定程度上规避这个问题：使用<code>bpf_tail_call</code>跳转（注意，跳转callee函数执行完成后，不会继续执行<code>caller</code>剩余的逻辑，而是直接退出）的目标函数，函数内部的栈资源限制计算是独立的，会覆盖调用<code>caller</code>的栈帧。而常规的<code>bpf2bpf call</code>，调用的<code>callee</code>执行完成后，会继续执行<code>caller</code>里的代码。而且，512B的限制会对<code>caller callee</code>整体生效。如，下述的<code>bpf2bpf call</code>是会报错的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct event &#123;</span><br><span class="line">	u32 pid;      // 4B</span><br><span class="line">	u8 line[256]; // 256B</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// linux-4.16以前，需要这样声明。4.16新增了真正意义上的函数调用而非inline处理。</span><br><span class="line">// static __always_inline void send_event(ctx) &#123;</span><br><span class="line">static void send_event(struct pt_regs *ctx) &#123;</span><br><span class="line">	struct event event = &#123;&#125;;</span><br><span class="line">	event.pid          = bpf_get_current_pid_tgid();</span><br><span class="line">	event.line[0]      = 49;</span><br><span class="line">	bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;event, sizeof(event));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(&quot;uretprobe/bash_readline&quot;)</span><br><span class="line">int uretprobe_bash_readline(struct pt_regs *ctx) &#123;</span><br><span class="line">    struct event event = &#123;&#125;;</span><br><span class="line">    event.pid          = bpf_get_current_pid_tgid();</span><br><span class="line">    event.line[0]      = 49;</span><br><span class="line">    send_event(ctx); // 这里发起了一个bpf2bpf call</span><br><span class="line">    </span><br><span class="line">    // 如果将line的长度调小，程序能够正常执行。send_event后会继续执行。</span><br><span class="line">    bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;event, sizeof(event));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里算是笔者目前感知到的主要差异。<code>tail calls</code>的特性在<code>linux-4.2</code>的版本就上线了。在<code>centos-8</code>版本的系统上运行没有问题。</p>
<h1 id="二、tail-calls-的一个示例"><a href="#二、tail-calls-的一个示例" class="headerlink" title="二、tail calls 的一个示例"></a>二、tail calls 的一个示例</h1><p>这里附上执行效果和一段示例。笔者构建的场景是使用<code>uretprobe/bash_readline</code>作为<code>hook</code>点，依据返回字符串长度的奇偶性来触发不同的<code>bpf function</code>，分别输出不同的事件。实现效果如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo ./uretprobe</span><br><span class="line">2023/08/26 14:34:39 Listening for events..</span><br><span class="line">2023/08/26 14:34:45 /bin/bash:readline return value: ll</span><br><span class="line">2023/08/26 14:34:45 get even event</span><br><span class="line">2023/08/26 14:35:01 /bin/bash:readline return value: ls -l</span><br><span class="line">2023/08/26 14:35:01 get odd event</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>bpf</code>代码为：</p>
<pre><code>char __license[] SEC(&quot;license&quot;) = &quot;Dual MIT/GPL&quot;;
struct event &#123;
    u32 pid;
    u8 line[256];

    u8 mark;
&#125;;

struct &#123;
    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);
&#125; events SEC(&quot;.maps&quot;);

// Force emitting struct event into the ELF.
const struct event *unused __attribute__((unused));

// 通过bpf-tail-call只能调用同类型的bpf函数
SEC(&quot;uretprobe/bash_readline_odd&quot;)
int uretprobe_bash_readline_odd(struct pt_regs *ctx)&#123;
    struct event event = &#123;&#125;;
    event.pid = bpf_get_current_pid_tgid();
    event.line[0] = 49;
    event.mark = 5;
    bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;event, sizeof(event));

    return 0;
&#125;

// 通过bpf-tail-call只能调用同类型的bpf函数
SEC(&quot;uretprobe/bash_readline_even&quot;)
int uretprobe_bash_readline_even(struct pt_regs *ctx)&#123;
    struct event event = &#123;&#125;;
    event.pid = bpf_get_current_pid_tgid();
    event.mark = 8;
    event.line[0] = 50;
    bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;event, sizeof(event));

    return 0;
&#125;

struct&#123;
    __uint(type, BPF_MAP_TYPE_PROG_ARRAY);
    __uint(key_size, sizeof(u32));
    __uint(value_size, sizeof(u32));
    __uint(max_entries, 1024);
    __array(values, int (void*));
&#125; tail_jmp_table SEC(&quot;.maps&quot;) = &#123;
    .values = &#123;
        // 这里的id是可以在用户态通过map update来更新的。由此可以延伸出其他有意思的功能。这里从实际需求直接固定值了。
        [135] = (void*)&amp;uretprobe_bash_readline_odd,
        [146] = (void*)&amp;uretprobe_bash_readline_even,
    &#125;,
&#125;;

SEC(&quot;uretprobe/bash_readline&quot;)
int uretprobe_bash_readline(struct pt_regs *ctx) &#123;
    struct event event = &#123;&#125;;

    event.pid = bpf_get_current_pid_tgid();
    bpf_probe_read(&amp;event.line, sizeof(event.line), (void *)PT_REGS_RC(ctx));

    event.mark = 3;

    bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;event, sizeof(event));
    u8 line_length=0;
    for(line_length=0; line_length&lt;80; line_length++)&#123;
        if(event.line[line_length] == 0)&#123;
            break;
        &#125;
    &#125;

    if (line_length % 2 == 0)&#123;
        // 偶数调用 uretprobe_bash_readline_even
        bpf_tail_call(ctx, &amp;tail_jmp_table, 146);
    &#125;else&#123;
        // 奇数调用 uretprobe_bash_readline_odd
        bpf_tail_call(ctx, &amp;tail_jmp_table, 135);
    &#125;


    return 0;
&#125;
</code></pre>
<p>以上。周末愉快～</p>
<h1 id="三、参考文章"><a href="#三、参考文章" class="headerlink" title="三、参考文章"></a>三、参考文章</h1><p>[1] <a href="https://docs.cilium.io/en/latest/bpf/architecture/">BPF Architecture</a><br>[2] <a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html">bpf-helpers</a><br>[3] <a href="https://mozillazg.com/2022/10/ebpf-libbpf-use-tail-calls.html">在 ebpf/libbpf 程序中使用尾调用（tail calls）</a><br>[4] <a href="https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md">kernel version</a></p>
]]></content>
      <categories>
        <category>bpf</category>
      </categories>
      <tags>
        <tag>ebpf</tag>
        <tag>bpf</tag>
        <tag>tail call</tag>
      </tags>
  </entry>
  <entry>
    <title>bpftrace 遍历 golang 链表（go17+）</title>
    <url>/2023/11/18/clp3qjrah0000h3s654zfat1q/</url>
    <content><![CDATA[<blockquote>
<p>不出意外的，之前提到的 ELF 文件解析内容又拖延了。目前还不知道什么时候有时间能够把希望完成的几篇文章给搞完。翻一翻目前的博客，已经有很久没有更新了。那就水一篇文章吧。目前算是项目里的低谷期，希望能够重拾程序员的意义。</p>
</blockquote>
<p>在<a href="https://liyan-ah.github.io/2022/07/22/cljb83dlm000ckcs6bp7thrf9/#more">bpftrace 无侵入遍历golang链表</a>里，笔者展示了使用<code>bpftrace</code>来遍历<code>golang</code>链表的方法。由于<code>go-17</code>和<code>go-16</code>的函数调用规约存在不同，因此<a href="https://liyan-ah.github.io/2022/07/22/cljb83dlm000ckcs6bp7thrf9/#more">bpftrace 无侵入遍历golang链表</a>并不适用于<code>go-17</code>。其实这个问题在<a href="https://liyan-ah.github.io/2023/03/03/cljb83dm2001mkcs68hgf9o2s/#more">go-1.17+ 调用规约</a>已经提到了解决方案。本文给一个实例，算是更进一步的延伸这个话题，希望能够起到一些效果。</p>
<span id="more"></span>

<h1 id="一、执行效果"><a href="#一、执行效果" class="headerlink" title="一、执行效果"></a>一、执行效果</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo bpftrace ./link.bt</span><br><span class="line">Attaching 1 probe...    // 在触发目标程序前，停止在这里</span><br><span class="line">// 触发目标程序后，输出</span><br><span class="line">== enter main.showNode</span><br><span class="line">name: Alice, age: 11</span><br><span class="line">name: Bob, age: 12</span><br><span class="line">name: Claire, age: 13</span><br><span class="line">== end</span><br><span class="line"></span><br><span class="line">// 目标程序执行结果</span><br><span class="line">$ ./link</span><br><span class="line">name: Alice, age: 11</span><br><span class="line">name: Bob, age: 12</span><br><span class="line">name: Claire, age: 13</span><br></pre></td></tr></table></figure>

<p>需要注意的是，笔者的验证环境为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux 4.18.0-193.el8.x86_64</span><br><span class="line">go version go1.17 linux/amd64</span><br><span class="line">bpftrace v0.14.0-72-g6761-dirty</span><br></pre></td></tr></table></figure>
<p>由于不同的<code>CPU</code>架构下，寄存器的信息会有所不同。本文中所涉及的代码示例仅在<code>amd64</code>里有效。</p>
<h1 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h1><p>本文涉及两部分代码：目标的<code>go</code>代码以及<code>bpftrace</code>代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// link/main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Node struct &#123;</span><br><span class="line">	Name string</span><br><span class="line">	Age  int64</span><br><span class="line">	Next *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func showNode(head *Node) &#123;</span><br><span class="line">	var cur = head</span><br><span class="line">	for cur != nil &#123;</span><br><span class="line">		fmt.Printf(&quot;name: %s, age: %d\n&quot;, cur.Name, cur.Age)</span><br><span class="line">		cur = cur.Next</span><br><span class="line">	&#125;</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var node = &amp;Node&#123;</span><br><span class="line">		Name: &quot;Alice&quot;,</span><br><span class="line">		Age:  11,</span><br><span class="line">		Next: &amp;Node&#123;</span><br><span class="line">			Name: &quot;Bob&quot;,</span><br><span class="line">			Age:  12,</span><br><span class="line">			Next: &amp;Node&#123;</span><br><span class="line">				Name: &quot;Claire&quot;,</span><br><span class="line">				Age:  13,</span><br><span class="line">				Next: nil,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	showNode(node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bpftrace</code>代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// link/link.bt</span><br><span class="line">// 这里，符号使用双引号包裹起来是个好习惯</span><br><span class="line">uprobe:./link:&quot;main.showNode&quot;</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;== enter main.showNode\n&quot;);</span><br><span class="line">  $head_ptr = reg(&quot;ax&quot;);</span><br><span class="line">  unroll(10)&#123;</span><br><span class="line">    $name_ptr = *(uint64*)($head_ptr+0);</span><br><span class="line">    $name_len = *(uint64*)($head_ptr+8);</span><br><span class="line">    $age_v = *(int64*)($head_ptr+16);</span><br><span class="line">    printf(&quot;name: %s, age: %d\n&quot;, str($name_ptr, $name_len), $age_v);</span><br><span class="line"></span><br><span class="line">    // set head = next</span><br><span class="line">    $head_ptr = *(uint64*)($head_ptr+24);</span><br><span class="line">    if ($head_ptr == 0)&#123;</span><br><span class="line">        printf(&quot;== end\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上。周末愉快。</p>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>bpftrace</tag>
        <tag>bpf</tag>
      </tags>
  </entry>
  <entry>
    <title>如何追踪golang channel?</title>
    <url>/2023/12/08/clpwpqoex000197s695mz6lob/</url>
    <content><![CDATA[<blockquote>
<p>2023年就要结束了，算起来距离上一次更新也有很久了。搜肠刮肚，总得在23年结束前再搞两篇总结，算是有始有终。总结今年，总还是绕不过 BPF，golang。既然如此，就对BPF观测golang这个话题再往下挖掘下，先做第一篇文章。下旬如果有时间并且顺利的话，希望能把BPF的原理总结完成。</p>
</blockquote>
<p>在<a href="https://liyan-ah.github.io/2023/03/29/cljb83dmh003dkcs61joe1kfh/#more">无侵入观测服务拓扑四元组的一种实现</a>中，笔者有提到追踪<code>golang</code>处理过程的两个无法解决的问题是<code>golang</code>里的<code>channel</code>处理以及<code>goroutine pool</code>。再深究下，这两个问题实际上都可以归纳到对<code>channel</code>的处理，因为很多<code>goroutine pool</code>都离不了<code>channel</code>的使用，比如<a href="https://github.com/Jeffail/tunny">Jeffail/tunny</a>这个库。<br>本文将会构建一个<code>channel</code>的追踪的方案。</p>
<span id="more"></span>

<h1 id="一、追踪效果"><a href="#一、追踪效果" class="headerlink" title="一、追踪效果"></a>一、追踪效果</h1><p>按照惯例，我们还是来看下效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// terminal 1，启动服务</span><br><span class="line">$ ./drink-srv</span><br><span class="line"></span><br><span class="line">// terminal 2，启动追踪脚本</span><br><span class="line">$ sudo bpftrace ./drink.bt</span><br><span class="line">Attaching 7 probes...  // 启动后停止在这里</span><br><span class="line">serve HTTP: /alcohol   // 触发接口后输出</span><br><span class="line">caller: /alcohol, callee: :/unknown/prepare/hotel</span><br><span class="line">serve HTTP: /tea</span><br><span class="line">caller: /tea, callee: :/unknown/prepare/club</span><br><span class="line"></span><br><span class="line">// terminal 3，触发服务接口</span><br><span class="line">$ curl &quot;localhost:1423/alcohol?age=22&quot;</span><br><span class="line">$ curl &quot;localhost:1423/tea?age=12&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="二、方案设计"><a href="#二、方案设计" class="headerlink" title="二、方案设计"></a>二、方案设计</h1><p>关于<code>golang channel</code>的实现及设计，可以参见<a href="https://i6448038.github.io/2019/04/11/go-channel/">图解Go的channel底层实现</a>，里面有非常生动的动图实现；搭配源码食用更好<a href="https://github.com/golang/go/blob/master/src/runtime/chan.go">runtime/chan.go</a>源码的实现。<br>笔者在这里再简单的总结下，对<code>send</code>及<code>recv</code>两种操作设计的状态做一个简单的概述：<br><code>chan-send</code>的状态：<br><img src="/images/chan-send.png" alt="upload successful"><br><code>chan-recv</code>的状态：<br><img src="/images/chan-recv.png" alt="upload successful"></p>
<p>比如，对于下面的代码，派生出的<code>g1</code>在开启<code>select</code>后，由于<code>ticketChan</code>是空的，会触发<code>g1</code>让出<code>m</code>里的执行权限，进入<code>gopark</code>状态。同时，<code>ticketChan</code>会将<code>g1</code>封装成<code>sudog</code>，放到<code>recvq</code>队列中。当一段时间之后，其他的<code>g</code>将数据写入<code>channel</code>里时，会在<code>chansend</code>时，检查到<code>recvq</code>不为空，会直接将数据拷贝到空闲的<code>sudog</code>中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var ticketChan = make(chan TicketInfo, 10)</span><br><span class="line">func HandleDrink() &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case info, ok := &lt;-ticketChan:</span><br><span class="line">			...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    go HandleDrink()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>chanrecv</code>进入<code>recvq</code>对应的<code>golang</code>处理逻辑在这里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// runtime/chan.go</span><br><span class="line">	...</span><br><span class="line">	// no sender available: block on this channel.</span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = 0</span><br><span class="line">	if t0 != 0 &#123;</span><br><span class="line">		mysg.releasetime = -1</span><br><span class="line">	&#125;</span><br><span class="line">	// No stack splits between assigning elem and enqueuing mysg</span><br><span class="line">	// on gp.waiting where copystack can find it.</span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = nil</span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.isSelect = false</span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.param = nil</span><br><span class="line">	c.recvq.enqueue(mysg)</span><br><span class="line">    ...</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><code>chansend</code>直接将数据拷贝到<code>recvq</code>对应的<code>golang</code>处理逻辑在这里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// runtime/chan.go</span><br><span class="line">	...</span><br><span class="line">	if sg := c.recvq.dequeue(); sg != nil &#123;</span><br><span class="line">		// Found a waiting receiver. We pass the value we want to send</span><br><span class="line">		// directly to the receiver, bypassing the channel buffer (if any).</span><br><span class="line">		send(c, sg, ep, func() &#123; unlock(&amp;c.lock) &#125;, 3)</span><br><span class="line">		return true</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>对于这个示例，只要把<code>chanrecv</code>、<code>chansend</code>以及<code>send</code>来进行<code>hook</code>，同时使用<code>channel</code>的地址以及写入数据时的<code>channel qcount</code>，即可实现将<code>sender</code>和<code>receiver</code>关联起来的功能，也即可以实现对<code>golang channel</code>的追踪。</p>
<h1 id="三、方案实现"><a href="#三、方案实现" class="headerlink" title="三、方案实现"></a>三、方案实现</h1><p>了解了<code>channel</code>的处理流程，追踪的方案就比较明确了，直接在关键的函数处设置<code>hook</code>点即可。先来看下目标服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">	&quot;strconv&quot;</span><br><span class="line"></span><br><span class="line">	&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	ALCOHOL = iota + 1001</span><br><span class="line">	COCO</span><br><span class="line">	COFFEE</span><br><span class="line">	TEA</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type TicketInfo struct &#123;</span><br><span class="line">	Age  int</span><br><span class="line">	Name string</span><br><span class="line">	Type int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ticketChan = make(chan TicketInfo, 10)</span><br><span class="line"></span><br><span class="line">func AlcoholH(c *gin.Context) &#123;</span><br><span class="line">	var ticket = TicketInfo&#123;&#125;</span><br><span class="line">	var err error</span><br><span class="line">	ticket.Age, err = strconv.Atoi(c.Query(&quot;age&quot;))</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		c.String(http.StatusOK, &quot;handle failed&quot;)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	ticket.Name = c.Query(&quot;name&quot;)</span><br><span class="line">	ticket.Type = ALCOHOL</span><br><span class="line">	ticketChan &lt;- ticket</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TeaH(c *gin.Context) &#123;</span><br><span class="line">	var ticket = TicketInfo&#123;&#125;</span><br><span class="line">	var err error</span><br><span class="line">	ticket.Age, err = strconv.Atoi(c.Query(&quot;age&quot;))</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Println(&quot;handle failed, &quot;, err.Error())</span><br><span class="line">		c.String(http.StatusOK, &quot;handle failed&quot;)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	ticket.Name = c.Query(&quot;name&quot;)</span><br><span class="line">	ticket.Type = TEA</span><br><span class="line">	ticketChan &lt;- ticket</span><br><span class="line">	c.String(http.StatusOK, &quot;okay&quot;)</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func HandleDrink() &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case info, ok := &lt;-ticketChan:</span><br><span class="line">			if !ok &#123;</span><br><span class="line">				log.Println(&quot;chan closed.&quot;)</span><br><span class="line">				return</span><br><span class="line">			&#125;</span><br><span class="line">			log.Println(&quot;get ticket&quot;)</span><br><span class="line">			switch info.Type &#123;</span><br><span class="line">			case ALCOHOL:</span><br><span class="line">				Alcohol(info)</span><br><span class="line">			case COCO:</span><br><span class="line">				SoftDrink(info)</span><br><span class="line">			case COFFEE, TEA:</span><br><span class="line">				Tea(info)</span><br><span class="line">			default:</span><br><span class="line">				log.Println(&quot;unknown drink type&quot;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Alcohol(ticket TicketInfo) &#123;</span><br><span class="line">	var url = &quot;http://localhost/unknown/prepare/hotel&quot;</span><br><span class="line">	http.DefaultClient.Get(url)</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func SoftDrink(ticket TicketInfo) &#123;</span><br><span class="line">	log.Printf(&quot;[%s, %d] drink %d&quot;, ticket.Name, ticket.Age, ticket.Type)</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Tea(ticket TicketInfo) &#123;</span><br><span class="line">	var url = &quot;http://localhost/unknown/prepare/club&quot;</span><br><span class="line">	http.DefaultClient.Get(url)</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		close(ticketChan)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	go HandleDrink()</span><br><span class="line"></span><br><span class="line">	var r = gin.Default()</span><br><span class="line">	r.GET(&quot;/alcohol&quot;, AlcoholH)</span><br><span class="line">	r.GET(&quot;/tea&quot;, TeaH)</span><br><span class="line"></span><br><span class="line">	var srv = &amp;http.Server&#123;</span><br><span class="line">		Addr:    &quot;127.0.0.1:1423&quot;,</span><br><span class="line">		Handler: r,</span><br><span class="line">	&#125;</span><br><span class="line">	if srv.ListenAndServe() != nil &#123;</span><br><span class="line">		log.Println(&quot;failed to handle service listen&quot;)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于这样的一个服务，希望达到示例中的追踪效果，对应的方案为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define OFF_TASK_THRD 4992</span><br><span class="line">#define OFF_THRD_FSBASE 40</span><br><span class="line">#define GOID_OFFSET 152</span><br><span class="line"></span><br><span class="line">uprobe:./drink-srv:&quot;runtime.runqput&quot;</span><br><span class="line">&#123;</span><br><span class="line">  $prob_mark = &quot;runqput&quot;;</span><br><span class="line">  @prob[$prob_mark] = @prob[$prob_mark] + 1;</span><br><span class="line"></span><br><span class="line">  if (@new_go[tid, pid] == 0)&#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  $p_goid = @new_go[tid, pid];</span><br><span class="line"></span><br><span class="line">  $g = (uint64)(reg(&quot;bx&quot;));</span><br><span class="line">  $goid = *(uint64*)($g+GOID_OFFSET);</span><br><span class="line">  @caller_addr[$goid] = @caller_addr[$p_goid];</span><br><span class="line">  @caller_len[$goid]  = @caller_len[$p_goid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./drink-srv:&quot;runtime.newproc1&quot;</span><br><span class="line">&#123;</span><br><span class="line">  $prob_mark = &quot;newproc1&quot;;</span><br><span class="line">  @prob[$prob_mark] = @prob[$prob_mark] + 1;</span><br><span class="line"></span><br><span class="line">  $g = (uint64)(reg(&quot;bx&quot;));</span><br><span class="line">  $goid = *(uint64*)($g+GOID_OFFSET);</span><br><span class="line">  if (@caller_addr[$goid] == 0)&#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  @new_go[tid, pid] = $goid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这里，将 caller 信息和写入 channel 信息的 key 关联起来</span><br><span class="line">uprobe:./drink-srv:&quot;runtime.chansend&quot;</span><br><span class="line">&#123;</span><br><span class="line">  $prob_mark = &quot;chansend&quot;;</span><br><span class="line">  @prob[$prob_mark] = @prob[$prob_mark] + 1;</span><br><span class="line"></span><br><span class="line">  $cur = (uint64)curtask;</span><br><span class="line">  $fsbase = *(uint64*)($cur+OFF_TASK_THRD+OFF_THRD_FSBASE);</span><br><span class="line">  $g = *(uint64*)($fsbase-8);</span><br><span class="line">  $goid = *(uint64*)($g+GOID_OFFSET);</span><br><span class="line"></span><br><span class="line">  // 如果当前执行goroutine中没有caller，跳过</span><br><span class="line">  if(@caller_addr[$goid] == 0)&#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  $chan = (uint64)reg(&quot;ax&quot;);</span><br><span class="line">  $qcount = *(uint32*)($chan + 0);</span><br><span class="line">  $buf = *(uint64*)($chan+16);</span><br><span class="line">  @send_addr[$chan, $qcount] = @caller_addr[$goid];</span><br><span class="line">  @send_len[$chan, $qcount]  = @caller_len[$goid];</span><br><span class="line"></span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uprobe:./drink-srv:&quot;runtime.chanrecv&quot;</span><br><span class="line">&#123;</span><br><span class="line">  $prob_mark = &quot;chanrecv&quot;;</span><br><span class="line">  @prob[$prob_mark] = @prob[$prob_mark] + 1;</span><br><span class="line"></span><br><span class="line">  $cur = (uint64)curtask;</span><br><span class="line">  $fsbase = *(uint64*)($cur+OFF_TASK_THRD+OFF_THRD_FSBASE);</span><br><span class="line">  $g = *(uint64*)($fsbase-8);</span><br><span class="line">  $goid = *(uint64*)($g+GOID_OFFSET);</span><br><span class="line"></span><br><span class="line">  $chan = (uint64)reg(&quot;ax&quot;);</span><br><span class="line">  $qcount = *(uint32*)($chan + 0);</span><br><span class="line">  $buf = *(uint64*)($chan+16);</span><br><span class="line">  if (@send_addr[$chan, $qcount] == 0)&#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  @caller_addr[$goid] = @send_addr[$chan, $qcount];</span><br><span class="line">  @caller_len[$goid]  = @send_len[$chan, $qcount];</span><br><span class="line"></span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uprobe:./drink-srv:&quot;runtime.send&quot;</span><br><span class="line">&#123;</span><br><span class="line">  $prob_mark = &quot;send&quot;;</span><br><span class="line">  @prob[$prob_mark] = @prob[$prob_mark] + 1;</span><br><span class="line"></span><br><span class="line">  $chan = (uint64)reg(&quot;ax&quot;);</span><br><span class="line">  $sg = (uint64)reg(&quot;bx&quot;);</span><br><span class="line">  $g = *(uint64*)($sg+0);</span><br><span class="line">  $goid = *(uint64*)($g+GOID_OFFSET);</span><br><span class="line"></span><br><span class="line">  $qcount = *(uint32*)($chan+0);</span><br><span class="line"></span><br><span class="line">  @caller_addr[$goid] = @send_addr[$chan, $qcount];</span><br><span class="line">  @caller_len[$goid]  = @send_len[$chan, $qcount];</span><br><span class="line"></span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">type serverHandler struct &#123;</span><br><span class="line">	srv *Server</span><br><span class="line">&#125;</span><br><span class="line">func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) &#123;</span><br><span class="line">*/</span><br><span class="line">uprobe:./drink-srv:&quot;net/http.serverHandler.ServeHTTP&quot;</span><br><span class="line">&#123;</span><br><span class="line">  $prob_mark = &quot;ServeHTTP&quot;;</span><br><span class="line">  @prob[$prob_mark] = @prob[$prob_mark] + 1;</span><br><span class="line"></span><br><span class="line">  $cur = (uint64)curtask;</span><br><span class="line">  $fsbase = *(uint64*)($cur+OFF_TASK_THRD+OFF_THRD_FSBASE);</span><br><span class="line">  $g = *(uint64*)($fsbase-8);</span><br><span class="line">  $goid = *(uint64*)($g+GOID_OFFSET);</span><br><span class="line"></span><br><span class="line">  $req_addr = reg(&quot;di&quot;);</span><br><span class="line">  // offset(Request.URL) = 16</span><br><span class="line">  $url_addr = *(uint64*)($req_addr+16);</span><br><span class="line">  // offset(URL.Path) = 56</span><br><span class="line">  $path_addr = *(uint64*)($url_addr+56);</span><br><span class="line">  $path_len  = *(uint64*)($url_addr+64);</span><br><span class="line"></span><br><span class="line">  @caller_addr[$goid] = $path_addr;</span><br><span class="line">  @caller_len[$goid]  = $path_len;</span><br><span class="line"></span><br><span class="line">  printf(&quot;serve HTTP: %s\n&quot;, str($path_addr, $path_len));</span><br><span class="line"></span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">func (c *Client) do(req *Request) (retres *Response, reterr error) &#123;</span><br><span class="line">*/</span><br><span class="line">uprobe:./drink-srv:&quot;net/http.(*Client).do&quot;</span><br><span class="line">&#123;</span><br><span class="line">  $prob_mark = &quot;do&quot;;</span><br><span class="line">  @prob[$prob_mark] = @prob[$prob_mark] + 1;</span><br><span class="line"></span><br><span class="line">  $cur = (uint64)curtask;</span><br><span class="line">  $fsbase = *(uint64*)($cur+OFF_TASK_THRD+OFF_THRD_FSBASE);</span><br><span class="line">  $g = *(uint64*)($fsbase-8);</span><br><span class="line">  $goid = *(uint64*)($g+GOID_OFFSET);</span><br><span class="line"></span><br><span class="line">  if (@caller_addr[$goid] == 0)&#123;</span><br><span class="line">    printf(&quot;%d: has no caller.\n&quot;, $goid);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  $req_addr = reg(&quot;bx&quot;);</span><br><span class="line">  // offset(Request.URL) = 16</span><br><span class="line">  $url_addr = *(uint64*)($req_addr+16);</span><br><span class="line">  // offset(URL.Host) = 40</span><br><span class="line">  $host_addr = *(uint64*)($req_addr+40);</span><br><span class="line">  $host_len  = *(uint64*)($req_addr+48);</span><br><span class="line">  // offset(URL.Path) = 56</span><br><span class="line">  $path_addr = *(uint64*)($url_addr+56);</span><br><span class="line">  $path_len  = *(uint64*)($url_addr+64);</span><br><span class="line"></span><br><span class="line">  $c_addr = @caller_addr[$goid];</span><br><span class="line">  $c_len  = @caller_len[$goid];</span><br><span class="line"></span><br><span class="line">  printf(&quot;caller: %s, callee: %s:%s\n&quot;, str($c_addr, $c_len),</span><br><span class="line">    str($host_addr, $host_len), str($path_addr, $path_len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="四、追踪的风险"><a href="#四、追踪的风险" class="headerlink" title="四、追踪的风险"></a>四、追踪的风险</h1><p>至此，看起来<code>golang channel</code>是可以追踪的。但是实际上并非如此。比如如下这个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func HandleDrink() &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case info, ok := &lt;-ticketChan:</span><br><span class="line">			...</span><br><span class="line">        default: // 注意这个 stop</span><br><span class="line">        	// no stop here</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段逻辑在代码编写、编译阶段均无问题，是一段完全合理的逻辑。当我们试图追踪这段代码时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo bpftrace ./drink.bt</span><br><span class="line">Attaching 7 probes...</span><br><span class="line">^C  // 直接停止，没有请求</span><br><span class="line">@prob[chanrecv]: 908571</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，此时并没有做任何的操作，但是这个<code>chanrecv</code>这个<code>hook</code>点已经触发了数十万次。而我们知道，<code>BPF hook</code>点的触发并非没有开销的。因此，目标的代码在完全合理的情况下，我们的追踪程序会给系统带来很大的负载。这显然是我们需要避免的。  </p>
<p>以上，周末愉快～</p>
]]></content>
      <categories>
        <category>BPF</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>bpf</tag>
        <tag>channel</tag>
        <tag>observe</tag>
      </tags>
  </entry>
</search>
