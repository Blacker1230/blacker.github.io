<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Bugs on 李岩</title><link>https://liyan-ah.github.io/tags/bugs/</link><description>Recent content in Bugs on 李岩</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><lastBuildDate>Tue, 12 Mar 2024 11:02:00 +0000</lastBuildDate><atom:link href="https://liyan-ah.github.io/tags/bugs/index.xml" rel="self" type="application/rss+xml"/><item><title>BPF LRU_HASH_MAP 及 HASH_MAP 的使用异常</title><link>https://liyan-ah.github.io/p/bpf-lru_hash_map-%E5%8F%8A-hash_map-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8/</link><pubDate>Tue, 12 Mar 2024 11:02:00 +0000</pubDate><guid>https://liyan-ah.github.io/p/bpf-lru_hash_map-%E5%8F%8A-hash_map-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8/</guid><description>&lt;blockquote>
&lt;p>BPF 技术看起来还有很多不易察觉的缺陷。最近又踩了一个坑。记录下。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>LRU_HASH_MAP&lt;/code> 在实现的时候，出现了不符合预期的数据驱逐问题：设定一个 512 大小的&lt;code>LRU_HASH_MAP&lt;/code>，很可能出现在40-50个&lt;code>key&lt;/code>的时候，之前的&lt;code>key&lt;/code>就被覆盖。在一段时间未更新时，重新更新也可能会出现异常。总结就是，执行了写入操作，很可能没有写入。这个问题在&lt;a class="link" href="https://stackoverflow.com/questions/75882443/elements-incorrectly-evicted-from-ebpf-lru-hash-map" target="_blank" rel="noopener"
>Elements incorrectly evicted from eBPF LRU hash map&lt;/a>有较为详细的描述。&lt;/p>
&lt;p>但是，笔者之所以使用&lt;code>LRU_HASH_MAP&lt;/code>主要是期望保持整个程序的鲁棒性：期望可以一直写入&lt;code>key&lt;/code>而不需对&lt;code>bpf map&lt;/code>的状态进行维护。如果使用固定大小的&lt;code>HASH_MAP&lt;/code>，当写入的&lt;code>key&lt;/code>超过&lt;code>map&lt;/code>的预设大小时，测试的&lt;code>demo&lt;/code>会出现崩溃的现象。由于&lt;code>LRU_HASH_MAP&lt;/code>的功能出现了不符合预期的情况，显然也就需要使用&lt;code>HASH_MAP&lt;/code>来替代了。 &lt;br>
笔者遇到的需要使用&lt;code>LRU_HASH_MAP&lt;/code>的场景有两种：1. 作为配置项。用户态的代码向&lt;code>BPF MAP&lt;/code>里写入配置，而后在&lt;code>BPF&lt;/code>里使用。2. 作为数据中转。比如涉及多个&lt;code>hook&lt;/code>点配合时，就需要使用&lt;code>BPF MAP&lt;/code>来存储一些中间数据。对于场景1，可以直接使用&lt;code>HASH_MAP&lt;/code>来替代，用户态添加一些检查的措施，定期批量对&lt;code>MAP&lt;/code>进行数据清理以及数据写入即可。但是对于场景2，可能会麻烦很多：数据是随时产出的，用户态没有办法控制其产出的频率、周期。目前能想到的是设置一个较大的&lt;code>MAP&lt;/code>（这个异常的触发是否和&lt;code>MAP&lt;/code>的大小有关？），仍然使用&lt;code>LRU_HASH_MAP&lt;/code>；或者设置一个较大的&lt;code>HASH_MAP&lt;/code>，然后定时在用户态进行数据的清理。&lt;br>
以上。&lt;/p></description></item></channel></rss>